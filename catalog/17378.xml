<?xml version="1.0" encoding="UTF-8"?>
<xml><thread id="17378"><title>Strobing Monsters Idea</title><posts><post id="p158537" date="Posted: Sun Oct 01, 2006 3:42 pm "><author>chapsticky</author><body><![CDATA[<div class="postbody">ive had a great idea to make the monsters in doom more interesting however am stuck on how to this, &#13;<br /><br />the idea is to change it so that they are hidden while moving and visable when stationary, like a strobing light effect for all you ravers out there &#13;<br /><br />or otherwise make it so it looks like they are hidden and visable while walking so your not really sure where they are, like those ninjas things from the fear game, where they are hidden until they attack you</div>]]></body></post><post id="p158550" date="Posted: Sun Oct 01, 2006 7:02 pm "><author>6th Venom</author><body><![CDATA[<div class="postbody">It's already done, it is called a wraith.  <img src="/web/20070509181516im_/http://doom3world.org/phpbb2/images/smilies/icon_wink.gif" alt=":wink:" title="Wink" /></div>]]></body></post><post id="p158584" date="Posted: Mon Oct 02, 2006 4:44 am "><author>Maj 2oo7</author><body><![CDATA[<div class="postbody"><div class="quotetitle">6th Venom wrote:</div><div class="quotecontent">It's already done, it is called a wraith.  <img src="/web/20070509181516im_/http://doom3world.org/phpbb2/images/smilies/icon_wink.gif" alt=":wink:" title="Wink" /></div>&#13;<br /><br />Haha, touché.</div>]]></body></post><post id="p158634" date="Posted: Mon Oct 02, 2006 9:09 pm "><author>chapsticky</author><body><![CDATA[<div class="postbody">well ive tried like copying what the wraith does and applying it to the archvile but with no luck everytime i try to see if it works i get an error message saying ai_monster_zombie_base.script line 56 is not a define#&#13;<br /><br />this is what i have anyway&#13;<br /><br />/***********************************************************************&#13;<br /><br />ai_monster_demon_archvile.script&#13;<br /><br />monster_demon_archvile&#13;<br /><br />***********************************************************************/&#13;<br /><br />#define 	ARCH_ATTACK_RATE				2&#13;<br />#define 	ARCH_DODGE_RATE					4&#13;<br />#define	ARCH_PAIN_DELAY					0.25&#13;<br />#define	ARCH_TURRET_TO_IDLE				4&#13;<br />#define	ARCH_FLAME_WALL_NUM				20&#13;<br />#define	ARCH_FLAME_WALL_SEPERATION		48&#13;<br />#define	ARCH_FLAME_WALL_RANGE			( ARCH_FLAME_WALL_NUM * ARCH_FLAME_WALL_SEPERATION )&#13;<br />#define 	ARCH_NOFOVTIME				4&#13;<br />define 	ARCH_INVISIBLE_DIST_MIN		140&#13;<br />#define 	ARCH_INVISIBLE_DIST_MAX		256&#13;<br />#define 	ARCH_INVISIBLE_DELAY_MIN		0.6&#13;<br />#define 	ARCH_INVISIBLE_DELAY_MAX		1.5&#13;<br />#define 	ARCH_VISIBLE_DELAY_MIN		1.3&#13;<br />#define 	ARCH_VISIBLE_DELAY_MAX		2.2&#13;<br /><br /><br />// anim blend times&#13;<br />#define	ARCH_PAIN_TO_IDLE				2&#13;<br />#define 	ARCH_PAIN_TO_PAIN				0&#13;<br />#define 	ARCH_SIGHT_TO_IDLE				4&#13;<br />#define	 ARCH_RESURRECT_TO_IDLE			4&#13;<br />#define	 ARCH_IDLE_TO_RESURRECT			4&#13;<br />#define	ARCH_MELEE_TO_IDLE				4&#13;<br />#define 	ARCH_INCINERATE_TO_IDLE			4&#13;<br />#define 	ARCH_FLAMEWALL_TO_IDLE			4&#13;<br />#define	 ARCH_DODGE_LEFT_TO_IDLE			4&#13;<br />#define	ARCH_DODGE_RIGHT_TO_IDLE		4&#13;<br />#define 	ARCH_WAIT_TO_OUT				4&#13;<br />#define	ARCH_IN_TO_WAIT					4&#13;<br />#define	ARCH_WALK_TO_WAIT				4&#13;<br />#define 	ARCH_WALK_TO_ACTION				4&#13;<br />#define 	ARCH_ACTION_TO_IDLE				4&#13;<br />#define 	ARCH_WALK_TO_DODGE_LEFT			4&#13;<br />#define 	ARCH_WALK_TO_DODGE_RIGHT		4&#13;<br />#define 	ARCH_IDLE_TO_PAIN				0&#13;<br />#define 	ARCH_IDLE_TO_WALK				4&#13;<br />#define 	ARCH_IDLE_TO_SIGHT				4&#13;<br />#define 	ARCH_WALK_TO_IDLE				4&#13;<br />#define 	ARCH_WALK_TO_FLAMEWALLATTACK	4&#13;<br />#define 	ARCH_IDLE_TO_FLAMEWALLATTACK	4&#13;<br />#define 	ARCH_WALK_TO_INCINERATEATTACK	4&#13;<br />#define 	ARCH_IDLE_TO_INCINERATEATTACK	4&#13;<br />#define 	ARCH_WALK_TO_MELEE				4&#13;<br />#define 	ARCH_IDLE_TO_TURRETATTACK		4&#13;<br />#define 	ARCH_TURRETATTACK_TO_IDLE		4&#13;<br /><br />#define 	ATTACK_FLAMEWALL				ATTACK_SPECIAL1&#13;<br />#define 	ATTACK_RESURRECT				ATTACK_SPECIAL2&#13;<br />#define	ATTACK_BECOME_INVISIBLE			ATTACK_SPECIAL3&#13;<br />#define	ATTACK_BECOME_VISIBLE				ATTACK_SPECIAL4 &#13;<br /><br />object monster_demon_archvile : monster_base {&#13;<br />	float			nextDodge;&#13;<br />	float			nextAttack;&#13;<br />	float			nextNoFOVAttack;&#13;<br />	entity			combat_node;&#13;<br />	float			keep_alive;&#13;<br />	float			num_start;&#13;<br />	float			summon_delay;&#13;<br />	float			summon_time;&#13;<br />	float			nextInvisible;&#13;<br />	entity			spawn_effect;&#13;<br /><br />	boolean			invisible;	////set invisable&#13;<br /><br />	//&#13;<br />	// States&#13;<br />	//&#13;<br />	void			state_Begin();&#13;<br />	void			state_Idle();&#13;<br />	void			state_LostCombat();&#13;<br /><br />	void			init();&#13;<br /><br />	// attacks&#13;<br />	float			check_attacks();&#13;<br />	void			do_attack( float attack_flags );&#13;<br />	void			combat_resurrect();&#13;<br />	void			combat_flamewall();&#13;<br />	void			combat_incinerate();&#13;<br />	void			combat_melee();&#13;<br />	void			combat_dodge_left();&#13;<br />	void			combat_dodge_right();&#13;<br />	void			combat_become_visible();&#13;<br />	void			combat_become_invisible();&#13;<br /><br />	void			spawn_fx();   ///////////added spawn affect from when visable to invisable&#13;<br /><br />	void 			spawn_flame_wall( vector org );&#13;<br />	void 			spawn_incerate( vector org );&#13;<br />	void 			flame_wall_loop();&#13;<br />	void 			flame_wall();&#13;<br />	void 			incinerate();&#13;<br />	float			num_minions();&#13;<br />	monster_base		choose_random_dead_minion();&#13;<br />	void			resurrection();&#13;<br /><br />	// torso anim states&#13;<br />	void			Torso_Idle();&#13;<br />	void			Torso_Pain();&#13;<br />	void			Torso_Resurrect();&#13;<br />	void			Torso_MeleeAttack();&#13;<br />	void			Torso_FlameWallAttack();&#13;<br />	void			Torso_IncinerateAttack();&#13;<br />	void			Torso_TurretAttack();&#13;<br /><br />	// legs anim states&#13;<br />	void			Legs_Idle();&#13;<br />	void			Legs_Walk();&#13;<br />	void			Legs_DodgeLeft();&#13;<br />	void			Legs_DodgeRight();&#13;<br />};&#13;<br /><br />/***********************************************************************&#13;<br /><br />	Torso animation control&#13;<br /><br />***********************************************************************/&#13;<br /><br />void monster_demon_archvile::Torso_Idle() {&#13;<br />	idleAnim( ANIMCHANNEL_TORSO, "stand" );&#13;<br /><br />	while( !AI_PAIN ) {&#13;<br />		waitFrame();&#13;<br />	}&#13;<br /><br />	animState( ANIMCHANNEL_TORSO, "Torso_Pain", ARCH_IDLE_TO_PAIN );&#13;<br />}&#13;<br /><br />void monster_demon_archvile::Torso_Pain() {&#13;<br />	string animname;&#13;<br />	float nextpain;&#13;<br />	float currenttime;&#13;<br /><br />	animname = getPainAnim();&#13;<br />	playAnim( ANIMCHANNEL_TORSO, animname );&#13;<br /><br />	nextpain = sys.getTime() + ARCH_PAIN_DELAY;&#13;<br /><br />	while( !animDone( ANIMCHANNEL_TORSO, ARCH_PAIN_TO_IDLE ) ) {&#13;<br />		if ( AI_PAIN ) {&#13;<br />			currenttime = sys.getTime();&#13;<br />			if ( currenttime &gt; nextpain ) {&#13;<br />				animState( ANIMCHANNEL_TORSO, "Torso_Pain", ARCH_PAIN_TO_PAIN );&#13;<br />			}&#13;<br />		}&#13;<br />		waitFrame();&#13;<br />	}&#13;<br /><br />	finishAction( "pain" );&#13;<br />	animState( ANIMCHANNEL_TORSO, "Torso_Idle", ARCH_PAIN_TO_IDLE );&#13;<br />}&#13;<br /><br />void monster_demon_archvile::Torso_Resurrect() {&#13;<br />	setShaderParm( 4, -sys.getTime() );&#13;<br />	setSmokeVisibility( ALL_PARTICLES, 1 );&#13;<br />	playAnim( ANIMCHANNEL_TORSO, "resurrection" );&#13;<br /><br />	while( !animDone( ANIMCHANNEL_TORSO, ARCH_RESURRECT_TO_IDLE ) ) {&#13;<br />		waitFrame();&#13;<br />	}&#13;<br /><br />	finishAction( "resurrection" );&#13;<br />	setSmokeVisibility( ALL_PARTICLES, 0 );&#13;<br />	animState( ANIMCHANNEL_TORSO, "Torso_Idle", ARCH_RESURRECT_TO_IDLE );&#13;<br />}&#13;<br /><br />void monster_demon_archvile::Torso_MeleeAttack() {&#13;<br />	playAnim( ANIMCHANNEL_TORSO, "melee_attack" );&#13;<br /><br />	while( !animDone( ANIMCHANNEL_TORSO, ARCH_MELEE_TO_IDLE ) ) {&#13;<br />		waitFrame();&#13;<br />	}&#13;<br /><br />	finishAction( "melee_attack" );&#13;<br />	animState( ANIMCHANNEL_TORSO, "Torso_Idle", ARCH_MELEE_TO_IDLE );&#13;<br />}&#13;<br /><br />void monster_demon_archvile::Torso_FlameWallAttack() {&#13;<br />	string anim;&#13;<br /><br />	disablePain();&#13;<br /><br />	setShaderParm( 4, -sys.getTime() );&#13;<br />	setSmokeVisibility( ALL_PARTICLES, 1 );&#13;<br />	anim = chooseAnim( ANIMCHANNEL_TORSO, "flamewall_attack" );&#13;<br />	if ( testAnimMoveTowardEnemy( anim ) ) {&#13;<br />		playAnim( ANIMCHANNEL_TORSO, anim );&#13;<br />	} else {&#13;<br />		allowMovement( false );&#13;<br />		playAnim( ANIMCHANNEL_TORSO, "turret_attack" );&#13;<br />	}&#13;<br /><br />	while( !animDone( ANIMCHANNEL_TORSO, ARCH_FLAMEWALL_TO_IDLE ) ) {&#13;<br />		waitFrame();&#13;<br />	}&#13;<br /><br />	allowMovement( true );&#13;<br />	finishAction( "flamewall_attack" );&#13;<br />	setSmokeVisibility( ALL_PARTICLES, 0 );&#13;<br />	animState( ANIMCHANNEL_TORSO, "Torso_Idle", ARCH_FLAMEWALL_TO_IDLE );&#13;<br />}&#13;<br /><br />void monster_demon_archvile::Torso_IncinerateAttack() {&#13;<br />	disablePain();&#13;<br />	setShaderParm( 4, -sys.getTime() );&#13;<br />	setSmokeVisibility( ALL_PARTICLES, 1 );&#13;<br />	playAnim( ANIMCHANNEL_TORSO, "incinerate_attack" );&#13;<br /><br />	while( !animDone( ANIMCHANNEL_TORSO, ARCH_INCINERATE_TO_IDLE ) ) {&#13;<br />		waitFrame();&#13;<br />	}&#13;<br /><br />	allowMovement( true );&#13;<br />	finishAction( "incinerate_attack" );&#13;<br />	setSmokeVisibility( ALL_PARTICLES, 0 );&#13;<br />	animState( ANIMCHANNEL_TORSO, "Torso_Idle", ARCH_INCINERATE_TO_IDLE );&#13;<br />}&#13;<br /><br />void monster_demon_archvile::Torso_TurretAttack() {&#13;<br />	allowMovement( false );&#13;<br />	if ( num_minions() &lt; keep_alive ) {&#13;<br />		// check if we can resurrect a minion&#13;<br />		if ( choose_random_dead_minion() ) {&#13;<br />			Torso_Resurrect();&#13;<br />			return;&#13;<br />		}&#13;<br />	}&#13;<br />	Torso_IncinerateAttack();&#13;<br />}&#13;<br /><br />/***********************************************************************&#13;<br /><br />	Legs animation control&#13;<br /><br />***********************************************************************/&#13;<br /><br />void monster_demon_archvile::Legs_Idle() {&#13;<br />	idleAnim( ANIMCHANNEL_LEGS, "stand" );&#13;<br /><br />	while( !AI_FORWARD ) {&#13;<br />		waitFrame();&#13;<br />	}&#13;<br /><br />	animState( ANIMCHANNEL_LEGS, "Legs_Walk", ARCH_IDLE_TO_WALK );&#13;<br />}&#13;<br /><br />void monster_demon_archvile::Legs_Walk() {&#13;<br />	playCycle( ANIMCHANNEL_LEGS, "walk" );&#13;<br /><br />	while( AI_FORWARD )	{&#13;<br />		waitFrame();&#13;<br />	}&#13;<br /><br />	animState( ANIMCHANNEL_LEGS, "Legs_Idle", ARCH_WALK_TO_IDLE );&#13;<br />}&#13;<br /><br />void monster_demon_archvile::Legs_DodgeLeft() {&#13;<br />	playAnim( ANIMCHANNEL_LEGS, "evade_left" );&#13;<br /><br />	while( !animDone( ANIMCHANNEL_LEGS, ARCH_DODGE_LEFT_TO_IDLE ) ) {&#13;<br />		preventPain( GAME_FRAMETIME );&#13;<br />		waitFrame();&#13;<br />	}&#13;<br /><br />	finishAction( "strafe" );&#13;<br />	animState( ANIMCHANNEL_LEGS, "Legs_Idle", ARCH_DODGE_LEFT_TO_IDLE );&#13;<br />}&#13;<br /><br />void monster_demon_archvile::Legs_DodgeRight() {&#13;<br />	playAnim( ANIMCHANNEL_LEGS, "evade_right" );&#13;<br /><br />	while( !animDone( ANIMCHANNEL_LEGS, ARCH_DODGE_RIGHT_TO_IDLE ) ) {&#13;<br />		preventPain( GAME_FRAMETIME );&#13;<br />		waitFrame();&#13;<br />	}&#13;<br /><br />	finishAction( "strafe" );&#13;<br />	animState( ANIMCHANNEL_LEGS, "Legs_Idle", ARCH_DODGE_RIGHT_TO_IDLE );&#13;<br />}&#13;<br /><br />/***********************************************************************&#13;<br /><br />	AI&#13;<br /><br />***********************************************************************/&#13;<br /><br />/*&#13;<br />=====================&#13;<br />monster_demon_archvile::init&#13;<br />=====================&#13;<br />*/&#13;<br />void monster_demon_archvile::init() {&#13;<br />	float i;&#13;<br />	float num;&#13;<br />	float total;&#13;<br />	monster_base monster;&#13;<br /><br />	keep_alive = getIntKey( "keep_alive" );&#13;<br />	num_start = getIntKey( "num_start" );&#13;<br />	summon_delay = getFloatKey( "delay" );&#13;<br /><br />	summon_time = 0;&#13;<br /><br />	// wait for other monsters to start up&#13;<br />	waitFrame();&#13;<br /><br />	// count how many resurrection targets there are&#13;<br />	total = 0;&#13;<br />	num = numTargets();&#13;<br />	for( i = 0; i &lt; num; i++ ) {&#13;<br />		monster = getTarget( i );&#13;<br />		if ( !monster ) {&#13;<br />			continue;&#13;<br />		}&#13;<br />		total++;&#13;<br />		monster.archvile_minion();&#13;<br />	}&#13;<br />	if ( !keep_alive ) {&#13;<br />		keep_alive = total;&#13;<br />	}&#13;<br /><br />	if ( keep_alive &gt; total ) {&#13;<br />		keep_alive = total;&#13;<br />	}&#13;<br />	if ( num_start &gt; total ) {&#13;<br />		num_start = total;&#13;<br />	}&#13;<br /><br />	setState( "state_Begin" );&#13;<br />}&#13;<br /><br />/***********************************************************************&#13;<br /><br />	States&#13;<br /><br />***********************************************************************/&#13;<br /><br />/*&#13;<br />=====================&#13;<br />monster_demon_archvile::state_Begin&#13;<br />=====================&#13;<br />*/&#13;<br />void monster_demon_archvile::state_Begin() {&#13;<br />	animState( ANIMCHANNEL_TORSO, "Torso_Idle", 0 );&#13;<br />	animState( ANIMCHANNEL_LEGS, "Legs_Idle", 0 );&#13;<br />	monster_begin();&#13;<br />	setMoveType( MOVETYPE_ANIM );&#13;<br />	setState( "state_Idle" );&#13;<br />}&#13;<br /><br />/*&#13;<br />=====================&#13;<br />monster_demon_archvile::state_Idle&#13;<br />=====================&#13;<br />*/&#13;<br />void monster_demon_archvile::state_Idle() {&#13;<br />	setSmokeVisibility( ALL_PARTICLES, 0 );&#13;<br />	wait_for_enemy();&#13;<br /><br />	nextAttack		= 0;&#13;<br />	nextNoFOVAttack = 0;&#13;<br />	nextDodge		= RandomTime( ARCH_DODGE_RATE );&#13;<br /><br />	setState( "state_Combat" );&#13;<br />}&#13;<br /><br />/***********************************************************************&#13;<br /><br />	attacks&#13;<br /><br />***********************************************************************/&#13;<br /><br />/*&#13;<br />=====================&#13;<br />monster_demon_archvile::do_attack&#13;<br />=====================&#13;<br />*/&#13;<br />void monster_demon_archvile::do_attack( float attack_flags ) {&#13;<br />	nextNoFOVAttack = sys.getTime() + ARCH_NOFOVTIME;&#13;<br />	if ( attack_flags &amp; ATTACK_DODGE_LEFT ) {&#13;<br />		combat_dodge_left();&#13;<br />	} else if ( attack_flags &amp; ATTACK_DODGE_RIGHT ) {&#13;<br />		combat_dodge_right();&#13;<br />	} else if ( attack_flags &amp; ATTACK_COMBAT_NODE ) {&#13;<br />		combat_ainode( combat_node );&#13;<br />	} else if ( attack_flags &amp; ATTACK_RESURRECT ) {&#13;<br />		combat_resurrect();&#13;<br />	} else if ( attack_flags &amp; ATTACK_MELEE ) {&#13;<br />		combat_melee();&#13;<br />	} else if ( attack_flags &amp; ATTACK_FLAMEWALL ) {&#13;<br />		combat_flamewall();&#13;<br />	} else if ( attack_flags &amp; ATTACK_BECOME_INVISIBLE ) {&#13;<br />		combat_become_invisible();&#13;<br />	}else if ( attack_flags &amp; ATTACK_BECOME_VISIBLE ) {&#13;<br />		combat_become_visible();&#13;<br />	}&#13;<br />}&#13;<br /><br />/*&#13;<br />=====================&#13;<br />monster_demon_archvile::check_attacks&#13;<br />=====================&#13;<br />*/&#13;<br />float monster_demon_archvile::check_attacks() {&#13;<br />	float range;&#13;<br />	float currentTime;&#13;<br />	float canMelee;&#13;<br />	float attack_flags;&#13;<br /><br />	attack_flags = 0;	&#13;<br />	range = enemyRange();&#13;<br />	currentTime = sys.getTime();&#13;<br /><br />	if ( invisible ) {&#13;<br />		if ( ( range &lt; ARCH_INVISIBLE_DIST_MIN ) || ( currentTime &gt;= nextInvisible ) ) {&#13;<br />			if ( canBecomeSolid() ) {&#13;<br />				attack_flags |= ATTACK_BECOME_VISIBLE;&#13;<br />			}&#13;<br />		}&#13;<br /><br />		return attack_flags;&#13;<br />	}&#13;<br /><br />	canMelee = testMeleeAttack();&#13;<br />	if ( !canMelee ) {&#13;<br />		if ( AI_PAIN &amp;&amp; ( currentTime &gt;= nextDodge ) ) {&#13;<br />			if ( testAnimMove( "evade_left" ) ) {&#13;<br />				attack_flags |= ATTACK_DODGE_LEFT;&#13;<br />			}&#13;<br />			if ( testAnimMove( "evade_right" ) ) {&#13;<br />				attack_flags |= ATTACK_DODGE_RIGHT;&#13;<br /><br />				// if we can dodge either direction, pick one&#13;<br />				if ( attack_flags &amp; ATTACK_DODGE_LEFT ) {&#13;<br />					if ( sys.random( 100 ) &lt; 50 ) {&#13;<br />						attack_flags &amp;= ~ATTACK_DODGE_RIGHT;&#13;<br />					} else {&#13;<br />						attack_flags &amp;= ~ATTACK_DODGE_LEFT;&#13;<br />					}&#13;<br />				}&#13;<br />			}&#13;<br />		}&#13;<br />		combat_node = getCombatNode();&#13;<br />		if ( combat_node ) {&#13;<br />			attack_flags |= ATTACK_COMBAT_NODE;&#13;<br />		}&#13;<br />	}&#13;<br /><br />	if ( canMelee ) {&#13;<br />		attack_flags |= ATTACK_MELEE;&#13;<br />	}&#13;<br /><br />	range = enemyRange();&#13;<br />	if ( AI_ONGROUND &amp;&amp; ( range &gt; ARCH_INVISIBLE_DIST_MAX ) &amp;&amp; ( currentTime &gt;= nextInvisible ) ) {&#13;<br />		attack_flags |= ATTACK_BECOME_INVISIBLE;&#13;<br />	}&#13;<br /><br />	if ( ( ( sys.getTime() &gt; nextNoFOVAttack ) &amp;&amp; AI_ENEMY_VISIBLE ) || AI_ENEMY_IN_FOV ) {&#13;<br />		if ( !canReachEnemy() || ( currentTime &gt;= nextAttack ) ) {&#13;<br />			if ( enemyRange() &lt; ARCH_FLAME_WALL_RANGE ) {&#13;<br />				if ( testChargeAttack() ) {&#13;<br />					attack_flags |= ATTACK_FLAMEWALL;&#13;<br />				}&#13;<br />			}&#13;<br />		}&#13;<br />	}&#13;<br /><br />	if ( num_minions() &lt; keep_alive ) {&#13;<br />		if ( summon_time &lt; currentTime ) {&#13;<br />			// check if we can resurrect a minion&#13;<br />			if ( choose_random_dead_minion() ) {&#13;<br />				attack_flags |= ATTACK_RESURRECT;&#13;<br />			}&#13;<br />		}&#13;<br />	} else {&#13;<br />		summon_time = currentTime + summon_delay;&#13;<br />	}&#13;<br /><br />	return attack_flags;&#13;<br />}&#13;<br /><br />/*&#13;<br />=====================&#13;<br />monster_demon_archvile::combat_resurrect&#13;<br />=====================&#13;<br />*/&#13;<br />void monster_demon_archvile::combat_resurrect() {&#13;<br />	stopMove();&#13;<br />	lookAtEnemy( 0 );&#13;<br />	animState( ANIMCHANNEL_TORSO, "Torso_Resurrect", ARCH_IDLE_TO_RESURRECT );&#13;<br />	waitAction( "resurrection" );&#13;<br />	summon_time = sys.getTime() + summon_delay;&#13;<br />}&#13;<br /><br />/*&#13;<br />=====================&#13;<br />monster_demon_archvile::combat_flamewall&#13;<br />=====================&#13;<br />*/&#13;<br />void monster_demon_archvile::combat_flamewall() {&#13;<br />	faceEnemy();&#13;<br />	stopMove();&#13;<br />	lookAtEnemy( 0 );&#13;<br /><br />	animState( ANIMCHANNEL_TORSO, "Torso_FlameWallAttack", ARCH_IDLE_TO_FLAMEWALLATTACK );&#13;<br />	waitAction( "flamewall_attack" );&#13;<br /><br />	// don't attack for a bit&#13;<br />	nextAttack = DelayTime( ARCH_ATTACK_RATE );&#13;<br />	nextNoFOVAttack = sys.getTime() + ARCH_NOFOVTIME;&#13;<br />}&#13;<br /><br />/*&#13;<br />=====================&#13;<br />monster_demon_archvile::combat_incinerate&#13;<br />=====================&#13;<br />*/&#13;<br />void monster_demon_archvile::combat_incinerate() {&#13;<br />	faceEnemy();&#13;<br />	stopMove();&#13;<br />	lookAtEnemy( 0 );&#13;<br /><br />	animState( ANIMCHANNEL_TORSO, "Torso_IncinerateAttack", ARCH_IDLE_TO_INCINERATEATTACK );&#13;<br />	waitAction( "incinerate_attack" );&#13;<br /><br />	// don't attack for a bit&#13;<br />	nextAttack = DelayTime( ARCH_ATTACK_RATE );&#13;<br />}&#13;<br /><br />/*&#13;<br />=====================&#13;<br />monster_demon_archvile::combat_melee&#13;<br />=====================&#13;<br />*/&#13;<br />void monster_demon_archvile::combat_melee() {&#13;<br />	lookAtEnemy( 100 );&#13;<br />	faceEnemy();&#13;<br />	animState( ANIMCHANNEL_TORSO, "Torso_MeleeAttack", ARCH_WALK_TO_MELEE );&#13;<br />	waitAction( "melee_attack" );&#13;<br />	lookAtEnemy( 1 );&#13;<br />}&#13;<br /><br />/*&#13;<br />=====================&#13;<br />monster_demon_archvile::combat_dodge_left&#13;<br />=====================&#13;<br />*/&#13;<br />void monster_demon_archvile::combat_dodge_left() {&#13;<br />	AI_PAIN = false;&#13;<br />	stopMove();&#13;<br />	faceEnemy();&#13;<br />	animState( ANIMCHANNEL_LEGS, "Legs_DodgeLeft", ARCH_WALK_TO_DODGE_LEFT );&#13;<br />	waitAction( "strafe" );&#13;<br />	nextDodge = DelayTime( ARCH_DODGE_RATE );&#13;<br />}&#13;<br /><br />/*&#13;<br />=====================&#13;<br />monster_demon_archvile::combat_dodge_right&#13;<br />=====================&#13;<br />*/&#13;<br />void monster_demon_archvile::combat_dodge_right() {&#13;<br />	AI_PAIN = false;&#13;<br />	stopMove();&#13;<br />	faceEnemy();&#13;<br />	animState( ANIMCHANNEL_LEGS, "Legs_DodgeRight", ARCH_WALK_TO_DODGE_RIGHT );&#13;<br />	waitAction( "strafe" );&#13;<br />	nextDodge = DelayTime( ARCH_DODGE_RATE );&#13;<br />}&#13;<br /><br />/*&#13;<br />=====================&#13;<br />monster_demon_archvile::spawn_flame_wall&#13;<br />=====================&#13;<br />*/&#13;<br />void monster_demon_archvile::spawn_flame_wall( vector org ) {&#13;<br />	entity ent;&#13;<br />	vector ang;&#13;<br /><br />	ang_y = sys.random( 360 );&#13;<br />	ent = sys.spawn( "archvile_flamewall" );&#13;<br />	ent.setKey( "cinematic_remove", "1" );	// make sure it gets removed in cinematics&#13;<br />	ent.setShaderParm( 4, -sys.getTime() );&#13;<br />	ent.setShaderParm( 5, sys.random( 1 ) );&#13;<br />	ent.setOrigin( org );&#13;<br />	ent.setAngles( ang );&#13;<br />	ent.setOwner( self );&#13;<br />	ent.disable();&#13;<br />	sys.wait( 0.2 );&#13;<br />	ent.enable();&#13;<br />	sys.wait( 0.5 );&#13;<br />	ent.disable();&#13;<br />	sys.wait( 2.0 );&#13;<br />	ent.remove();&#13;<br />}&#13;<br /><br />/*&#13;<br />=====================&#13;<br />monster_demon_archvile::spawn_incerate&#13;<br />=====================&#13;<br />*/&#13;<br />void monster_demon_archvile::spawn_incerate( vector org ) {&#13;<br />	entity ent;&#13;<br />	vector ang;&#13;<br /><br />	ang_y = sys.random( 360 );&#13;<br />	ent = sys.spawn( "archvile_incinerate" );&#13;<br />	ent.setKey( "cinematic_remove", "1" );	// make sure it gets removed in cinematics&#13;<br />	ent.setShaderParm( 4, -sys.getTime() );&#13;<br />	ent.setShaderParm( 5, sys.random( 1 ) );&#13;<br />	ent.setOrigin( org );&#13;<br />	ent.setAngles( ang );&#13;<br />	ent.setOwner( self );&#13;<br />	ent.disable();&#13;<br />	sys.wait( 0.4 );&#13;<br />	ent.enable();&#13;<br />	sys.wait( 0.4 );&#13;<br />	ent.disable();&#13;<br />	sys.wait( 0.6 );&#13;<br />	ent.remove();&#13;<br />}&#13;<br /><br />/*&#13;<br />=====================&#13;<br />monster_demon_archvile::flame_wall_loop&#13;<br />=====================&#13;<br />*/&#13;<br />void monster_demon_archvile::flame_wall_loop() {&#13;<br />	float	i;&#13;<br />	vector	dir;&#13;<br />	vector	ang;&#13;<br />	vector	pos;&#13;<br />	float	frac;&#13;<br /><br />	ang = getAngles();&#13;<br />	dir = sys.angToForward( ang ) * ARCH_FLAME_WALL_SEPERATION;&#13;<br />	pos = getOrigin();&#13;<br />	for( i = 0; i &lt; ARCH_FLAME_WALL_NUM; i++ ) {&#13;<br />		pos_z += 48;&#13;<br />		if ( sys.trace( pos, pos + dir, '-8 -8 0', '8 8 16', MASK_SOLID, self ) &lt; 1 ) {&#13;<br />			break;&#13;<br />		}&#13;<br />		pos = pos + dir;&#13;<br />		frac = sys.trace( pos, pos - '0 0 96', '-8 -8 0', '8 8 16', MASK_SOLID, self );&#13;<br />		if ( frac == 1 ) {&#13;<br />			break;&#13;<br />		}&#13;<br />		pos_z -= 96 * frac;&#13;<br />		thread spawn_flame_wall( pos );&#13;<br />		sys.wait( 0.075 );&#13;<br />	}&#13;<br />}&#13;<br /><br />/*&#13;<br />=====================&#13;<br />monster_demon_archvile::flame_wall&#13;<br />=====================&#13;<br />*/&#13;<br />void monster_demon_archvile::flame_wall() {&#13;<br />	thread flame_wall_loop();&#13;<br />}&#13;<br /><br />/*&#13;<br />=====================&#13;<br />monster_demon_archvile::incinerate&#13;<br />=====================&#13;<br />*/&#13;<br />void monster_demon_archvile::incinerate() {&#13;<br />	thread spawn_incerate( predictEnemyPos( 0.4 ) );&#13;<br />}&#13;<br /><br />/*&#13;<br />=====================&#13;<br />monster_demon_archvile::num_minions&#13;<br />=====================&#13;<br />*/&#13;<br />float monster_demon_archvile::num_minions() {&#13;<br />	float i;&#13;<br />	float num;&#13;<br />	monster_base monster;&#13;<br />	float minions;&#13;<br /><br />	minions = 0;&#13;<br />	num = numTargets();&#13;<br />	for( i = 0; i &lt; num; i++ ) {&#13;<br />		monster = getTarget( i );&#13;<br />		if ( !monster || monster.AI_DEAD ) {&#13;<br />			continue;&#13;<br />		}&#13;<br />		minions++;&#13;<br />	}&#13;<br /><br />	return minions;&#13;<br />}&#13;<br /><br />/*&#13;<br />=====================&#13;<br />monster_demon_archvile::choose_random_dead_minion&#13;<br />=====================&#13;<br />*/&#13;<br />monster_base monster_demon_archvile::choose_random_dead_minion() {&#13;<br />	float i;&#13;<br />	float num;&#13;<br />	float startnum;&#13;<br />	monster_base monster;&#13;<br /><br />	num = numTargets();&#13;<br />	startnum = sys.random( num );&#13;<br />	for( i = 0; i &lt; num; i++ ) {&#13;<br />		monster = getTarget( ( i + startnum ) % num );&#13;<br />		if ( monster ) {&#13;<br />			if ( monster.can_resurrect() ) {&#13;<br />				return monster;&#13;<br />			}&#13;<br />		}&#13;<br />	}&#13;<br />	return $null_entity;&#13;<br />}&#13;<br /><br />/*&#13;<br />=====================&#13;<br />monster_demon_archvile::resurrection&#13;<br />=====================&#13;<br />*/&#13;<br />void monster_demon_archvile::resurrection() {&#13;<br />	float i;&#13;<br />	float num;&#13;<br />	monster_base monster;&#13;<br />	float alive;&#13;<br />	entity enemy;&#13;<br /><br />	alive = num_minions();&#13;<br /><br />	if ( !num_start ) {&#13;<br />		num = keep_alive;&#13;<br />	} else {&#13;<br />		num = num_start;&#13;<br />		num_start = 0;&#13;<br />	}&#13;<br /><br />	enemy = getEnemy();&#13;<br />	for( i = alive; i &lt; num; i++ ) {&#13;<br />		monster = choose_random_dead_minion();&#13;<br />		if ( !monster ) {&#13;<br />			break;&#13;<br />		}&#13;<br />		if ( monster == enemy ) {&#13;<br />			clearEnemy();&#13;<br />			checkForEnemy( false );&#13;<br />			enemy = getEnemy();&#13;<br />		}&#13;<br />		monster.monster_resurrect( enemy );&#13;<br />	}&#13;<br />}&#13;<br />*/&#13;<br />=====================&#13;<br />monster_demon_wraith::spawn_fx&#13;<br />=====================&#13;<br />*/&#13;<br />void monster_demon_archvile::spawn_fx() {&#13;<br />	if ( !spawn_effect ) {&#13;<br />		spawn_effect = sys.spawn( "archvile_spawneffect" );&#13;<br />	}&#13;<br /><br />	spawn_effect.setOrigin( getOrigin() );&#13;<br />	spawn_effect.show();&#13;<br />	spawn_effect.setShaderParm( SHADERPARM_TIMEOFFSET, -sys.getTime() );&#13;<br />}&#13;<br /><br />/*&#13;<br />=====================&#13;<br />monster_demon_archvile::combat_become_visible&#13;<br />=====================&#13;<br />*/&#13;<br />void monster_demon_archvile::combat_become_visible() {&#13;<br />	float endTime;&#13;<br /><br />	stopMove();&#13;<br /><br />	if ( invisible ) {&#13;<br />		// don't allow movement so that he stays in the same place where we checked if he could become solid&#13;<br />		allowMovement( false );&#13;<br /><br />		// check again just to make sure&#13;<br />		while( !canBecomeSolid() ) {&#13;<br />			waitFrame();&#13;<br />		}&#13;<br /><br />		becomeSolid();&#13;<br />		allowHiddenMovement( false );&#13;<br />		allowMovement( true );&#13;<br /><br />		animState( ANIMCHANNEL_LEGS, "Legs_Idle", 0 );&#13;<br /><br />		startSound( "snd_fade_in", SND_CHANNEL_VOICE2, false );&#13;<br />		spawn_fx();&#13;<br />		sys.wait( 0.65 );&#13;<br /><br />		show();&#13;<br />		endTime = sys.getTime() + 0.5;&#13;<br />		while( endTime &gt; sys.getTime() ) {&#13;<br />			setShaderParm( SHADERPARM_TIME_OF_DEATH, sys.getTime() - ( endTime - sys.getTime() ) * 8 );&#13;<br />			waitFrame();&#13;<br />		}&#13;<br /><br />		clearBurn();&#13;<br />		sys.wait( 0.10 );&#13;<br />		spawn_effect.hide();&#13;<br /><br />		invisible = false;&#13;<br />	}&#13;<br /><br />	nextInvisible = RandomDelay( ARCH_INVISIBLE_DELAY_MIN, ARCH_INVISIBLE_DELAY_MAX );&#13;<br />}&#13;<br /><br />/*&#13;<br />=====================&#13;<br />monster_demon_archvile::combat_become_invisible&#13;<br />=====================&#13;<br />*/&#13;<br />void monster_demon_arch::combat_become_invisible() {&#13;<br />	float endTime;&#13;<br />	float startTime;&#13;<br /><br />	stopMove();&#13;<br /><br />	if ( !invisible ) {&#13;<br />		// wait a bit incase we're blending from a run/walk&#13;<br />		sys.wait( 0.167 );&#13;<br /><br />		invisible = true;&#13;<br /><br />		startSound( "snd_fade_out", SND_CHANNEL_VOICE2, false );&#13;<br />		spawn_fx();&#13;<br />		sys.wait( 0.65 );&#13;<br /><br />		preBurn();&#13;<br />		startTime = sys.getTime();&#13;<br />		endTime = sys.getTime() + 0.5;&#13;<br />		while( endTime &gt; sys.getTime() ) {&#13;<br />			setShaderParm( SHADERPARM_TIME_OF_DEATH, sys.getTime() - ( sys.getTime() - startTime ) * 8 );&#13;<br />			waitFrame();&#13;<br />		}&#13;<br /><br />		sys.wait( 0.10 );&#13;<br /><br />		hide();&#13;<br />		spawn_effect.hide();&#13;<br />	}&#13;<br /><br />	allowHiddenMovement( true );&#13;<br />	setShaderParm( SHADERPARM_TIME_OF_DEATH, sys.getTime() - 100 );&#13;<br />	nextInvisible = RandomDelay( ARCH_VISIBLE_DELAY_MIN, ARCH_VISIBLE_DELAY_MAX );&#13;<br />}&#13;<br /><br />/*</div>]]></body></post><post id="p158652" date="Posted: Mon Oct 02, 2006 11:24 pm "><author>6th Venom</author><body><![CDATA[<div class="postbody"><div class="codetitle"><b>Code:</b></div><div class="codecontent">object monster_demon_archvile : monster_base {<br />f</div><br />Isn't it supposed to have 2 ":" like this:<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">object monster_demon_archvile :: monster_base {<br />f</div>&#13;<br />cause i saw 2 ":" at each others in your script, but really don't know more...  <img src="/web/20070509181516im_/http://doom3world.org/phpbb2/images/smilies/icon_confused.gif" alt=":?" title="Confused" /></div>]]></body></post></posts></thread></xml>
