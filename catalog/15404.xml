<?xml version="1.0" encoding="UTF-8"?>
<xml><thread id="15404"><title>ASE Importer</title><posts><post id="p140291" date="Posted: Mon Apr 17, 2006 2:00 am "><author>Goofos</author><body><![CDATA[<div class="postbody"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/images/smilies/icon_arrow.gif" alt=":arrow:" title="Arrow" /> Version: 0.13
<br /><br />Supports Mesh Objects with vertex colors, multiple UV, smoothgroups.
<br /><br />A little Note!: you should not try to import very big ase files (&gt;50 MB with 512 MB RAM). With much RAM you might can try this.
<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">#!BPY<br /><br />"""<br />Name: 'ASCII Scene (.ase) v0.13'<br />Blender: 244<br />Group: 'Import'<br />Tooltip: 'Import from ASCII Scene Export file format (.ase)'<br />""" <br />__author__ = "Goofos"<br />__version__ = "0.13"<br /><br /># goofos<br />#<br /># ***** BEGIN GPL LICENSE BLOCK *****<br />#<br /># This program is free software; you can redistribute it and/or<br /># modify it under the terms of the GNU General Public License<br /># as published by the Free Software Foundation; either version 2<br /># of the License, or (at your option) any later version.<br /># <br /># This program is distributed in the hope that it will be useful,<br /># but WITHOUT ANY WARRANTY; without even the implied warranty of<br /># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<br /># GNU General Public License for more details.<br /># <br /># You should have received a copy of the GNU General Public License<br /># along with this program; if not, write to the Free Software Foundation,<br /># Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.<br /># <br /># ***** END GPL LICENCE BLOCK *****<br /><br />import time, sys<br />import Blender<br />from Blender import Scene, Object, Mesh<br /><br />'''<br />Some Options<br />'''<br /># Scale Factor (float)<br />OPT_SCALE = 0.1<br /># Add EdgeSplit Modifier when importing sharp edges (bool)<br />OPT_MOD_EDGESPLIT = True<br /># Enable the fileselector (bool)<br />OPT_FILESELECTOR = True<br /># If the fileselector is disabled, specify a static filename (string)<br />OPT_STATIC_FILENAME = 'E:\ASE Files\garage.ASE'<br /># Enable Progressbar (bool)<br />OPT_PROGRESSBAR = False<br /># File buffer. After testing with big files i think there is no real difference.<br /># -1 = system default, 0 = unbuffered, 1 = line buffered, &gt;1 = buffer size<br />OPT_FILE_BUFFER = -1<br /><br />'''<br />Import Options<br />'''<br /># Import Meshes scaled, defined by the scale factor of OPT_SCALE (bool)<br /># Note: Object location data looses some precision, .. i think!<br />IMP_SCALED = True<br /># Import Vertex Colors (bool)<br />IMP_VCOLOR = True<br /># Import UV Coords and UV layers (bool)<br />IMP_UV = True<br /># Import NGons as Blender FGons (bool)<br /># Note: Include quads, too.<br />IMP_FGONS = False<br /># Try to find possible quads and convert the two tris to a quad (bool)<br /># Note: Very slow!! ablsolutely doesn't work accurate :/<br /># i don't know wether this is a script problem or a blender problem!<br />IMP_QUADS = False<br /># Surround UV islands with seams (bool)<br />IMP_SEAMS = False<br /># Surround smooth groups with sharp edges (bool)<br />IMP_SMOOTHGROUPS = True<br /># Try to find the lowest autosmooth angle in vertex normals (bool)<br /># Note: i dont know if this is correct :&gt;<br />IMP_AUTOSMOOTH = False<br /><br /><br /><br /><br /><br />class Ase_group:<br />   def __init__(self):<br />      self.name = 'Name'<br />      self.ase_type = 'GROUP'<br />      self.ase_helper = None<br />      self.ase_objects = []<br /><br />class Ase_object:<br /><br />   def __init__(self, ase_object_type, name=''):<br />      #if ase_object_type not in ['GEOM','HELPER','SHAPE','LIGHT','CAMERA']: return<br />      if ase_object_type not in ['geom','helper','shape','light','camera']: return<br />      self.name = name<br />      self.ase_type = ase_object_type #GEOM, HELPER, SHAPE, LIGHT, CAMERA<br />      self.row0 = None<br />      self.row1 = None<br />      self.row2 = None<br />      self.row3 = None<br />      self.parent = None<br /><br />      #new_ase_data = None<br />      if ase_object_type == 'geom':<br />         new_ase_data = Ase_mesh(self)<br />      self.ase_data = new_ase_data<br /><br />class Ase_mesh:<br />   def __init__(self, ase_obj=None):<br />      self.name = 'Name'<br />      self.num = {'VERTS':0,'FACES':0,'CVERTEX':0,'CVFACES':0}<br />      self.ase_verts = {}<br />      self.vertseq = []<br />      self.ase_edges = {}<br />      self.ase_faces = {}<br />      self.faceseq = []<br />      self.ase_uv_channels = {}<br />      self.active_uv = None<br />      self.ase_vertcolors = {}<br />      self.ase_cfaces = {}<br />      self.autosmooth = 0<br />      self.hasUV = 0<br />      self.hasVC = 0 <br /><br />   def sort_edgekeys(self,vi0,vi1,vi2):<br />      '''<br />      Returns sorted edge keys of the given triangle vert indicies.<br />      '''<br />      if vi0 &gt; vi1: ed_k0 = vi1,vi0<br />      else: ed_k0 = vi0,vi1<br />      if vi1 &gt; vi2: ed_k1 = vi2,vi1<br />      else: ed_k1 = vi1,vi2<br />      if vi0 &gt; vi2: ed_k2 = vi2,vi0<br />      else: ed_k2 = vi0,vi2<br />      return ed_k0,ed_k1,ed_k2<br /><br />   def append_vert(self, ase_vert_index, x, y, z):<br />      '''<br />      Create a new Vertex for this Mesh.<br />      '''<br />      ase_v = Ase_vert(ase_vert_index, x, y, z)<br />      self.ase_verts[ase_vert_index] = ase_v<br />      #self.vertseq.insert(ase_vert_index, (ase_v.co.x,ase_v.co.y,ase_v.co.z))<br />      self.vertseq.insert(ase_vert_index, ase_v.co)<br />      <br />   def append_face(self, index, vi0, vi1, vi2, AB=1, BC=1, CA=1, smooth_groups=[0], mat_indices=0):<br />      '''<br />      Uhm ... work in progress!<br />      '''<br />      # create a new Ase_face<br />      ase_f = Ase_face(index, vi0, vi1, vi2, smooth_groups, mat_indices)<br />      ed_keys = self.sort_edgekeys(vi0,vi1,vi2)<br />      #ed_keys = [vi0,vi1].sort(),[vi1,vi2].sort(),[vi0,vi2].sort()<br />      ase_f.edge_keys = ed_keys<br />      ase_f.vis_sum = AB+BC+CA<br />      if ase_f.vis_sum == 2:<br />         if not AB: ase_f.tri_edge = ed_keys[0]<br />         elif not BC: ase_f.tri_edge = ed_keys[1]<br />         elif not CA: ase_f.tri_edge = ed_keys[2]<br /><br />      # set visibility (fgon) and sharp for edges<br />      # and look if the two face users might form a quad<br />      # or create a new Ase_edge<br />      for k,vis in zip(ed_keys,[AB,BC,CA]):<br />         # Ase_edge already exist or create a new one<br />         if not self.ase_edges.has_key(k):<br />            ase_ed = Ase_edge(k)<br />            ase_ed.fusers.append(ase_f.index)<br />            ase_ed.visible = vis<br />            self.ase_edges[k] = ase_ed<br />            continue<br />         else:<br />            ase_ed = self.ase_edges[k]<br />            ase_ed.fusers.append(ase_f.index)<br />            if ase_f.vis_sum == 2 and not ase_ed.visible:<br />               ase_f.tri_edge = k<br /><br />         fusers = [i for i in ase_ed.fusers if i != ase_f.index]<br />         if not fusers: continue<br />         for i in fusers:<br />            ase_f2 = self.ase_faces[i]<br />            # if this edge is invisible and both tris only have<br />            # this invisible edge, than the two tris could form a quad<br />            # easy done with a sum of all vis variables of the edges<br />            if k == ase_f.tri_edge:<br />               if ase_f.tri_edge == ase_f2.tri_edge:<br />                  ase_f.quad_team = ase_f2.index<br />                  ase_f2.quad_team = ase_f.index<br /><br />            # look if this edge is sharp<br />            # if not both faces share at least one smoothgroup var<br />            # than this edge is sharp<br />            #if ase_ed.sharp: continue<br />            for sg in smooth_groups:<br />               if sg not in ase_f2.smooth_groups:<br />                  ase_ed.sharp = True<br /><br />      self.ase_faces[ase_f.index] = ase_f<br />      self.faceseq.insert(ase_f.index, (ase_f.v0, ase_f.v1, ase_f.v2))<br /><br />   def append_uv_channel(self, layer_index=1):<br />      ''' <br />      Create a new UV Layer and set it active.<br />      '''<br />      self.ase_uv_channels[layer_index] = Ase_uv_channel(layer_index)<br />      self.active_uv = self.ase_uv_channels[layer_index]<br /><br />   def append_tvert(self, ase_uv_index, u, v, w=0):<br />      '''<br />      Create a new UV Vector in the active! UV Channel.<br />      '''<br />      if not self.active_uv: return<br />      #self.active_uv.ase_tverts[ase_uv_index] = Ase_tvert(ase_uv_index,u,v,w)<br />      self.active_uv.ase_tverts[ase_uv_index] = (u,v)<br /><br />   def append_tface(self, ase_face_index, uvi0, uvi1, uvi2, opt_check_seams=False):<br />      '''<br />      Create a new Face UV with indicies to UV Vectors in the active UV Layer.<br />      Optional check for Seams and store into the UV Channel.<br />      '''<br />      if not self.active_uv: return<br />      self.active_uv.ase_tfaces[ase_face_index] = [uvi0, uvi1, uvi2]<br />      # look if this face has seams<br />      # might useless because it makes no sense to import seams for all UV layers<br />      # that's why those edge keys are separately written to each ase UV layer<br />      if opt_check_seams:<br />         edge_keys = self.ase_faces[ase_face_index].edge_keys<br />         for ed_key,uvs in zip(edge_keys,[[uvi0,uvi1],[uvi1,uvi2],[uvi0,uvi2]]):<br />            uvs.sort()<br />            ase_ed,active_uv = self.ase_edges[ed_key],self.active_uv<br />            if not active_uv.ase_tedges.has_key(ed_key):<br />               active_uv.ase_tedges[ed_key] = uvs<br />               continue<br />            elif active_uv.ase_tedges[ed_key] != uvs:<br />               active_uv.seams.append(ed_key)<br /><br />   def append_vertcol(self, ase_color_index, r, g, b):<br />      #new = Ase_vertcolor(ase_color_index, r, g, b)<br />      #self.ase_vertcolors[ase_color_index] = new<br />      self.ase_vertcolors[ase_color_index] = (r,g,b)<br />      <br />   def append_cface(self, ase_face_index, ci0, ci1, ci2):<br />      ase_f = self.ase_faces[ase_face_index]<br />      #f.c0, f.c1, f.c2 = ci0, ci1, ci2<br />      self.ase_cfaces[ase_face_index] = (ci0, ci1, ci2)<br /><br />   def append_normal(self, ase_face_index, x, y, z):<br />      self.ase_faces[ase_face_index].normal = Blender.Mathutils.Vector(x,y,z)<br /><br />   def append_vnormal(self, ase_face_index, ase_vert_index, x, y, z, opt_check_smooth=False):<br />      ase_f = self.ase_faces[ase_face_index]<br />      self.ase_verts[ase_vert_index].normals[ase_face_index] = Blender.Mathutils.Vector(x,y,z)<br />      if opt_check_smooth and ase_f.smooth_groups:<br />         ase_edges = [self.ase_edges[key] for key in ase_f.edge_keys]<br />         for ed_key,ase_ed in zip(ase_f.edge_keys,ase_edges):<br />            if ase_ed.sharp or len(ase_ed.fusers) &lt; 2: continue<br />            for vi in ed_key:<br />               if not self.ase_verts.has_key(vi): continue<br />               vnormals = self.ase_verts[vi].normals<br />               fi0, fi1 = ase_ed.fusers[0:2]<br />               if vnormals.has_key(fi0) and vnormals.has_key(fi1):<br />                  vnor0, vnor1 = vnormals[fi0],vnormals[fi1]<br />                  if vnor0 == vnor1:<br />                     continue<br />                  else:<br />                     angle = round(Blender.Mathutils.AngleBetweenVecs(vnor0, vnor1))<br />                     if not self.autosmooth: self.autosmooth = angle<br />                     elif angle and self.autosmooth &gt; angle:<br />                        print angle<br />                        self.autosmooth = angle<br /><br /><br />class Ase_vert:<br />   def __init__(self, index, x, y, z):<br />      self.index = index<br />      #self.co = Blender.Mathutils.Vector(x,y,z)<br />      self.co = (x,y,z)<br />      self.normals = {}<br /><br />class Ase_edge:<br />   def __init__(self, key):<br />      self.key = key<br />      self.fusers = []<br />      self.uvs = None<br />      self.visible = 1<br />      self.sharp = False<br /><br />class Ase_face:<br />   def __init__(self, ase_face_index, v0, v1, v2, smooth_groups=0, mat_indices=0):<br />      self.index = ase_face_index<br />      self.v0 = v0<br />      self.v1 = v1<br />      self.v2 = v2<br />      self.edge_keys = None<br />      self.c0 = None<br />      self.c1 = None<br />      self.c2 = None<br />      self.normal = None<br />      #self.vert_normals = {}<br />      self.mat_indices = mat_indices<br />      self.smooth_groups = smooth_groups # 0 = solid face<br />      self.vis_sum = 3<br />      self.quad_team = None<br />      self.tri_edge = None<br /><br />class Ase_uv_channel:<br />   def __init__(self, index=1):<br />      self.index = index<br />      self.num = {'TVERTEX':0,'TVFACES':0}<br />      self.uv_layer_name = 'UVTex#' + str(self.index)<br />      self.ase_tverts = {}<br />      self.ase_tfaces = {}<br />      self.ase_tedges = {}<br />      self.seams = []<br /><br />class Ase_tvert:<br />   def __init__(self,index, u, v, w=0):<br />      self.index = index<br />      #self.vec = Blender.Mathutils.Vector(u,v)<br />      self.vec = (u,v)<br /><br />class Ase_tface:<br />   def __init__(self, index, uvi0, uvi1, uvi2):<br />      self.index = index<br />      self.uv = {0:uvi0, 1:uvi1, 2:uvi2}<br /><br />class Ase_vertcolor:<br />   def __init__(self, index, r, g, b):<br />      self.index = 0 <br />      self.r = round(r*256)<br />      self.g = round(g*256)<br />      self.b = round(b*256)<br />      self.a = 255.0<br /><br /><br />def spawn(ase_objects):<br /><br />   PB_index = 0.0<br />   PB_num = float(len(ase_objects))<br /><br />   print 'Import Objects...'<br />   if OPT_PROGRESSBAR: Blender.Window.DrawProgressBar(0.0, "Importing Objects...")<br /><br />   scene = Blender.Scene.GetCurrent()<br />   for ase_ob in ase_objects: <br />      if OPT_PROGRESSBAR and not (PB_index % PB_num):<br />         Blender.Window.DrawProgressBar(PB_index / PB_num, "Importing Objects...")<br /><br />      if ase_ob.ase_type == 'geom':<br />         spawn_mesh(scene,ase_ob)<br /><br />      PB_index += 1.0<br /><br />def spawn_mesh(scene,ase_ob):<br /><br />   ase_me = ase_ob.ase_data<br />   #normal_flag = 1<br /><br />   row0 = ase_ob.row0<br />   row1 = ase_ob.row1<br />   row2 = ase_ob.row2<br />   row3 = ase_ob.row3<br /><br />   matrix = Blender.Mathutils.Matrix(row0, row1, row2, row3)<br />   matrix.resize4x4()<br /><br />   # create new Blender Object and link to scene<br />   ob = Blender.Object.New('Mesh', ase_ob.name)<br />   ob.setMatrix(matrix)<br />   scene.objects.link(ob)<br /><br />   # get Mesh data from Object<br />   me = ob.getData(0,1)<br />   me.vertexColors = me.faceUV = False<br /><br />   # create Verts and Faces<br />   # seems like extend() is limited to a length of 64000?<br />   # this is a problem when importing big meshes.<br />   div = divmod(ase_me.num['VERTEX'], 64000)<br />   if div[1]: div = div[0]+1<br />   else: div = div[0]<br />   start = 0<br />   for i in range(div):<br />      end = start+64000<br />      me.verts.extend(ase_me.vertseq[start:end])<br />      start = end<br />   div = divmod(ase_me.num['FACES'], 64000)<br />   face_index_list = []<br />   if div[1]: div = div[0]+1<br />   else: div = div[0]<br />   start = 0<br />   for i in range(div):<br />      end = start+64000<br />      me.faces.extend(ase_me.faceseq[start:end])<br />      start = end<br /><br />   # import Vertex Colors, Solid/Smooth to faces<br />   if IMP_VCOLOR:<br />      me.vertexColors = ase_me.hasVC<br />      ase_vcolors = ase_me.ase_vertcolors<br />   for i,ase_f in ase_me.ase_faces.iteritems():<br />      try:f = me.faces[i]<br />      except:<br />         # dont know what's the problem with this<br />         print 'array index out of range:', i<br />         continue<br />      if me.vertexColors:<br />         cface = ase_me.ase_cfaces[i]<br />         c0,c1,c2 = ase_vcolors[cface[0]],ase_vcolors[cface[1]],ase_vcolors[cface[2]]<br />         fc0,fc1,fc2 = f.col[:]<br />         fc0.r,fc0.g,fc0.b = int(c0[0]*255),int(c0[1]*255),int(c0[2]*255)<br />         fc1.r,fc1.g,fc1.b = int(c1[0]*255),int(c1[1]*255),int(c1[2]*255)<br />         fc2.r,fc2.g,fc2.b = int(c2[0]*255),int(c2[1]*255),int(c2[2]*255)<br />      if ase_f.smooth_groups:<br />         f.smooth = 1<br /><br />   # import UV layer's<br />   if IMP_UV and ase_me.hasUV:<br />      for uv_chan in ase_me.ase_uv_channels.itervalues():<br />         me.addUVLayer(uv_chan.uv_layer_name)<br />         me.activeUVLayer = uv_chan.uv_layer_name<br />         tverts = uv_chan.ase_tverts<br />         for fi,uvis in uv_chan.ase_tfaces.iteritems():<br />            try:f = me.faces[fi]<br />            except: continue<br />            uv1,uv2,uv3 = tverts[uvis[0]],tverts[uvis[1]],tverts[uvis[2]]<br />            f.uv = [Blender.Mathutils.Vector(uv1), Blender.Mathutils.Vector(uv2), Blender.Mathutils.Vector(uv3)]<br />      me.activeUVLayer = ase_me.ase_uv_channels[1].uv_layer_name<br /><br />   # EXPERIMENTAL!<br />   # convert tris to quads<br />   # this is currently the easiest way i found without destroying uvs or vcolors<br />   # but don't work like expected...:/<br />   if IMP_QUADS:<br />      #quad_teams = set([i for i,ase_f in ase_me.ase_faces.iteritems() if ase_f.quad_team != None])<br />      quad_teams = []<br />      for i,ase_f in ase_me.ase_faces.iteritems():<br />         if ase_f.quad_team != None:<br />            if ase_f.index &lt; ase_f.quad_team: qt = ase_f.index,ase_f.quad_team<br />            elif ase_f.index &gt; ase_f.quad_team: qt = ase_f.quad_team,ase_f.index<br />            if qt not in quad_teams:<br />               quad_teams.append(qt)<br /><br />      faces = me.faces<br />      # first deselect all faces<br />      for f in faces: f.sel = 0<br />      for t0,t1 in quad_teams:<br />         ase_f0 = ase_me.ase_faces[t0]<br />         ase_f1 = ase_me.ase_faces[t1]<br />         try: f0,f1 = me.faces[ase_f0.index], me.faces[ase_f1.index]<br />         except: continue<br />         f0.sel = 1<br />         f1.sel = 1<br />         me.triangleToQuad()<br />         for i in faces.selected():<br />            faces[i].sel = 0<br /><br />   # apply the matrix to mesh (and optional fit the ob and me to blender)<br />   if IMP_SCALED:<br />      # seems this isn't accurate because of precision of the location vector<br />      scale = Blender.Mathutils.ScaleMatrix(OPT_SCALE,4)<br />      inv_matrix = ob.getMatrix().copy().invert() * scale<br />      ob.setLocation(ob.getMatrix().translationPart() * scale)<br />   else:<br />      inv_matrix = ob.getMatrix().copy().invert()<br />   me.transform(inv_matrix, 1)<br />   me.calcNormals()<br /><br />   # apply sharp, seam and fgon flags to edges.<br />   add_EDGESPLIT = False<br />   if IMP_FGONS or IMP_SEAMS or IMP_SMOOTHGROUPS:<br />      SHARP = Mesh.EdgeFlags.SHARP<br />      SEAM = Mesh.EdgeFlags.SEAM<br />      FGON = Mesh.EdgeFlags.FGON<br />      seam_keys = []<br />      if ase_me.hasUV: seam_keys = ase_me.ase_uv_channels[1].seams<br />      for k,ase_ed in ase_me.ase_edges.iteritems():<br />         if ase_ed.sharp or not ase_ed.visible or k in seam_keys:<br />            edi = me.findEdges(k[0],k[1])<br />            if edi:<br />               ed = me.edges[edi]<br />               if ase_me.hasUV and k in seam_keys and IMP_SEAMS: ed.flag |= SEAM<br />               if not ase_ed.visible and IMP_FGONS: ed.flag |= FGON<br />               if ase_ed.sharp and IMP_SMOOTHGROUPS:<br />                    ed.flag |= SHARP<br />                  add_EDGESPLIT = True<br /><br /><br /><br />   # add EdgeSplit Modiefier when the mesh has sharp edges<br />   # autosmooth is EXPERIMENTAL! because i dont know if this is correct!<br />   if add_EDGESPLIT and OPT_MOD_EDGESPLIT:<br />      mod = ob.modifiers.append(Blender.Modifier.Types.EDGESPLIT)<br />      if not ase_me.autosmooth:<br />         mod[Blender.Modifier.Settings.EDGESPLIT_FROM_ANGLE] = 0<br />      else:<br />         mod[Blender.Modifier.Settings.EDGESPLIT_ANGLE] = ase_me.autosmooth<br />      mod[Blender.Modifier.Settings.EDGESPLIT_FROM_SHARP] = 1<br />      ob.makeDisplayList() # Needed to apply the modifier<br />   elif not add_EDGESPLIT and ase_me.autosmooth:<br />      AUTOSMOOTH = Mesh.Modes.AUTOSMOOTH<br />      me.modes |= AUTOSMOOTH<br />      me.degr = ase_me.autosmooth<br /><br />   me.update()<br />   counts['verts'] += ase_me.num['VERTEX']<br />   counts['tris'] += ase_me.num['FACES']<br />   counts['faces'] += len(me.faces)<br />   print 'Imported Mesh-Object: ', ob.name<br /><br />#def oj_the_object_jockey(file):<br />def read_file(file):<br />   '''<br />   Read an .ase file and return a list of ase_objects<br />   '''<br />   lines= file.readlines()<br /><br />   print 'Read file...'<br />   PB_index = 0.0<br />   PB_num = float(len(lines))<br />   if OPT_PROGRESSBAR: Blender.Window.DrawProgressBar(0.0, "Read File...")<br /><br />   # it is needed to read UV if Seams should be imported even when importing UV is disabled<br />   READ_UV = False<br />   if IMP_UV or IMP_SEAMS: READ_UV = True<br />   #if IMP_AUTOSMOOTH and not IMP_SMOOTHGROUPS: IMP_AUTOSMOOTH = False<br /><br />   ase_objects = []<br />   ase_ob = False<br />   for line in lines:<br />      if OPT_PROGRESSBAR and not (PB_index % 10000):<br />         Blender.Window.DrawProgressBar(PB_index / PB_num, "Read File...")<br />      PB_index += 1<br /><br />      words = line.split()<br />      if not words:<br />         continue<br />      word0 = words[0]<br />      if word0 == '*GEOMOBJECT':<br />         #if ase_ob: ase_objects.append(ase_ob)<br />         ase_ob_type = word0.lower()[1:-6] #get rid of '*' and 'OBJECT'<br />         ase_ob = Ase_object(ase_ob_type)<br />         ase_objects.append(ase_ob)<br />         continue<br />      elif word0 in ['*HELPEROBJECT','*SHAPEOBJECT','*LIGHTOBJECT','*CAMERAOBJECT','*GROUP']:<br />         # Not supported objects!<br />         # because these objects too use a TM_NODE,<br />         # ase_ob should be set back to False to prevent errors.<br />         ase_ob = False<br />         continue<br />      elif word0 == '*NODE_NAME' and ase_ob:<br />         name = words[1][1:-1] #get rid of '"'<br />         if ase_ob and ase_ob.name != '': ase_ob.ase_data.name = name<br />         elif ase_ob: ase_ob.name = name<br />         continue<br />      elif word0 == '*NODE_PARENT' and ase_ob:<br />         ase_ob.parent = words[1][1:-1] #get rid of '"'<br />         continue<br />      elif word0 == '*TM_ROW0' and ase_ob:<br />         ase_ob.row0 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*TM_ROW1' and ase_ob:<br />         ase_ob.row1 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*TM_ROW2' and ase_ob:<br />         ase_ob.row2 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*TM_ROW3' and ase_ob:<br />         ase_ob.row3 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*MESH':<br />         ase_me = ase_ob.ase_data<br />         continue<br />      elif word0 == '*MESH_NUMVERTEX':<br />         ase_me.num['VERTEX'] = int(words[1])<br />         continue<br />      elif word0 == '*MESH_NUMFACES':<br />         ase_me.num['FACES'] = int(words[1])<br />         continue<br />      elif word0 == '*MESH_VERTEX':<br />         #vert_index, x, y, z<br />         ase_me.append_vert(int(words[1]),float(words[2]),float(words[3]),float(words[4]))<br />         continue<br />      elif word0 == '*MESH_FACE':<br />         #ase_face_index, vi0, vi1, vi2, AB, BC, CA, smooth_groups, mat_indicies<br />         #smooth = mat = False<br />         ase_face_index = words[1]<br />         if ase_face_index.endswith(':'):<br />            ase_face_index = ase_face_index[:-1]<br /><br />         smooth_groups = mat_indices = []<br />         for i,w in enumerate(words):<br />            if w == '*MESH_SMOOTHING' and IMP_SMOOTHGROUPS:<br />               try:<br />                  if words[i+1] != '*MESH_MTLID':<br />                     smooth_groups = [int(i) for i in words[i+1].split(',')]<br />               except:<br />                  smooth_groups = 0<br />            elif w == '*MESH_MTLID' and IMP_SMOOTHGROUPS:<br />               try:<br />                  mat_indices = [int(i) for i in words[i+1].split(',')]<br />               except:<br />                  mat_indices = 0<br />         ase_me.append_face(int(ase_face_index),int(words[3]),int(words[5]),int(words[7]),int(words[9]),int(words[11]),int(words[13]),smooth_groups,mat_indices)<br />         continue<br />      elif READ_UV:<br />         if word0 == '*MESH_NUMTVERTEX':<br />            if not ase_me.ase_uv_channels: ase_me.append_uv_channel()<br />            ase_me.active_uv.num['TVERTEX'] = int(words[1])<br />            ase_me.hasUV = True<br />            continue<br />         elif word0 == '*MESH_MAPPINGCHANNEL':<br />            # uv_channel_index<br />            ase_me.append_uv_channel(int(words[1]))<br />            continue<br />         elif word0 == '*MESH_TVERT':<br />            #uv_index, u, v, w<br />            ase_me.append_tvert(int(words[1]),float(words[2]),float(words[3]),float(words[4]))<br />            continue<br />         elif word0 == '*MESH_NUMTVFACES':<br />            ase_me.active_uv.num['TVFACES'] = int(words[1])<br />            continue<br />         elif word0 == '*MESH_TFACE':<br />            #ase_face_index, uv0, uv1, uv2, opt_IMP_SEAMS<br />            ase_face_index = words[1]<br />            if ase_face_index.endswith(':'):<br />               ase_face_index = ase_face_index[:-1]<br />            ase_me.append_tface(int(ase_face_index),int(words[2]),int(words[3]),int(words[4]),IMP_SEAMS)<br />            continue<br />      elif IMP_VCOLOR:<br />         if word0 == '*MESH_NUMCVERTEX':<br />            ase_me.num['CVERTEX'] = int(words[1])<br />            if ase_me.num['CVERTEX']:<br />               ase_me.hasVC = True<br />            continue<br />         elif word0 == '*MESH_VERTCOL':<br />            #color_index, r, g, b<br />            ase_me.append_vertcol(int(words[1]),float(words[2]),float(words[3]),float(words[4]))<br />            continue<br />         elif word0 == '*MESH_NUMCVFACES':<br />            ase_me.num['CVFACES'] = words[1]<br />            continue<br />         elif word0 == '*MESH_CFACE':<br />            #ase_face_index, ci0, ci1, ci2<br />            ase_face_index = words[1]<br />            if ase_face_index.endswith(':'):<br />               ase_face_index = ase_face_index[:-1]<br />            ase_me.append_cface(int(ase_face_index),int(words[2]),int(words[3]),int(words[4]))<br />            continue<br />      #elif word0 == '*MESH_NORMALS':<br />      elif IMP_AUTOSMOOTH:<br />         if word0 == '*MESH_FACENORMAL':<br />            # ase_face_index, x, y, z<br />            ase_face_index = int(words[1])<br />            ase_me.append_normal(ase_face_index,float(words[2]),float(words[3]),float(words[4]))<br />            continue<br />         elif word0 == '*MESH_VERTEXNORMAL':<br />            # ase_face_index, ase_vert_index, x, y, z<br />            ase_me.append_vnormal(ase_face_index,int(words[1]),float(words[2]),float(words[3]),float(words[4]),IMP_AUTOSMOOTH)<br />            continue<br />      else:<br />         continue<br />   return ase_objects<br /><br />def print_boxed(text): #Copy/Paste from meshtools, only to remove the beep :)<br />   lines = text.splitlines()<br />   maxlinelen = max(map(len, lines))<br />   if sys.platform[:3] == "win":<br />      print chr(218)+chr(196) + chr(196)*maxlinelen + chr(196)+chr(191) <br />      for line in lines: <br />         print chr(179) + ' ' + line.ljust(maxlinelen) + ' ' + chr(179) <br />      print chr(192)+chr(196) + chr(196)*maxlinelen + chr(196)+chr(217) <br />   else: <br />      print '+-' + '-'*maxlinelen + '-+' <br />      for line in lines: print '| ' + line.ljust(maxlinelen) + ' |' <br />      print '+-' + '-'*maxlinelen + '-+' <br /><br />def read(filename):<br /><br />   global counts<br />   counts = {'verts':0,'tris':0,'faces':0}<br /><br />   start = time.clock()<br /><br />   print_boxed("----------ASCII Scene Import----------")<br />   print 'Import File: ', filename<br /><br />   mode = Blender.Window.EditMode()     # are we in edit mode?  If so ...<br />   if mode: Blender.Window.EditMode(0) # leave edit mode before getting the mesh<br /><br />   file = open(filename,'r', OPT_FILE_BUFFER)<br />   ase_objects = read_file(file)<br />   file.close()<br />   spawn(ase_objects)<br />   Blender.Redraw()<br />   if OPT_PROGRESSBAR: Blender.Window.DrawProgressBar(1.0, '')  # clear progressbar<br />   # Blender.Window.EditMode(mode)<br /><br />   end = time.clock()<br />   seconds = " in %.2f %s" % (end-start, "seconds") <br />   #totals = "Imported Verts: %i Faces: %i Tris: %i " % (counts['verts'],counts['tris'],counts['faces'])<br />   #print_boxed(totals)<br />   message = "Successfully imported " + Blender.sys.basename(filename) + seconds <br />   print_boxed(message)<br /><br /><br /><br /><br />def read_ui(filename): <br /><br />   global IMPORT_SC, IMPORT_VC, IMP_UV, IMPORT_GO, IMPORT_SE, IMPORT_SM<br />   global IMP_SCALED,IMP_SMOOTHGROUPS,IMP_VCOLOR,IMP_UV,IMP_FGONS,IMP_QUADS,IMP_SEAMS,IMP_SMOOTHGROUPS,IMP_AUTOSMOOTH<br /><br />   IMPORT_SC = Blender.Draw.Create(IMP_SCALED)<br />   IMPORT_VC = Blender.Draw.Create(IMP_VCOLOR)<br />   IMP_UV = Blender.Draw.Create(IMP_UV)<br />   IMPORT_SE = Blender.Draw.Create(IMP_SEAMS)<br />   IMPORT_SM = Blender.Draw.Create(IMP_SMOOTHGROUPS)<br /><br />   # Get USER Options <br />   pup_block = [('Import Options'),('Scale Meshes', IMPORT_SC, 'Scale the Objects so that they better fit into Blender\'s grid size'),('Vertex Colors', IMPORT_VC, 'Import Vertex Colors if existing'),('UV (Layer)', IMP_UV, 'Import UV and UV layer\'s if existing'),('Smoothing', IMPORT_SM, 'Surround Smoothgroups with sharp edges'),('Seams', IMPORT_SE, 'Try to import Seams from UV islands (from the first UV layer!)')]<br /><br />   if not Blender.Draw.PupBlock('Import ASCII Scene...', pup_block):<br />      return<br /><br />   Blender.Window.WaitCursor(1)<br /><br />   IMP_SCALED = IMPORT_SC.val<br />   IMP_VCOLOR = IMPORT_VC.val<br />   IMP_UV = IMP_UV.val<br />   IMP_SEAMS = IMPORT_SE.val<br />   IMP_SMOOTHGROUPS = IMPORT_SM.val<br /><br />   read(filename)<br /><br />   Blender.Window.WaitCursor(0)<br />   Blender.Redraw()<br /><br /><br />if __name__ == '__main__' and OPT_FILESELECTOR:<br />   Blender.Window.FileSelector(read_ui, 'Import ASCII Scene', ('.ase'))<br />elif __name__ == '__main__':<br />   read_ui(OPT_STATIC_FILENAME)</div></div>]]></body></post><post id="p140320" date="Posted: Mon Apr 17, 2006 1:12 pm "><author>Bittoman</author><body><![CDATA[<div class="postbody">Nice job, thanks Goofos!</div>]]></body></post><post id="p140355" date="Posted: Mon Apr 17, 2006 10:30 pm "><author>kat</author><body><![CDATA[<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en-gb" xml:lang="en-gb" xml:lang="en-gb">
  <head>
    <script type="text/javascript" src="https://web.archive.org/static/js/analytics.js"></script>
    <link type="text/css" rel="stylesheet" href="https://web.archive.org/static/css/banner-styles.css" />
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta http-equiv="content-language" content="en-gb" />
    <meta http-equiv="content-style-type" content="text/css" />
    <meta http-equiv="imagetoolbar" content="no" />
    <meta name="resource-type" content="document" />
    <meta name="distribution" content="global" />
    <meta name="copyright" content="2002-2006 phpBB Group" />
    <meta name="keywords" content="" />
    <meta name="description" content="" />
    <title>Doom3world • View topic - ASE Importer</title>
    <link rel="stylesheet" href="https://web.archive.org/web/20070509181516cs_/http://doom3world.org/phpbb2/styles/subsilver2/theme/stylesheet.css" type="text/css" />
    <script type="text/javascript">
<![CDATA[
// <![CDATA[

function popup(url, width, height, name)
{
	if (!name)
	{
		name = '_popup';
	}

	window.open(url.replace(/&amp;/g, '&'), name, 'height=' + height + ',resizable=yes,scrollbars=yes,width=' + width);
	return false;
}

function jumpto()
{
	var page = prompt('Enter the page number you wish to go to.:', '1');
	var perpage = '20';
	var base_url = './viewtopic.php?f=50&amp;t=15404&amp;st=0&amp;sk=t&amp;sd=a&amp;sid=0b1c0103b77fa8569d84397a188d28b9';

	if (page !== null && !isNaN(page) && page > 0)
	{
		document.location.href = base_url.replace(/&amp;/g, '&') + '&start=' + ((page - 1) * perpage);
	}
}

/**
* Find a member
*/
function find_username(url)
{
	popup(url, 760, 570, '_usersearch');
	return false;
}

/**
* Mark/unmark checklist
* id = ID of parent container, name = name prefix, state = state [true/false]
*/
function marklist(id, name, state)
{
	var parent = document.getElementById(id);
	if (!parent)
	{
		eval('parent = document.' + id);
	}

	if (!parent)
	{
		return;
	}

	var rb = parent.getElementsByTagName('input');
	
	for (var r = 0; r < rb.length; r++)
	{
		if (rb[r].name.substr(0, name.length) == name)
		{
			rb[r].checked = state;
		}
	}
}


// ]]]] ><![CDATA[>
]] >
    </script>
  </head>
  <body class="ltr">
<!-- BEGIN WAYBACK TOOLBAR INSERT -->
<script><![CDATA[ if (window.archive_analytics) { window.archive_analytics.values['server_name']="wwwb-app18.us.archive.org";}; ]] ></script><script type="text/javascript" src="https://web.archive.org/static/js/disclaim-element.js"></script><script type="text/javascript" src="https://web.archive.org/static/js/graph-calc.js"></script><script type="text/javascript" src="https://web.archive.org/static/jflot/jquery.min.js"></script><script type="text/javascript"><![CDATA[
//<![CDATA[
var firstDate = 820454400000;
var lastDate = 1420070399999;
var wbPrefix = "/web/";
var wbCurrentUrl = "http:\/\/doom3world.org\/phpbb2\/viewtopic.php?f=50&t=15404";

var curYear = -1;
var curMonth = -1;
var yearCount = 18;
var firstYear = 1996;
var imgWidth = 475;
var yearImgWidth = 25;
var monthImgWidth = 2;
var trackerVal = "none";
var displayDay = "9";
var displayMonth = "May";
var displayYear = "2007";
var prettyMonths = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];

function showTrackers(val) {
	if(val == trackerVal) {
		return;
	}
	if(val == "inline") {
		document.getElementById("displayYearEl").style.color = "#ec008c";
		document.getElementById("displayMonthEl").style.color = "#ec008c";
		document.getElementById("displayDayEl").style.color = "#ec008c";		
	} else {
		document.getElementById("displayYearEl").innerHTML = displayYear;
		document.getElementById("displayYearEl").style.color = "#ff0";
		document.getElementById("displayMonthEl").innerHTML = displayMonth;
		document.getElementById("displayMonthEl").style.color = "#ff0";
		document.getElementById("displayDayEl").innerHTML = displayDay;
		document.getElementById("displayDayEl").style.color = "#ff0";
	}
   document.getElementById("wbMouseTrackYearImg").style.display = val;
   document.getElementById("wbMouseTrackMonthImg").style.display = val;
   trackerVal = val;
}
function getElementX2(obj) {
	var thing = jQuery(obj);
	if((thing == undefined) 
			|| (typeof thing == "undefined") 
			|| (typeof thing.offset == "undefined")) {
		return getElementX(obj);
	}
	return Math.round(thing.offset().left);
}
function trackMouseMove(event,element) {

   var eventX = getEventX(event);
   var elementX = getElementX2(element);
   var xOff = eventX - elementX;
	if(xOff < 0) {
		xOff = 0;
	} else if(xOff > imgWidth) {
		xOff = imgWidth;
	}
   var monthOff = xOff % yearImgWidth;

   var year = Math.floor(xOff / yearImgWidth);
	var yearStart = year * yearImgWidth;
   var monthOfYear = Math.floor(monthOff / monthImgWidth);
   if(monthOfYear > 11) {
       monthOfYear = 11;
   }
   // 1 extra border pixel at the left edge of the year:
   var month = (year * 12) + monthOfYear;
   var day = 1;
	if(monthOff % 2 == 1) {
		day = 15;
	}
	var dateString = 
		zeroPad(year + firstYear) + 
		zeroPad(monthOfYear+1,2) +
		zeroPad(day,2) + "000000";

	var monthString = prettyMonths[monthOfYear];
	document.getElementById("displayYearEl").innerHTML = year + 1996;
	document.getElementById("displayMonthEl").innerHTML = monthString;
	// looks too jarring when it changes..
	//document.getElementById("displayDayEl").innerHTML = zeroPad(day,2);

	var url = wbPrefix + dateString + '/' +  wbCurrentUrl;
	document.getElementById('wm-graph-anchor').href = url;

   //document.getElementById("wmtbURL").value="evX("+eventX+") elX("+elementX+") xO("+xOff+") y("+year+") m("+month+") monthOff("+monthOff+") DS("+dateString+") Moy("+monthOfYear+") ms("+monthString+")";
   if(curYear != year) {
       var yrOff = year * yearImgWidth;
       document.getElementById("wbMouseTrackYearImg").style.left = yrOff + "px";
       curYear = year;
   }
   if(curMonth != month) {
       var mtOff = year + (month * monthImgWidth) + 1;
       document.getElementById("wbMouseTrackMonthImg").style.left = mtOff + "px";
       curMonth = month;
   }
}
//]]]] ><![CDATA[>
]] ></script><style type="text/css"><![CDATA[body{margin-top:0!important;padding-top:0!important;min-width:800px!important;}#wm-ipp a:hover{text-decoration:underline!important;}]] ></style><div id="wm-ipp" lang="en" class="__wb_banner_div" style="display:none; position:relative;padding:0 5px;min-height:70px;min-width:800px" xml:lang="en">


<div id="wm-ipp-inside" class="__wb_banner_div" style="position:fixed;padding:0!important;margin:0!important;width:97%;min-width:780px;border:5px solid #000;border-top:none;background-image:url(https://web.archive.org/static/images/toolbar/wm_tb_bk_trns.png);text-align:center;-moz-box-shadow:1px 1px 3px #333;-webkit-box-shadow:1px 1px 3px #333;box-shadow:1px 1px 3px #333;font-size:11px!important;font-family:'Lucida Grande','Arial',sans-serif!important;">
   <table style="border-collapse:collapse;margin:0;padding:0;width:100%;"><tbody><tr><td style="padding:10px;vertical-align:top;min-width:110px;">
   <a href="https://web.archive.org/web/" title="Wayback Machine home page" style="background-color:transparent;border:none;"><img src="https://web.archive.org/static/images/toolbar/wayback-toolbar-logo.png" alt="Wayback Machine" width="110" height="39" border="0" /></a>
   </td>
   <td style="padding:0!important;text-align:center;vertical-align:top;width:100%;">

       <table style="border-collapse:collapse;margin:0 auto;padding:0;width:570px;"><tbody><tr><td style="padding:3px 0;" colspan="2">
       <form target="_top" method="get" action="https://web.archive.org/web/form-submit.jsp" name="wmtb" id="wmtb" style="margin:0!important;padding:0!important;"><input type="text" name="url" id="wmtbURL" value="http://doom3world.org/phpbb2/viewtopic.php?f=50&amp;t=15404" style="width:400px;font-size:11px;font-family:'Lucida Grande','Arial',sans-serif;" onfocus="javascript:this.focus();this.select();" /><input type="hidden" name="type" value="replay" /><input type="hidden" name="date" value="20070509181516" /><input type="submit" value="Go" style="font-size:11px;font-family:'Lucida Grande','Arial',sans-serif;margin-left:5px;width: inherit !important" /><span id="wm_tb_options" style="display:block;"></span></form>
       </td>
       <td style="vertical-align:bottom;padding:5px 0 0 0!important;" rowspan="2">
           <table style="border-collapse:collapse;width:110px;color:#99a;font-family:'Helvetica','Lucida Grande','Arial',sans-serif;"><tbody><!-- NEXT/PREV MONTH NAV AND MONTH INDICATOR --><tr style="width:110px;height:16px;font-size:10px!important;"><td style="padding-right:9px;font-size:11px!important;font-weight:bold;text-transform:uppercase;text-align:right;white-space:nowrap;overflow:visible;" nowrap="nowrap">
               
                       Apr
                       
               </td>
               <td id="displayMonthEl" style="background:#000;color:#ff0;font-size:11px!important;font-weight:bold;text-transform:uppercase;width:34px;height:15px;padding-top:1px;text-align:center;" title="You are here: 18:15:16 May 9, 2007">MAY</td>
				<td style="padding-left:9px;font-size:11px!important;font-weight:bold;text-transform:uppercase;white-space:nowrap;overflow:visible;" nowrap="nowrap">
               
		                <a href="../../www.doom3world.org/phpbb2/viewtopic.php?f=50&amp;t=15404" style="text-decoration:none;color:#33f;font-weight:bold;background-color:transparent;border:none;" title="3 Dec 2008"><strong>DEC</strong></a>
		                
               </td>
           </tr><!-- NEXT/PREV CAPTURE NAV AND DAY OF MONTH INDICATOR --><tr><td style="padding-right:9px;white-space:nowrap;overflow:visible;text-align:right!important;vertical-align:middle!important;" nowrap="nowrap">
               
                       <img src="https://web.archive.org/static/images/toolbar/wm_tb_prv_off.png" alt="Previous capture" width="14" height="16" border="0" /></td>
               <td id="displayDayEl" style="background:#000;color:#ff0;width:34px;height:24px;padding:2px 0 0 0;text-align:center;font-size:24px;font-weight: bold;" title="You are here: 18:15:16 May 9, 2007">9</td>
				<td style="padding-left:9px;white-space:nowrap;overflow:visible;text-align:left!important;vertical-align:middle!important;" nowrap="nowrap">
               
		                <a href="../../www.doom3world.org/phpbb2/viewtopic.php?f=50&amp;t=15404" title="14:26:18 Dec 3, 2008" style="background-color:transparent;border:none;"><img src="https://web.archive.org/static/images/toolbar/wm_tb_nxt_on.png" alt="Next capture" width="14" height="16" border="0" /></a>
		                
			    </td>
           </tr><!-- NEXT/PREV YEAR NAV AND YEAR INDICATOR --><tr style="width:110px;height:13px;font-size:9px!important;"><td style="padding-right:9px;font-size:11px!important;font-weight: bold;text-align:right;white-space:nowrap;overflow:visible;" nowrap="nowrap">
               
                       2006
                       
               </td>
               <td id="displayYearEl" style="background:#000;color:#ff0;font-size:11px!important;font-weight: bold;padding-top:1px;width:34px;height:13px;text-align:center;" title="You are here: 18:15:16 May 9, 2007">2007</td>
				<td style="padding-left:9px;font-size:11px!important;font-weight: bold;white-space:nowrap;overflow:visible;" nowrap="nowrap">
               
		                <a href="../../www.doom3world.org/phpbb2/viewtopic.php?f=50&amp;t=15404" style="text-decoration:none;color:#33f;font-weight:bold;background-color:transparent;border:none;" title="3 Dec 2008"><strong>2008</strong></a>
		                
				</td>
           </tr></tbody></table></td>

       </tr><tr><td style="vertical-align:middle;padding:0!important;">
           <a href="https://web.archive.org/web/20070509181516*/http://doom3world.org/phpbb2/viewtopic.php?f=50&amp;t=15404" style="color:#33f;font-size:11px;font-weight:bold;background-color:transparent;border:none;" title="See a list of every capture for this URL"><strong>2 captures</strong></a>
           <div class="__wb_banner_div" style="margin:0!important;padding:0!important;color:#666;font-size:9px;padding-top:2px!important;white-space:nowrap;" title="Timespan for captures of this URL">9 May 07 - 3 Dec 08</div>
       </td>
       <td style="padding:0!important;">
       <a style="position:relative; white-space:nowrap; width:475px;height:27px;" href="viewtopic.php?f=50&amp;t=15404" id="wm-graph-anchor">
       <div class="__wb_banner_div" id="wm-ipp-sparkline" style="position:relative; white-space:nowrap; width:475px;height:27px;background-color:#fff;cursor:pointer;border-right:1px solid #ccc;" title="Explore captures for this URL">
			<img id="sparklineImgId" style="position:absolute; z-index:9012; top:0px; left:0px;" onmouseover="showTrackers('inline');" onmouseout="showTrackers('none');" onmousemove="trackMouseMove(event,this)" alt="sparklines" width="475" height="27" border="0" src="https://web.archive.org/web/jsp/graph.jsp?graphdata=475_27_1996:-1:000000000000_1997:-1:000000000000_1998:-1:000000000000_1999:-1:000000000000_2000:-1:000000000000_2001:-1:000000000000_2002:-1:000000000000_2003:-1:000000000000_2004:-1:000000000000_2005:-1:000000000000_2006:-1:000000000000_2007:4:000010000000_2008:-1:000000000001_2009:-1:000000000000_2010:-1:000000000000_2011:-1:000000000000_2012:-1:000000000000_2013:-1:000000000000_2014:-1:000000000000" /><img id="wbMouseTrackYearImg" style="display:none; position:absolute; z-index:9010;" width="25" height="27" border="0" src="https://web.archive.org/static/images/toolbar/transp-yellow-pixel.png" /><img id="wbMouseTrackMonthImg" style="display:none; position:absolute; z-index:9011; " width="2" height="27" border="0" src="https://web.archive.org/static/images/toolbar/transp-red-pixel.png" /></div>
		</a>

       </td>
       </tr></tbody></table></td>
   <td style="text-align:right;padding:5px;width:65px;font-size:11px!important;">
       <a href="javascript:;" onclick="document.getElementById('wm-ipp').style.display='none';" style="display:block;padding-right:18px;background:url(https://web.archive.org/static/images/toolbar/wm_tb_close.png) no-repeat 100% 0;color:#33f;font-family:'Lucida Grande','Arial',sans-serif;margin-bottom:23px;background-color:transparent;border:none;" title="Close the toolbar">Close</a>
       <a href="http://faq.web.archive.org/" style="display:block;padding-right:18px;background:url(https://web.archive.org/static/images/toolbar/wm_tb_help.png) no-repeat 100% 0;color:#33f;font-family:'Lucida Grande','Arial',sans-serif;background-color:transparent;border:none;" title="Get some help using the Wayback Machine">Help</a>
   </td>
   </tr></tbody></table></div>
</div>
<script type="text/javascript"><![CDATA[
 var wmDisclaimBanner = document.getElementById("wm-ipp");
 if(wmDisclaimBanner != null) {
   disclaimElement(wmDisclaimBanner);
 }
]] ></script><!-- END WAYBACK TOOLBAR INSERT --><a name="top" id="top"></a>

<div id="wrapheader">

	<div id="logodesc">
		<table width="100%" cellspacing="0"><tr><td><a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/index.php?sid=0b1c0103b77fa8569d84397a188d28b9"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/imageset/site_logo.gif" width="300" height="71" alt="" title="" /></a></td>
			<td width="100%" align="center"><h1>Doom3world</h1><span class="gen">The world is yours! Doom 3 - Quake 4 - ET:QW - Prey - Rage</span>
      
      <br /><script type="text/javascript"><![CDATA[<!--
      google_ad_client = "pub-9445709839432880";
      google_ad_width = 468;
      google_ad_height = 60;
      google_ad_format = "468x60_as";
      google_ad_type = "text_image";
      //2007-11-04: D3WForums_banner_header
      google_ad_channel = "6206397355";
      google_color_border = "DCE1E5";
      google_color_bg = "DCE1E5";
      google_color_link = "006699";
      google_color_text = "000000";
      google_color_url = "006699";
      google_ui_features = "rc:0";
      //-->
      ]] ></script><script type="text/javascript" src="https://web.archive.org/web/20070509181516js_/http://pagead2.googlesyndication.com/pagead/show_ads.js"><![CDATA[
  ]] ></script></td>
		</tr></table></div>

	<div id="menubar">
		<table width="100%" cellspacing="0"><tr><td class="genmed">
				<a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/ucp.php?mode=login&amp;sid=0b1c0103b77fa8569d84397a188d28b9"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/theme/images/icon_mini_login.gif" width="12" height="13" alt="*" /> Login</a>   <a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/ucp.php?mode=register&amp;sid=0b1c0103b77fa8569d84397a188d28b9"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/theme/images/icon_mini_register.gif" width="12" height="13" alt="*" /> Register</a>
								</td>
			<td class="genmed" align="right">
				<a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/faq.php?sid=0b1c0103b77fa8569d84397a188d28b9"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/theme/images/icon_mini_faq.gif" width="12" height="13" alt="*" /> FAQ</a>
				   <a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/search.php?sid=0b1c0103b77fa8569d84397a188d28b9"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/theme/images/icon_mini_search.gif" width="12" height="13" alt="*" /> Search</a>			</td>
		</tr></table></div>

	<div id="datebar">
		<table width="100%" cellspacing="0"><tr><td class="gensmall"></td>
			<td class="gensmall" align="right">It is currently Fri Dec 21, 2007 1:36 pm<br /></td>
		</tr></table></div>

</div>

<div id="wrapcentre">

		<p class="searchbar">
		<span style="float: left;"><a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/search.php?search_id=unanswered&amp;sid=0b1c0103b77fa8569d84397a188d28b9">View unanswered posts</a> | <a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/search.php?search_id=active_topics&amp;sid=0b1c0103b77fa8569d84397a188d28b9">View active topics</a></span>
			</p>
	
	<br style="clear: both;" /><table class="tablebg" width="100%" cellspacing="1" cellpadding="0" style="margin-top: 5px;"><tr><td class="row1">
			<p class="breadcrumbs"><a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/index.php?sid=0b1c0103b77fa8569d84397a188d28b9">Board index</a> 
   » <a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/viewforum.php?f=71&amp;sid=0b1c0103b77fa8569d84397a188d28b9">General Discussion</a> » <a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/viewforum.php?f=72&amp;sid=0b1c0103b77fa8569d84397a188d28b9">3D editing and offline rendering</a> » <a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/viewforum.php?f=50&amp;sid=0b1c0103b77fa8569d84397a188d28b9">Blender</a>      
  

  
  </p>
			<p class="datetime">All times are UTC </p>
		</td>
	</tr></table><center>
  <script type="text/javascript"><![CDATA[<!--
      google_ad_client = "pub-9445709839432880";
      google_ad_width = 728;
      google_ad_height = 15;
      google_ad_format = "728x15_0ads_al_s";
      //2007-11-03: D3WForums_linkblock
      google_ad_channel = "1963952183";
      google_color_border = "FFFFFF";
      google_color_bg = "FFFFFF";
      google_color_link = "006699";
      google_color_text = "006699";
      google_color_url = "006699";
      //-->
      ]] ></script><script type="text/javascript" src="https://web.archive.org/web/20070509181516js_/http://pagead2.googlesyndication.com/pagead/show_ads.js"><![CDATA[
  ]] ></script></center>
	<br /><div id="pageheader">
	<h2><a class="titles" href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/viewtopic.php?f=50&amp;t=15404&amp;start=0&amp;st=0&amp;sk=t&amp;sd=a&amp;sid=0b1c0103b77fa8569d84397a188d28b9">ASE Importer</a></h2>

	<p class="moderators">Moderator: <a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/memberlist.php?mode=group&amp;g=654&amp;sid=0b1c0103b77fa8569d84397a188d28b9">il padrino</a></p>
</div>

<br clear="all" /><br /><div id="pagecontent">

	<table width="100%" cellspacing="1"><tr><td align="left" valign="middle" nowrap="nowrap">
		<a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/posting.php?mode=post&amp;f=50&amp;sid=0b1c0103b77fa8569d84397a188d28b9"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/imageset/en/button_topic_new.gif" alt="Post new topic" title="Post new topic" /></a> <a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/posting.php?mode=reply&amp;f=50&amp;t=15404&amp;sid=0b1c0103b77fa8569d84397a188d28b9"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/imageset/en/button_topic_reply.gif" alt="Reply to topic" title="Reply to topic" /></a>		</td>
					<td class="nav" valign="middle" nowrap="nowrap"> Page <strong>1</strong> of <strong>2</strong><br /></td>
			<td class="gensmall" nowrap="nowrap"> [ 21 posts ] </td>
			<td class="gensmall" width="100%" align="right" nowrap="nowrap"><b><a href="viewtopic.php?f=50&amp;t=15404#" onclick="jumpto(); return false;" title="Click to jump to page…">Go to page</a> <strong>1</strong><span class="page-sep">, </span><a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/viewtopic.php?f=50&amp;t=15404&amp;st=0&amp;sk=t&amp;sd=a&amp;sid=0b1c0103b77fa8569d84397a188d28b9&amp;start=20">2</a>  <a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/viewtopic.php?f=50&amp;t=15404&amp;st=0&amp;sk=t&amp;sd=a&amp;sid=0b1c0103b77fa8569d84397a188d28b9&amp;start=20">Next</a></b></td>
			</tr></table><table class="tablebg" width="100%" cellspacing="1"><tr><td class="cat">
			<table width="100%" cellspacing="0"><tr><td class="nav" nowrap="nowrap"> 
								</td>
				<td class="nav" align="right" nowrap="nowrap"><a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/viewtopic.php?f=50&amp;t=15404&amp;view=previous&amp;sid=0b1c0103b77fa8569d84397a188d28b9">Previous topic</a> | <a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/viewtopic.php?f=50&amp;t=15404&amp;view=next&amp;sid=0b1c0103b77fa8569d84397a188d28b9">Next topic</a> </td>
			</tr></table></td>
	</tr></table><table class="tablebg" width="100%" cellspacing="1"><tr><th>Author</th>
			<th>Message</th>
		</tr><tr class="row1"><td align="center" valign="middle">
				<a name="p140291" id="p140291"></a>
				<b class="postauthor">Goofos</b>
			</td>
			<td width="100%" height="25">
				<table width="100%" cellspacing="0"><tr><td class="gensmall" width="100%"><div style="float: left;"> <b>Post subject:</b> ASE Importer</div><div style="float: right;"><a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/viewtopic.php?p=140291&amp;sid=0b1c0103b77fa8569d84397a188d28b9#p140291"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/imageset/icon_post_target.gif" width="12" height="9" alt="Post" title="Post" /></a><b>Posted:</b> Mon Apr 17, 2006 2:00 am </div></td>
				</tr></table></td>
		</tr><tr class="row1"><td valign="top" class="profile">
				<table cellspacing="4" align="center" width="150"><tr><td><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/imageset/en/icon_user_offline.gif" alt="Offline" title="Offline" /></td>
				</tr><tr><td class="postdetails">picked up the chaingun</td>
				</tr><tr><td><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/download/file.php?avatar=12761.gif" width="30" height="22" alt="User avatar" /></td>
				</tr></table><span class="postdetails">
					<br /><b>Joined:</b> Thu Mar 10, 2005 2:05 am<br /><b>Posts:</b> 177<br /><b>Location:</b> black forrest				</span>

			</td>
			<td valign="top">
				<table width="100%" cellspacing="5"><tr><td>
					
						<div class="postbody"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/images/smilies/icon_arrow.gif" alt=":arrow:" title="Arrow" /> Version: 0.13
<br /><br />Supports Mesh Objects with vertex colors, multiple UV, smoothgroups.
<br /><br />A little Note!: you should not try to import very big ase files (&gt;50 MB with 512 MB RAM). With much RAM you might can try this.
<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">#!BPY<br /><br />"""<br />Name: 'ASCII Scene (.ase) v0.13'<br />Blender: 244<br />Group: 'Import'<br />Tooltip: 'Import from ASCII Scene Export file format (.ase)'<br />""" <br />__author__ = "Goofos"<br />__version__ = "0.13"<br /><br /># goofos<br />#<br /># ***** BEGIN GPL LICENSE BLOCK *****<br />#<br /># This program is free software; you can redistribute it and/or<br /># modify it under the terms of the GNU General Public License<br /># as published by the Free Software Foundation; either version 2<br /># of the License, or (at your option) any later version.<br /># <br /># This program is distributed in the hope that it will be useful,<br /># but WITHOUT ANY WARRANTY; without even the implied warranty of<br /># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<br /># GNU General Public License for more details.<br /># <br /># You should have received a copy of the GNU General Public License<br /># along with this program; if not, write to the Free Software Foundation,<br /># Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.<br /># <br /># ***** END GPL LICENCE BLOCK *****<br /><br />import time, sys<br />import Blender<br />from Blender import Scene, Object, Mesh<br /><br />'''<br />Some Options<br />'''<br /># Scale Factor (float)<br />OPT_SCALE = 0.1<br /># Add EdgeSplit Modifier when importing sharp edges (bool)<br />OPT_MOD_EDGESPLIT = True<br /># Enable the fileselector (bool)<br />OPT_FILESELECTOR = True<br /># If the fileselector is disabled, specify a static filename (string)<br />OPT_STATIC_FILENAME = 'E:\ASE Files\garage.ASE'<br /># Enable Progressbar (bool)<br />OPT_PROGRESSBAR = False<br /># File buffer. After testing with big files i think there is no real difference.<br /># -1 = system default, 0 = unbuffered, 1 = line buffered, &gt;1 = buffer size<br />OPT_FILE_BUFFER = -1<br /><br />'''<br />Import Options<br />'''<br /># Import Meshes scaled, defined by the scale factor of OPT_SCALE (bool)<br /># Note: Object location data looses some precision, .. i think!<br />IMP_SCALED = True<br /># Import Vertex Colors (bool)<br />IMP_VCOLOR = True<br /># Import UV Coords and UV layers (bool)<br />IMP_UV = True<br /># Import NGons as Blender FGons (bool)<br /># Note: Include quads, too.<br />IMP_FGONS = False<br /># Try to find possible quads and convert the two tris to a quad (bool)<br /># Note: Very slow!! ablsolutely doesn't work accurate :/<br /># i don't know wether this is a script problem or a blender problem!<br />IMP_QUADS = False<br /># Surround UV islands with seams (bool)<br />IMP_SEAMS = False<br /># Surround smooth groups with sharp edges (bool)<br />IMP_SMOOTHGROUPS = True<br /># Try to find the lowest autosmooth angle in vertex normals (bool)<br /># Note: i dont know if this is correct :&gt;<br />IMP_AUTOSMOOTH = False<br /><br /><br /><br /><br /><br />class Ase_group:<br />   def __init__(self):<br />      self.name = 'Name'<br />      self.ase_type = 'GROUP'<br />      self.ase_helper = None<br />      self.ase_objects = []<br /><br />class Ase_object:<br /><br />   def __init__(self, ase_object_type, name=''):<br />      #if ase_object_type not in ['GEOM','HELPER','SHAPE','LIGHT','CAMERA']: return<br />      if ase_object_type not in ['geom','helper','shape','light','camera']: return<br />      self.name = name<br />      self.ase_type = ase_object_type #GEOM, HELPER, SHAPE, LIGHT, CAMERA<br />      self.row0 = None<br />      self.row1 = None<br />      self.row2 = None<br />      self.row3 = None<br />      self.parent = None<br /><br />      #new_ase_data = None<br />      if ase_object_type == 'geom':<br />         new_ase_data = Ase_mesh(self)<br />      self.ase_data = new_ase_data<br /><br />class Ase_mesh:<br />   def __init__(self, ase_obj=None):<br />      self.name = 'Name'<br />      self.num = {'VERTS':0,'FACES':0,'CVERTEX':0,'CVFACES':0}<br />      self.ase_verts = {}<br />      self.vertseq = []<br />      self.ase_edges = {}<br />      self.ase_faces = {}<br />      self.faceseq = []<br />      self.ase_uv_channels = {}<br />      self.active_uv = None<br />      self.ase_vertcolors = {}<br />      self.ase_cfaces = {}<br />      self.autosmooth = 0<br />      self.hasUV = 0<br />      self.hasVC = 0 <br /><br />   def sort_edgekeys(self,vi0,vi1,vi2):<br />      '''<br />      Returns sorted edge keys of the given triangle vert indicies.<br />      '''<br />      if vi0 &gt; vi1: ed_k0 = vi1,vi0<br />      else: ed_k0 = vi0,vi1<br />      if vi1 &gt; vi2: ed_k1 = vi2,vi1<br />      else: ed_k1 = vi1,vi2<br />      if vi0 &gt; vi2: ed_k2 = vi2,vi0<br />      else: ed_k2 = vi0,vi2<br />      return ed_k0,ed_k1,ed_k2<br /><br />   def append_vert(self, ase_vert_index, x, y, z):<br />      '''<br />      Create a new Vertex for this Mesh.<br />      '''<br />      ase_v = Ase_vert(ase_vert_index, x, y, z)<br />      self.ase_verts[ase_vert_index] = ase_v<br />      #self.vertseq.insert(ase_vert_index, (ase_v.co.x,ase_v.co.y,ase_v.co.z))<br />      self.vertseq.insert(ase_vert_index, ase_v.co)<br />      <br />   def append_face(self, index, vi0, vi1, vi2, AB=1, BC=1, CA=1, smooth_groups=[0], mat_indices=0):<br />      '''<br />      Uhm ... work in progress!<br />      '''<br />      # create a new Ase_face<br />      ase_f = Ase_face(index, vi0, vi1, vi2, smooth_groups, mat_indices)<br />      ed_keys = self.sort_edgekeys(vi0,vi1,vi2)<br />      #ed_keys = [vi0,vi1].sort(),[vi1,vi2].sort(),[vi0,vi2].sort()<br />      ase_f.edge_keys = ed_keys<br />      ase_f.vis_sum = AB+BC+CA<br />      if ase_f.vis_sum == 2:<br />         if not AB: ase_f.tri_edge = ed_keys[0]<br />         elif not BC: ase_f.tri_edge = ed_keys[1]<br />         elif not CA: ase_f.tri_edge = ed_keys[2]<br /><br />      # set visibility (fgon) and sharp for edges<br />      # and look if the two face users might form a quad<br />      # or create a new Ase_edge<br />      for k,vis in zip(ed_keys,[AB,BC,CA]):<br />         # Ase_edge already exist or create a new one<br />         if not self.ase_edges.has_key(k):<br />            ase_ed = Ase_edge(k)<br />            ase_ed.fusers.append(ase_f.index)<br />            ase_ed.visible = vis<br />            self.ase_edges[k] = ase_ed<br />            continue<br />         else:<br />            ase_ed = self.ase_edges[k]<br />            ase_ed.fusers.append(ase_f.index)<br />            if ase_f.vis_sum == 2 and not ase_ed.visible:<br />               ase_f.tri_edge = k<br /><br />         fusers = [i for i in ase_ed.fusers if i != ase_f.index]<br />         if not fusers: continue<br />         for i in fusers:<br />            ase_f2 = self.ase_faces[i]<br />            # if this edge is invisible and both tris only have<br />            # this invisible edge, than the two tris could form a quad<br />            # easy done with a sum of all vis variables of the edges<br />            if k == ase_f.tri_edge:<br />               if ase_f.tri_edge == ase_f2.tri_edge:<br />                  ase_f.quad_team = ase_f2.index<br />                  ase_f2.quad_team = ase_f.index<br /><br />            # look if this edge is sharp<br />            # if not both faces share at least one smoothgroup var<br />            # than this edge is sharp<br />            #if ase_ed.sharp: continue<br />            for sg in smooth_groups:<br />               if sg not in ase_f2.smooth_groups:<br />                  ase_ed.sharp = True<br /><br />      self.ase_faces[ase_f.index] = ase_f<br />      self.faceseq.insert(ase_f.index, (ase_f.v0, ase_f.v1, ase_f.v2))<br /><br />   def append_uv_channel(self, layer_index=1):<br />      ''' <br />      Create a new UV Layer and set it active.<br />      '''<br />      self.ase_uv_channels[layer_index] = Ase_uv_channel(layer_index)<br />      self.active_uv = self.ase_uv_channels[layer_index]<br /><br />   def append_tvert(self, ase_uv_index, u, v, w=0):<br />      '''<br />      Create a new UV Vector in the active! UV Channel.<br />      '''<br />      if not self.active_uv: return<br />      #self.active_uv.ase_tverts[ase_uv_index] = Ase_tvert(ase_uv_index,u,v,w)<br />      self.active_uv.ase_tverts[ase_uv_index] = (u,v)<br /><br />   def append_tface(self, ase_face_index, uvi0, uvi1, uvi2, opt_check_seams=False):<br />      '''<br />      Create a new Face UV with indicies to UV Vectors in the active UV Layer.<br />      Optional check for Seams and store into the UV Channel.<br />      '''<br />      if not self.active_uv: return<br />      self.active_uv.ase_tfaces[ase_face_index] = [uvi0, uvi1, uvi2]<br />      # look if this face has seams<br />      # might useless because it makes no sense to import seams for all UV layers<br />      # that's why those edge keys are separately written to each ase UV layer<br />      if opt_check_seams:<br />         edge_keys = self.ase_faces[ase_face_index].edge_keys<br />         for ed_key,uvs in zip(edge_keys,[[uvi0,uvi1],[uvi1,uvi2],[uvi0,uvi2]]):<br />            uvs.sort()<br />            ase_ed,active_uv = self.ase_edges[ed_key],self.active_uv<br />            if not active_uv.ase_tedges.has_key(ed_key):<br />               active_uv.ase_tedges[ed_key] = uvs<br />               continue<br />            elif active_uv.ase_tedges[ed_key] != uvs:<br />               active_uv.seams.append(ed_key)<br /><br />   def append_vertcol(self, ase_color_index, r, g, b):<br />      #new = Ase_vertcolor(ase_color_index, r, g, b)<br />      #self.ase_vertcolors[ase_color_index] = new<br />      self.ase_vertcolors[ase_color_index] = (r,g,b)<br />      <br />   def append_cface(self, ase_face_index, ci0, ci1, ci2):<br />      ase_f = self.ase_faces[ase_face_index]<br />      #f.c0, f.c1, f.c2 = ci0, ci1, ci2<br />      self.ase_cfaces[ase_face_index] = (ci0, ci1, ci2)<br /><br />   def append_normal(self, ase_face_index, x, y, z):<br />      self.ase_faces[ase_face_index].normal = Blender.Mathutils.Vector(x,y,z)<br /><br />   def append_vnormal(self, ase_face_index, ase_vert_index, x, y, z, opt_check_smooth=False):<br />      ase_f = self.ase_faces[ase_face_index]<br />      self.ase_verts[ase_vert_index].normals[ase_face_index] = Blender.Mathutils.Vector(x,y,z)<br />      if opt_check_smooth and ase_f.smooth_groups:<br />         ase_edges = [self.ase_edges[key] for key in ase_f.edge_keys]<br />         for ed_key,ase_ed in zip(ase_f.edge_keys,ase_edges):<br />            if ase_ed.sharp or len(ase_ed.fusers) &lt; 2: continue<br />            for vi in ed_key:<br />               if not self.ase_verts.has_key(vi): continue<br />               vnormals = self.ase_verts[vi].normals<br />               fi0, fi1 = ase_ed.fusers[0:2]<br />               if vnormals.has_key(fi0) and vnormals.has_key(fi1):<br />                  vnor0, vnor1 = vnormals[fi0],vnormals[fi1]<br />                  if vnor0 == vnor1:<br />                     continue<br />                  else:<br />                     angle = round(Blender.Mathutils.AngleBetweenVecs(vnor0, vnor1))<br />                     if not self.autosmooth: self.autosmooth = angle<br />                     elif angle and self.autosmooth &gt; angle:<br />                        print angle<br />                        self.autosmooth = angle<br /><br /><br />class Ase_vert:<br />   def __init__(self, index, x, y, z):<br />      self.index = index<br />      #self.co = Blender.Mathutils.Vector(x,y,z)<br />      self.co = (x,y,z)<br />      self.normals = {}<br /><br />class Ase_edge:<br />   def __init__(self, key):<br />      self.key = key<br />      self.fusers = []<br />      self.uvs = None<br />      self.visible = 1<br />      self.sharp = False<br /><br />class Ase_face:<br />   def __init__(self, ase_face_index, v0, v1, v2, smooth_groups=0, mat_indices=0):<br />      self.index = ase_face_index<br />      self.v0 = v0<br />      self.v1 = v1<br />      self.v2 = v2<br />      self.edge_keys = None<br />      self.c0 = None<br />      self.c1 = None<br />      self.c2 = None<br />      self.normal = None<br />      #self.vert_normals = {}<br />      self.mat_indices = mat_indices<br />      self.smooth_groups = smooth_groups # 0 = solid face<br />      self.vis_sum = 3<br />      self.quad_team = None<br />      self.tri_edge = None<br /><br />class Ase_uv_channel:<br />   def __init__(self, index=1):<br />      self.index = index<br />      self.num = {'TVERTEX':0,'TVFACES':0}<br />      self.uv_layer_name = 'UVTex#' + str(self.index)<br />      self.ase_tverts = {}<br />      self.ase_tfaces = {}<br />      self.ase_tedges = {}<br />      self.seams = []<br /><br />class Ase_tvert:<br />   def __init__(self,index, u, v, w=0):<br />      self.index = index<br />      #self.vec = Blender.Mathutils.Vector(u,v)<br />      self.vec = (u,v)<br /><br />class Ase_tface:<br />   def __init__(self, index, uvi0, uvi1, uvi2):<br />      self.index = index<br />      self.uv = {0:uvi0, 1:uvi1, 2:uvi2}<br /><br />class Ase_vertcolor:<br />   def __init__(self, index, r, g, b):<br />      self.index = 0 <br />      self.r = round(r*256)<br />      self.g = round(g*256)<br />      self.b = round(b*256)<br />      self.a = 255.0<br /><br /><br />def spawn(ase_objects):<br /><br />   PB_index = 0.0<br />   PB_num = float(len(ase_objects))<br /><br />   print 'Import Objects...'<br />   if OPT_PROGRESSBAR: Blender.Window.DrawProgressBar(0.0, "Importing Objects...")<br /><br />   scene = Blender.Scene.GetCurrent()<br />   for ase_ob in ase_objects: <br />      if OPT_PROGRESSBAR and not (PB_index % PB_num):<br />         Blender.Window.DrawProgressBar(PB_index / PB_num, "Importing Objects...")<br /><br />      if ase_ob.ase_type == 'geom':<br />         spawn_mesh(scene,ase_ob)<br /><br />      PB_index += 1.0<br /><br />def spawn_mesh(scene,ase_ob):<br /><br />   ase_me = ase_ob.ase_data<br />   #normal_flag = 1<br /><br />   row0 = ase_ob.row0<br />   row1 = ase_ob.row1<br />   row2 = ase_ob.row2<br />   row3 = ase_ob.row3<br /><br />   matrix = Blender.Mathutils.Matrix(row0, row1, row2, row3)<br />   matrix.resize4x4()<br /><br />   # create new Blender Object and link to scene<br />   ob = Blender.Object.New('Mesh', ase_ob.name)<br />   ob.setMatrix(matrix)<br />   scene.objects.link(ob)<br /><br />   # get Mesh data from Object<br />   me = ob.getData(0,1)<br />   me.vertexColors = me.faceUV = False<br /><br />   # create Verts and Faces<br />   # seems like extend() is limited to a length of 64000?<br />   # this is a problem when importing big meshes.<br />   div = divmod(ase_me.num['VERTEX'], 64000)<br />   if div[1]: div = div[0]+1<br />   else: div = div[0]<br />   start = 0<br />   for i in range(div):<br />      end = start+64000<br />      me.verts.extend(ase_me.vertseq[start:end])<br />      start = end<br />   div = divmod(ase_me.num['FACES'], 64000)<br />   face_index_list = []<br />   if div[1]: div = div[0]+1<br />   else: div = div[0]<br />   start = 0<br />   for i in range(div):<br />      end = start+64000<br />      me.faces.extend(ase_me.faceseq[start:end])<br />      start = end<br /><br />   # import Vertex Colors, Solid/Smooth to faces<br />   if IMP_VCOLOR:<br />      me.vertexColors = ase_me.hasVC<br />      ase_vcolors = ase_me.ase_vertcolors<br />   for i,ase_f in ase_me.ase_faces.iteritems():<br />      try:f = me.faces[i]<br />      except:<br />         # dont know what's the problem with this<br />         print 'array index out of range:', i<br />         continue<br />      if me.vertexColors:<br />         cface = ase_me.ase_cfaces[i]<br />         c0,c1,c2 = ase_vcolors[cface[0]],ase_vcolors[cface[1]],ase_vcolors[cface[2]]<br />         fc0,fc1,fc2 = f.col[:]<br />         fc0.r,fc0.g,fc0.b = int(c0[0]*255),int(c0[1]*255),int(c0[2]*255)<br />         fc1.r,fc1.g,fc1.b = int(c1[0]*255),int(c1[1]*255),int(c1[2]*255)<br />         fc2.r,fc2.g,fc2.b = int(c2[0]*255),int(c2[1]*255),int(c2[2]*255)<br />      if ase_f.smooth_groups:<br />         f.smooth = 1<br /><br />   # import UV layer's<br />   if IMP_UV and ase_me.hasUV:<br />      for uv_chan in ase_me.ase_uv_channels.itervalues():<br />         me.addUVLayer(uv_chan.uv_layer_name)<br />         me.activeUVLayer = uv_chan.uv_layer_name<br />         tverts = uv_chan.ase_tverts<br />         for fi,uvis in uv_chan.ase_tfaces.iteritems():<br />            try:f = me.faces[fi]<br />            except: continue<br />            uv1,uv2,uv3 = tverts[uvis[0]],tverts[uvis[1]],tverts[uvis[2]]<br />            f.uv = [Blender.Mathutils.Vector(uv1), Blender.Mathutils.Vector(uv2), Blender.Mathutils.Vector(uv3)]<br />      me.activeUVLayer = ase_me.ase_uv_channels[1].uv_layer_name<br /><br />   # EXPERIMENTAL!<br />   # convert tris to quads<br />   # this is currently the easiest way i found without destroying uvs or vcolors<br />   # but don't work like expected...:/<br />   if IMP_QUADS:<br />      #quad_teams = set([i for i,ase_f in ase_me.ase_faces.iteritems() if ase_f.quad_team != None])<br />      quad_teams = []<br />      for i,ase_f in ase_me.ase_faces.iteritems():<br />         if ase_f.quad_team != None:<br />            if ase_f.index &lt; ase_f.quad_team: qt = ase_f.index,ase_f.quad_team<br />            elif ase_f.index &gt; ase_f.quad_team: qt = ase_f.quad_team,ase_f.index<br />            if qt not in quad_teams:<br />               quad_teams.append(qt)<br /><br />      faces = me.faces<br />      # first deselect all faces<br />      for f in faces: f.sel = 0<br />      for t0,t1 in quad_teams:<br />         ase_f0 = ase_me.ase_faces[t0]<br />         ase_f1 = ase_me.ase_faces[t1]<br />         try: f0,f1 = me.faces[ase_f0.index], me.faces[ase_f1.index]<br />         except: continue<br />         f0.sel = 1<br />         f1.sel = 1<br />         me.triangleToQuad()<br />         for i in faces.selected():<br />            faces[i].sel = 0<br /><br />   # apply the matrix to mesh (and optional fit the ob and me to blender)<br />   if IMP_SCALED:<br />      # seems this isn't accurate because of precision of the location vector<br />      scale = Blender.Mathutils.ScaleMatrix(OPT_SCALE,4)<br />      inv_matrix = ob.getMatrix().copy().invert() * scale<br />      ob.setLocation(ob.getMatrix().translationPart() * scale)<br />   else:<br />      inv_matrix = ob.getMatrix().copy().invert()<br />   me.transform(inv_matrix, 1)<br />   me.calcNormals()<br /><br />   # apply sharp, seam and fgon flags to edges.<br />   add_EDGESPLIT = False<br />   if IMP_FGONS or IMP_SEAMS or IMP_SMOOTHGROUPS:<br />      SHARP = Mesh.EdgeFlags.SHARP<br />      SEAM = Mesh.EdgeFlags.SEAM<br />      FGON = Mesh.EdgeFlags.FGON<br />      seam_keys = []<br />      if ase_me.hasUV: seam_keys = ase_me.ase_uv_channels[1].seams<br />      for k,ase_ed in ase_me.ase_edges.iteritems():<br />         if ase_ed.sharp or not ase_ed.visible or k in seam_keys:<br />            edi = me.findEdges(k[0],k[1])<br />            if edi:<br />               ed = me.edges[edi]<br />               if ase_me.hasUV and k in seam_keys and IMP_SEAMS: ed.flag |= SEAM<br />               if not ase_ed.visible and IMP_FGONS: ed.flag |= FGON<br />               if ase_ed.sharp and IMP_SMOOTHGROUPS:<br />                    ed.flag |= SHARP<br />                  add_EDGESPLIT = True<br /><br /><br /><br />   # add EdgeSplit Modiefier when the mesh has sharp edges<br />   # autosmooth is EXPERIMENTAL! because i dont know if this is correct!<br />   if add_EDGESPLIT and OPT_MOD_EDGESPLIT:<br />      mod = ob.modifiers.append(Blender.Modifier.Types.EDGESPLIT)<br />      if not ase_me.autosmooth:<br />         mod[Blender.Modifier.Settings.EDGESPLIT_FROM_ANGLE] = 0<br />      else:<br />         mod[Blender.Modifier.Settings.EDGESPLIT_ANGLE] = ase_me.autosmooth<br />      mod[Blender.Modifier.Settings.EDGESPLIT_FROM_SHARP] = 1<br />      ob.makeDisplayList() # Needed to apply the modifier<br />   elif not add_EDGESPLIT and ase_me.autosmooth:<br />      AUTOSMOOTH = Mesh.Modes.AUTOSMOOTH<br />      me.modes |= AUTOSMOOTH<br />      me.degr = ase_me.autosmooth<br /><br />   me.update()<br />   counts['verts'] += ase_me.num['VERTEX']<br />   counts['tris'] += ase_me.num['FACES']<br />   counts['faces'] += len(me.faces)<br />   print 'Imported Mesh-Object: ', ob.name<br /><br />#def oj_the_object_jockey(file):<br />def read_file(file):<br />   '''<br />   Read an .ase file and return a list of ase_objects<br />   '''<br />   lines= file.readlines()<br /><br />   print 'Read file...'<br />   PB_index = 0.0<br />   PB_num = float(len(lines))<br />   if OPT_PROGRESSBAR: Blender.Window.DrawProgressBar(0.0, "Read File...")<br /><br />   # it is needed to read UV if Seams should be imported even when importing UV is disabled<br />   READ_UV = False<br />   if IMP_UV or IMP_SEAMS: READ_UV = True<br />   #if IMP_AUTOSMOOTH and not IMP_SMOOTHGROUPS: IMP_AUTOSMOOTH = False<br /><br />   ase_objects = []<br />   ase_ob = False<br />   for line in lines:<br />      if OPT_PROGRESSBAR and not (PB_index % 10000):<br />         Blender.Window.DrawProgressBar(PB_index / PB_num, "Read File...")<br />      PB_index += 1<br /><br />      words = line.split()<br />      if not words:<br />         continue<br />      word0 = words[0]<br />      if word0 == '*GEOMOBJECT':<br />         #if ase_ob: ase_objects.append(ase_ob)<br />         ase_ob_type = word0.lower()[1:-6] #get rid of '*' and 'OBJECT'<br />         ase_ob = Ase_object(ase_ob_type)<br />         ase_objects.append(ase_ob)<br />         continue<br />      elif word0 in ['*HELPEROBJECT','*SHAPEOBJECT','*LIGHTOBJECT','*CAMERAOBJECT','*GROUP']:<br />         # Not supported objects!<br />         # because these objects too use a TM_NODE,<br />         # ase_ob should be set back to False to prevent errors.<br />         ase_ob = False<br />         continue<br />      elif word0 == '*NODE_NAME' and ase_ob:<br />         name = words[1][1:-1] #get rid of '"'<br />         if ase_ob and ase_ob.name != '': ase_ob.ase_data.name = name<br />         elif ase_ob: ase_ob.name = name<br />         continue<br />      elif word0 == '*NODE_PARENT' and ase_ob:<br />         ase_ob.parent = words[1][1:-1] #get rid of '"'<br />         continue<br />      elif word0 == '*TM_ROW0' and ase_ob:<br />         ase_ob.row0 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*TM_ROW1' and ase_ob:<br />         ase_ob.row1 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*TM_ROW2' and ase_ob:<br />         ase_ob.row2 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*TM_ROW3' and ase_ob:<br />         ase_ob.row3 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*MESH':<br />         ase_me = ase_ob.ase_data<br />         continue<br />      elif word0 == '*MESH_NUMVERTEX':<br />         ase_me.num['VERTEX'] = int(words[1])<br />         continue<br />      elif word0 == '*MESH_NUMFACES':<br />         ase_me.num['FACES'] = int(words[1])<br />         continue<br />      elif word0 == '*MESH_VERTEX':<br />         #vert_index, x, y, z<br />         ase_me.append_vert(int(words[1]),float(words[2]),float(words[3]),float(words[4]))<br />         continue<br />      elif word0 == '*MESH_FACE':<br />         #ase_face_index, vi0, vi1, vi2, AB, BC, CA, smooth_groups, mat_indicies<br />         #smooth = mat = False<br />         ase_face_index = words[1]<br />         if ase_face_index.endswith(':'):<br />            ase_face_index = ase_face_index[:-1]<br /><br />         smooth_groups = mat_indices = []<br />         for i,w in enumerate(words):<br />            if w == '*MESH_SMOOTHING' and IMP_SMOOTHGROUPS:<br />               try:<br />                  if words[i+1] != '*MESH_MTLID':<br />                     smooth_groups = [int(i) for i in words[i+1].split(',')]<br />               except:<br />                  smooth_groups = 0<br />            elif w == '*MESH_MTLID' and IMP_SMOOTHGROUPS:<br />               try:<br />                  mat_indices = [int(i) for i in words[i+1].split(',')]<br />               except:<br />                  mat_indices = 0<br />         ase_me.append_face(int(ase_face_index),int(words[3]),int(words[5]),int(words[7]),int(words[9]),int(words[11]),int(words[13]),smooth_groups,mat_indices)<br />         continue<br />      elif READ_UV:<br />         if word0 == '*MESH_NUMTVERTEX':<br />            if not ase_me.ase_uv_channels: ase_me.append_uv_channel()<br />            ase_me.active_uv.num['TVERTEX'] = int(words[1])<br />            ase_me.hasUV = True<br />            continue<br />         elif word0 == '*MESH_MAPPINGCHANNEL':<br />            # uv_channel_index<br />            ase_me.append_uv_channel(int(words[1]))<br />            continue<br />         elif word0 == '*MESH_TVERT':<br />            #uv_index, u, v, w<br />            ase_me.append_tvert(int(words[1]),float(words[2]),float(words[3]),float(words[4]))<br />            continue<br />         elif word0 == '*MESH_NUMTVFACES':<br />            ase_me.active_uv.num['TVFACES'] = int(words[1])<br />            continue<br />         elif word0 == '*MESH_TFACE':<br />            #ase_face_index, uv0, uv1, uv2, opt_IMP_SEAMS<br />            ase_face_index = words[1]<br />            if ase_face_index.endswith(':'):<br />               ase_face_index = ase_face_index[:-1]<br />            ase_me.append_tface(int(ase_face_index),int(words[2]),int(words[3]),int(words[4]),IMP_SEAMS)<br />            continue<br />      elif IMP_VCOLOR:<br />         if word0 == '*MESH_NUMCVERTEX':<br />            ase_me.num['CVERTEX'] = int(words[1])<br />            if ase_me.num['CVERTEX']:<br />               ase_me.hasVC = True<br />            continue<br />         elif word0 == '*MESH_VERTCOL':<br />            #color_index, r, g, b<br />            ase_me.append_vertcol(int(words[1]),float(words[2]),float(words[3]),float(words[4]))<br />            continue<br />         elif word0 == '*MESH_NUMCVFACES':<br />            ase_me.num['CVFACES'] = words[1]<br />            continue<br />         elif word0 == '*MESH_CFACE':<br />            #ase_face_index, ci0, ci1, ci2<br />            ase_face_index = words[1]<br />            if ase_face_index.endswith(':'):<br />               ase_face_index = ase_face_index[:-1]<br />            ase_me.append_cface(int(ase_face_index),int(words[2]),int(words[3]),int(words[4]))<br />            continue<br />      #elif word0 == '*MESH_NORMALS':<br />      elif IMP_AUTOSMOOTH:<br />         if word0 == '*MESH_FACENORMAL':<br />            # ase_face_index, x, y, z<br />            ase_face_index = int(words[1])<br />            ase_me.append_normal(ase_face_index,float(words[2]),float(words[3]),float(words[4]))<br />            continue<br />         elif word0 == '*MESH_VERTEXNORMAL':<br />            # ase_face_index, ase_vert_index, x, y, z<br />            ase_me.append_vnormal(ase_face_index,int(words[1]),float(words[2]),float(words[3]),float(words[4]),IMP_AUTOSMOOTH)<br />            continue<br />      else:<br />         continue<br />   return ase_objects<br /><br />def print_boxed(text): #Copy/Paste from meshtools, only to remove the beep :)<br />   lines = text.splitlines()<br />   maxlinelen = max(map(len, lines))<br />   if sys.platform[:3] == "win":<br />      print chr(218)+chr(196) + chr(196)*maxlinelen + chr(196)+chr(191) <br />      for line in lines: <br />         print chr(179) + ' ' + line.ljust(maxlinelen) + ' ' + chr(179) <br />      print chr(192)+chr(196) + chr(196)*maxlinelen + chr(196)+chr(217) <br />   else: <br />      print '+-' + '-'*maxlinelen + '-+' <br />      for line in lines: print '| ' + line.ljust(maxlinelen) + ' |' <br />      print '+-' + '-'*maxlinelen + '-+' <br /><br />def read(filename):<br /><br />   global counts<br />   counts = {'verts':0,'tris':0,'faces':0}<br /><br />   start = time.clock()<br /><br />   print_boxed("----------ASCII Scene Import----------")<br />   print 'Import File: ', filename<br /><br />   mode = Blender.Window.EditMode()     # are we in edit mode?  If so ...<br />   if mode: Blender.Window.EditMode(0) # leave edit mode before getting the mesh<br /><br />   file = open(filename,'r', OPT_FILE_BUFFER)<br />   ase_objects = read_file(file)<br />   file.close()<br />   spawn(ase_objects)<br />   Blender.Redraw()<br />   if OPT_PROGRESSBAR: Blender.Window.DrawProgressBar(1.0, '')  # clear progressbar<br />   # Blender.Window.EditMode(mode)<br /><br />   end = time.clock()<br />   seconds = " in %.2f %s" % (end-start, "seconds") <br />   #totals = "Imported Verts: %i Faces: %i Tris: %i " % (counts['verts'],counts['tris'],counts['faces'])<br />   #print_boxed(totals)<br />   message = "Successfully imported " + Blender.sys.basename(filename) + seconds <br />   print_boxed(message)<br /><br /><br /><br /><br />def read_ui(filename): <br /><br />   global IMPORT_SC, IMPORT_VC, IMP_UV, IMPORT_GO, IMPORT_SE, IMPORT_SM<br />   global IMP_SCALED,IMP_SMOOTHGROUPS,IMP_VCOLOR,IMP_UV,IMP_FGONS,IMP_QUADS,IMP_SEAMS,IMP_SMOOTHGROUPS,IMP_AUTOSMOOTH<br /><br />   IMPORT_SC = Blender.Draw.Create(IMP_SCALED)<br />   IMPORT_VC = Blender.Draw.Create(IMP_VCOLOR)<br />   IMP_UV = Blender.Draw.Create(IMP_UV)<br />   IMPORT_SE = Blender.Draw.Create(IMP_SEAMS)<br />   IMPORT_SM = Blender.Draw.Create(IMP_SMOOTHGROUPS)<br /><br />   # Get USER Options <br />   pup_block = [('Import Options'),('Scale Meshes', IMPORT_SC, 'Scale the Objects so that they better fit into Blender\'s grid size'),('Vertex Colors', IMPORT_VC, 'Import Vertex Colors if existing'),('UV (Layer)', IMP_UV, 'Import UV and UV layer\'s if existing'),('Smoothing', IMPORT_SM, 'Surround Smoothgroups with sharp edges'),('Seams', IMPORT_SE, 'Try to import Seams from UV islands (from the first UV layer!)')]<br /><br />   if not Blender.Draw.PupBlock('Import ASCII Scene...', pup_block):<br />      return<br /><br />   Blender.Window.WaitCursor(1)<br /><br />   IMP_SCALED = IMPORT_SC.val<br />   IMP_VCOLOR = IMPORT_VC.val<br />   IMP_UV = IMP_UV.val<br />   IMP_SEAMS = IMPORT_SE.val<br />   IMP_SMOOTHGROUPS = IMPORT_SM.val<br /><br />   read(filename)<br /><br />   Blender.Window.WaitCursor(0)<br />   Blender.Redraw()<br /><br /><br />if __name__ == '__main__' and OPT_FILESELECTOR:<br />   Blender.Window.FileSelector(read_ui, 'Import ASCII Scene', ('.ase'))<br />elif __name__ == '__main__':<br />   read_ui(OPT_STATIC_FILENAME)</div></div>

												<br /><br /><span class="gensmall">Last edited by <a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/memberlist.php?mode=viewprofile&amp;u=12761&amp;sid=0b1c0103b77fa8569d84397a188d28b9">Goofos</a> on Sun Jun 17, 2007 7:00 pm, edited 5 times in total.</span>
						<br clear="all" /><br /><table width="100%" cellspacing="0"><tr valign="middle"><td class="gensmall" align="right">
														</td>
						</tr></table></td>
				</tr></table></td>
		</tr><tr class="row1"><td class="profile"><strong><a href="viewtopic.php?f=50&amp;t=15404#wrapheader">Top</a></strong></td>
			<td><div class="gensmall" style="float: left;"> <a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/memberlist.php?mode=viewprofile&amp;u=12761&amp;sid=0b1c0103b77fa8569d84397a188d28b9"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/imageset/en/icon_user_profile.gif" alt="Profile" title="Profile" /></a>  </div> <div class="gensmall" style="float: right;"> </div></td>
		</tr><tr><td class="spacer" colspan="2" height="1"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/images/spacer.gif" alt="" width="1" height="1" /></td>
	</tr></table><table class="tablebg" width="100%" cellspacing="1"><tr class="row2"><td align="center" valign="middle">
				<a name="p140320" id="p140320"></a>
				<b class="postauthor">Bittoman</b>
			</td>
			<td width="100%" height="25">
				<table width="100%" cellspacing="0"><tr><td class="gensmall" width="100%"><div style="float: left;"> <b>Post subject:</b> </div><div style="float: right;"><a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/viewtopic.php?p=140320&amp;sid=0b1c0103b77fa8569d84397a188d28b9#p140320"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/imageset/icon_post_target.gif" width="12" height="9" alt="Post" title="Post" /></a><b>Posted:</b> Mon Apr 17, 2006 1:12 pm </div></td>
				</tr></table></td>
		</tr><tr class="row2"><td valign="top" class="profile">
				<table cellspacing="4" align="center" width="150"><tr><td><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/imageset/en/icon_user_offline.gif" alt="Offline" title="Offline" /></td>
				</tr><tr><td class="postdetails">True believer</td>
				</tr><tr><td><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/download/file.php?avatar=4625.jpg" width="47" height="64" alt="User avatar" /></td>
				</tr></table><span class="postdetails">
					<br /><b>Joined:</b> Sun Aug 29, 2004 10:39 pm<br /><b>Posts:</b> 1730				</span>

			</td>
			<td valign="top">
				<table width="100%" cellspacing="5"><tr><td>
					
						<div class="postbody">Nice job, thanks Goofos!</div>

					<br clear="all" /><br /><table width="100%" cellspacing="0"><tr valign="middle"><td class="gensmall" align="right">
														</td>
						</tr></table></td>
				</tr></table></td>
		</tr><tr class="row2"><td class="profile"><strong><a href="viewtopic.php?f=50&amp;t=15404#wrapheader">Top</a></strong></td>
			<td><div class="gensmall" style="float: left;"> <a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/memberlist.php?mode=viewprofile&amp;u=4625&amp;sid=0b1c0103b77fa8569d84397a188d28b9"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/imageset/en/icon_user_profile.gif" alt="Profile" title="Profile" /></a>  </div> <div class="gensmall" style="float: right;"> </div></td>
		</tr><tr><td class="spacer" colspan="2" height="1"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/images/spacer.gif" alt="" width="1" height="1" /></td>
	</tr></table><table class="tablebg" width="100%" cellspacing="1"><tr class="row1"><td align="center" valign="middle">
				<a name="p140355" id="p140355"></a>
				<b class="postauthor" style="color: #AA0000">kat</b>
			</td>
			<td width="100%" height="25">
				<table width="100%" cellspacing="0"><tr><td class="gensmall" width="100%"><div style="float: left;"> <b>Post subject:</b> </div><div style="float: right;"><a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/viewtopic.php?p=140355&amp;sid=0b1c0103b77fa8569d84397a188d28b9#p140355"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/imageset/icon_post_target.gif" width="12" height="9" alt="Post" title="Post" /></a><b>Posted:</b> Mon Apr 17, 2006 10:30 pm </div></td>
				</tr></table></td>
		</tr><tr class="row1"><td valign="top" class="profile">
				<table cellspacing="4" align="center" width="150"><tr><td><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/imageset/en/icon_user_offline.gif" alt="Offline" title="Offline" /></td>
				</tr><tr><td class="postdetails">"...mostly harmless?!"</td>
				</tr><tr><td><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/download/file.php?avatar=8.gif" width="48" height="48" alt="User avatar" /></td>
				</tr></table><span class="postdetails">
					<br /><b>Joined:</b> Thu Nov 08, 2001 11:00 pm<br /><b>Posts:</b> 4940<br /><b>Location:</b> UK, York				</span>

			</td>
			<td valign="top">
				<table width="100%" cellspacing="5"><tr><td>




<!--
     FILE ARCHIVED ON 18:15:16 May 9, 2007 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 0:05:36 Sep 26, 2014.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
--></td></tr></table></td></tr></table></div></div></body>
</html>
]]></body></post><post id="p140291" date="Posted: Mon Apr 17, 2006 2:00 am "><author>Goofos</author><body><![CDATA[<div class="postbody"><img src="https://web.archive.org/web/20081203142618im_/http://www.doom3world.org/phpbb2/images/smilies/icon_arrow.gif" alt=":arrow:" title="Arrow" /> Version: 0.13
<br /><br />Supports Mesh Objects with vertex colors, multiple UV, smoothgroups.
<br /><br />A little Note!: you should not try to import very big ase files (&gt;50 MB with 512 MB RAM). With much RAM you might can try this.
<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">#!BPY<br /><br />"""<br />Name: 'ASCII Scene (.ase) v0.13'<br />Blender: 244<br />Group: 'Import'<br />Tooltip: 'Import from ASCII Scene Export file format (.ase)'<br />""" <br />__author__ = "Goofos"<br />__version__ = "0.13"<br /><br /># goofos<br />#<br /># ***** BEGIN GPL LICENSE BLOCK *****<br />#<br /># This program is free software; you can redistribute it and/or<br /># modify it under the terms of the GNU General Public License<br /># as published by the Free Software Foundation; either version 2<br /># of the License, or (at your option) any later version.<br /># <br /># This program is distributed in the hope that it will be useful,<br /># but WITHOUT ANY WARRANTY; without even the implied warranty of<br /># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<br /># GNU General Public License for more details.<br /># <br /># You should have received a copy of the GNU General Public License<br /># along with this program; if not, write to the Free Software Foundation,<br /># Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.<br /># <br /># ***** END GPL LICENCE BLOCK *****<br /><br />import time, sys<br />import Blender<br />from Blender import Scene, Object, Mesh<br /><br />'''<br />Some Options<br />'''<br /># Scale Factor (float)<br />OPT_SCALE = 0.1<br /># Add EdgeSplit Modifier when importing sharp edges (bool)<br />OPT_MOD_EDGESPLIT = True<br /># Enable the fileselector (bool)<br />OPT_FILESELECTOR = True<br /># If the fileselector is disabled, specify a static filename (string)<br />OPT_STATIC_FILENAME = 'E:\ASE Files\garage.ASE'<br /># Enable Progressbar (bool)<br />OPT_PROGRESSBAR = False<br /># File buffer. After testing with big files i think there is no real difference.<br /># -1 = system default, 0 = unbuffered, 1 = line buffered, &gt;1 = buffer size<br />OPT_FILE_BUFFER = -1<br /><br />'''<br />Import Options<br />'''<br /># Import Meshes scaled, defined by the scale factor of OPT_SCALE (bool)<br /># Note: Object location data looses some precision, .. i think!<br />IMP_SCALED = True<br /># Import Vertex Colors (bool)<br />IMP_VCOLOR = True<br /># Import UV Coords and UV layers (bool)<br />IMP_UV = True<br /># Import NGons as Blender FGons (bool)<br /># Note: Include quads, too.<br />IMP_FGONS = False<br /># Try to find possible quads and convert the two tris to a quad (bool)<br /># Note: Very slow!! ablsolutely doesn't work accurate :/<br /># i don't know wether this is a script problem or a blender problem!<br />IMP_QUADS = False<br /># Surround UV islands with seams (bool)<br />IMP_SEAMS = False<br /># Surround smooth groups with sharp edges (bool)<br />IMP_SMOOTHGROUPS = True<br /># Try to find the lowest autosmooth angle in vertex normals (bool)<br /># Note: i dont know if this is correct :&gt;<br />IMP_AUTOSMOOTH = False<br /><br /><br /><br /><br /><br />class Ase_group:<br />   def __init__(self):<br />      self.name = 'Name'<br />      self.ase_type = 'GROUP'<br />      self.ase_helper = None<br />      self.ase_objects = []<br /><br />class Ase_object:<br /><br />   def __init__(self, ase_object_type, name=''):<br />      #if ase_object_type not in ['GEOM','HELPER','SHAPE','LIGHT','CAMERA']: return<br />      if ase_object_type not in ['geom','helper','shape','light','camera']: return<br />      self.name = name<br />      self.ase_type = ase_object_type #GEOM, HELPER, SHAPE, LIGHT, CAMERA<br />      self.row0 = None<br />      self.row1 = None<br />      self.row2 = None<br />      self.row3 = None<br />      self.parent = None<br /><br />      #new_ase_data = None<br />      if ase_object_type == 'geom':<br />         new_ase_data = Ase_mesh(self)<br />      self.ase_data = new_ase_data<br /><br />class Ase_mesh:<br />   def __init__(self, ase_obj=None):<br />      self.name = 'Name'<br />      self.num = {'VERTS':0,'FACES':0,'CVERTEX':0,'CVFACES':0}<br />      self.ase_verts = {}<br />      self.vertseq = []<br />      self.ase_edges = {}<br />      self.ase_faces = {}<br />      self.faceseq = []<br />      self.ase_uv_channels = {}<br />      self.active_uv = None<br />      self.ase_vertcolors = {}<br />      self.ase_cfaces = {}<br />      self.autosmooth = 0<br />      self.hasUV = 0<br />      self.hasVC = 0 <br /><br />   def sort_edgekeys(self,vi0,vi1,vi2):<br />      '''<br />      Returns sorted edge keys of the given triangle vert indicies.<br />      '''<br />      if vi0 &gt; vi1: ed_k0 = vi1,vi0<br />      else: ed_k0 = vi0,vi1<br />      if vi1 &gt; vi2: ed_k1 = vi2,vi1<br />      else: ed_k1 = vi1,vi2<br />      if vi0 &gt; vi2: ed_k2 = vi2,vi0<br />      else: ed_k2 = vi0,vi2<br />      return ed_k0,ed_k1,ed_k2<br /><br />   def append_vert(self, ase_vert_index, x, y, z):<br />      '''<br />      Create a new Vertex for this Mesh.<br />      '''<br />      ase_v = Ase_vert(ase_vert_index, x, y, z)<br />      self.ase_verts[ase_vert_index] = ase_v<br />      #self.vertseq.insert(ase_vert_index, (ase_v.co.x,ase_v.co.y,ase_v.co.z))<br />      self.vertseq.insert(ase_vert_index, ase_v.co)<br />      <br />   def append_face(self, index, vi0, vi1, vi2, AB=1, BC=1, CA=1, smooth_groups=[0], mat_indices=0):<br />      '''<br />      Uhm ... work in progress!<br />      '''<br />      # create a new Ase_face<br />      ase_f = Ase_face(index, vi0, vi1, vi2, smooth_groups, mat_indices)<br />      ed_keys = self.sort_edgekeys(vi0,vi1,vi2)<br />      #ed_keys = [vi0,vi1].sort(),[vi1,vi2].sort(),[vi0,vi2].sort()<br />      ase_f.edge_keys = ed_keys<br />      ase_f.vis_sum = AB+BC+CA<br />      if ase_f.vis_sum == 2:<br />         if not AB: ase_f.tri_edge = ed_keys[0]<br />         elif not BC: ase_f.tri_edge = ed_keys[1]<br />         elif not CA: ase_f.tri_edge = ed_keys[2]<br /><br />      # set visibility (fgon) and sharp for edges<br />      # and look if the two face users might form a quad<br />      # or create a new Ase_edge<br />      for k,vis in zip(ed_keys,[AB,BC,CA]):<br />         # Ase_edge already exist or create a new one<br />         if not self.ase_edges.has_key(k):<br />            ase_ed = Ase_edge(k)<br />            ase_ed.fusers.append(ase_f.index)<br />            ase_ed.visible = vis<br />            self.ase_edges[k] = ase_ed<br />            continue<br />         else:<br />            ase_ed = self.ase_edges[k]<br />            ase_ed.fusers.append(ase_f.index)<br />            if ase_f.vis_sum == 2 and not ase_ed.visible:<br />               ase_f.tri_edge = k<br /><br />         fusers = [i for i in ase_ed.fusers if i != ase_f.index]<br />         if not fusers: continue<br />         for i in fusers:<br />            ase_f2 = self.ase_faces[i]<br />            # if this edge is invisible and both tris only have<br />            # this invisible edge, than the two tris could form a quad<br />            # easy done with a sum of all vis variables of the edges<br />            if k == ase_f.tri_edge:<br />               if ase_f.tri_edge == ase_f2.tri_edge:<br />                  ase_f.quad_team = ase_f2.index<br />                  ase_f2.quad_team = ase_f.index<br /><br />            # look if this edge is sharp<br />            # if not both faces share at least one smoothgroup var<br />            # than this edge is sharp<br />            #if ase_ed.sharp: continue<br />            for sg in smooth_groups:<br />               if sg not in ase_f2.smooth_groups:<br />                  ase_ed.sharp = True<br /><br />      self.ase_faces[ase_f.index] = ase_f<br />      self.faceseq.insert(ase_f.index, (ase_f.v0, ase_f.v1, ase_f.v2))<br /><br />   def append_uv_channel(self, layer_index=1):<br />      ''' <br />      Create a new UV Layer and set it active.<br />      '''<br />      self.ase_uv_channels[layer_index] = Ase_uv_channel(layer_index)<br />      self.active_uv = self.ase_uv_channels[layer_index]<br /><br />   def append_tvert(self, ase_uv_index, u, v, w=0):<br />      '''<br />      Create a new UV Vector in the active! UV Channel.<br />      '''<br />      if not self.active_uv: return<br />      #self.active_uv.ase_tverts[ase_uv_index] = Ase_tvert(ase_uv_index,u,v,w)<br />      self.active_uv.ase_tverts[ase_uv_index] = (u,v)<br /><br />   def append_tface(self, ase_face_index, uvi0, uvi1, uvi2, opt_check_seams=False):<br />      '''<br />      Create a new Face UV with indicies to UV Vectors in the active UV Layer.<br />      Optional check for Seams and store into the UV Channel.<br />      '''<br />      if not self.active_uv: return<br />      self.active_uv.ase_tfaces[ase_face_index] = [uvi0, uvi1, uvi2]<br />      # look if this face has seams<br />      # might useless because it makes no sense to import seams for all UV layers<br />      # that's why those edge keys are separately written to each ase UV layer<br />      if opt_check_seams:<br />         edge_keys = self.ase_faces[ase_face_index].edge_keys<br />         for ed_key,uvs in zip(edge_keys,[[uvi0,uvi1],[uvi1,uvi2],[uvi0,uvi2]]):<br />            uvs.sort()<br />            ase_ed,active_uv = self.ase_edges[ed_key],self.active_uv<br />            if not active_uv.ase_tedges.has_key(ed_key):<br />               active_uv.ase_tedges[ed_key] = uvs<br />               continue<br />            elif active_uv.ase_tedges[ed_key] != uvs:<br />               active_uv.seams.append(ed_key)<br /><br />   def append_vertcol(self, ase_color_index, r, g, b):<br />      #new = Ase_vertcolor(ase_color_index, r, g, b)<br />      #self.ase_vertcolors[ase_color_index] = new<br />      self.ase_vertcolors[ase_color_index] = (r,g,b)<br />      <br />   def append_cface(self, ase_face_index, ci0, ci1, ci2):<br />      ase_f = self.ase_faces[ase_face_index]<br />      #f.c0, f.c1, f.c2 = ci0, ci1, ci2<br />      self.ase_cfaces[ase_face_index] = (ci0, ci1, ci2)<br /><br />   def append_normal(self, ase_face_index, x, y, z):<br />      self.ase_faces[ase_face_index].normal = Blender.Mathutils.Vector(x,y,z)<br /><br />   def append_vnormal(self, ase_face_index, ase_vert_index, x, y, z, opt_check_smooth=False):<br />      ase_f = self.ase_faces[ase_face_index]<br />      self.ase_verts[ase_vert_index].normals[ase_face_index] = Blender.Mathutils.Vector(x,y,z)<br />      if opt_check_smooth and ase_f.smooth_groups:<br />         ase_edges = [self.ase_edges[key] for key in ase_f.edge_keys]<br />         for ed_key,ase_ed in zip(ase_f.edge_keys,ase_edges):<br />            if ase_ed.sharp or len(ase_ed.fusers) &lt; 2: continue<br />            for vi in ed_key:<br />               if not self.ase_verts.has_key(vi): continue<br />               vnormals = self.ase_verts[vi].normals<br />               fi0, fi1 = ase_ed.fusers[0:2]<br />               if vnormals.has_key(fi0) and vnormals.has_key(fi1):<br />                  vnor0, vnor1 = vnormals[fi0],vnormals[fi1]<br />                  if vnor0 == vnor1:<br />                     continue<br />                  else:<br />                     angle = round(Blender.Mathutils.AngleBetweenVecs(vnor0, vnor1))<br />                     if not self.autosmooth: self.autosmooth = angle<br />                     elif angle and self.autosmooth &gt; angle:<br />                        print angle<br />                        self.autosmooth = angle<br /><br /><br />class Ase_vert:<br />   def __init__(self, index, x, y, z):<br />      self.index = index<br />      #self.co = Blender.Mathutils.Vector(x,y,z)<br />      self.co = (x,y,z)<br />      self.normals = {}<br /><br />class Ase_edge:<br />   def __init__(self, key):<br />      self.key = key<br />      self.fusers = []<br />      self.uvs = None<br />      self.visible = 1<br />      self.sharp = False<br /><br />class Ase_face:<br />   def __init__(self, ase_face_index, v0, v1, v2, smooth_groups=0, mat_indices=0):<br />      self.index = ase_face_index<br />      self.v0 = v0<br />      self.v1 = v1<br />      self.v2 = v2<br />      self.edge_keys = None<br />      self.c0 = None<br />      self.c1 = None<br />      self.c2 = None<br />      self.normal = None<br />      #self.vert_normals = {}<br />      self.mat_indices = mat_indices<br />      self.smooth_groups = smooth_groups # 0 = solid face<br />      self.vis_sum = 3<br />      self.quad_team = None<br />      self.tri_edge = None<br /><br />class Ase_uv_channel:<br />   def __init__(self, index=1):<br />      self.index = index<br />      self.num = {'TVERTEX':0,'TVFACES':0}<br />      self.uv_layer_name = 'UVTex#' + str(self.index)<br />      self.ase_tverts = {}<br />      self.ase_tfaces = {}<br />      self.ase_tedges = {}<br />      self.seams = []<br /><br />class Ase_tvert:<br />   def __init__(self,index, u, v, w=0):<br />      self.index = index<br />      #self.vec = Blender.Mathutils.Vector(u,v)<br />      self.vec = (u,v)<br /><br />class Ase_tface:<br />   def __init__(self, index, uvi0, uvi1, uvi2):<br />      self.index = index<br />      self.uv = {0:uvi0, 1:uvi1, 2:uvi2}<br /><br />class Ase_vertcolor:<br />   def __init__(self, index, r, g, b):<br />      self.index = 0 <br />      self.r = round(r*256)<br />      self.g = round(g*256)<br />      self.b = round(b*256)<br />      self.a = 255.0<br /><br /><br />def spawn(ase_objects):<br /><br />   PB_index = 0.0<br />   PB_num = float(len(ase_objects))<br /><br />   print 'Import Objects...'<br />   if OPT_PROGRESSBAR: Blender.Window.DrawProgressBar(0.0, "Importing Objects...")<br /><br />   scene = Blender.Scene.GetCurrent()<br />   for ase_ob in ase_objects: <br />      if OPT_PROGRESSBAR and not (PB_index % PB_num):<br />         Blender.Window.DrawProgressBar(PB_index / PB_num, "Importing Objects...")<br /><br />      if ase_ob.ase_type == 'geom':<br />         spawn_mesh(scene,ase_ob)<br /><br />      PB_index += 1.0<br /><br />def spawn_mesh(scene,ase_ob):<br /><br />   ase_me = ase_ob.ase_data<br />   #normal_flag = 1<br /><br />   row0 = ase_ob.row0<br />   row1 = ase_ob.row1<br />   row2 = ase_ob.row2<br />   row3 = ase_ob.row3<br /><br />   matrix = Blender.Mathutils.Matrix(row0, row1, row2, row3)<br />   matrix.resize4x4()<br /><br />   # create new Blender Object and link to scene<br />   ob = Blender.Object.New('Mesh', ase_ob.name)<br />   ob.setMatrix(matrix)<br />   scene.objects.link(ob)<br /><br />   # get Mesh data from Object<br />   me = ob.getData(0,1)<br />   me.vertexColors = me.faceUV = False<br /><br />   # create Verts and Faces<br />   # seems like extend() is limited to a length of 64000?<br />   # this is a problem when importing big meshes.<br />   div = divmod(ase_me.num['VERTEX'], 64000)<br />   if div[1]: div = div[0]+1<br />   else: div = div[0]<br />   start = 0<br />   for i in range(div):<br />      end = start+64000<br />      me.verts.extend(ase_me.vertseq[start:end])<br />      start = end<br />   div = divmod(ase_me.num['FACES'], 64000)<br />   face_index_list = []<br />   if div[1]: div = div[0]+1<br />   else: div = div[0]<br />   start = 0<br />   for i in range(div):<br />      end = start+64000<br />      me.faces.extend(ase_me.faceseq[start:end])<br />      start = end<br /><br />   # import Vertex Colors, Solid/Smooth to faces<br />   if IMP_VCOLOR:<br />      me.vertexColors = ase_me.hasVC<br />      ase_vcolors = ase_me.ase_vertcolors<br />   for i,ase_f in ase_me.ase_faces.iteritems():<br />      try:f = me.faces[i]<br />      except:<br />         # dont know what's the problem with this<br />         print 'array index out of range:', i<br />         continue<br />      if me.vertexColors:<br />         cface = ase_me.ase_cfaces[i]<br />         c0,c1,c2 = ase_vcolors[cface[0]],ase_vcolors[cface[1]],ase_vcolors[cface[2]]<br />         fc0,fc1,fc2 = f.col[:]<br />         fc0.r,fc0.g,fc0.b = int(c0[0]*255),int(c0[1]*255),int(c0[2]*255)<br />         fc1.r,fc1.g,fc1.b = int(c1[0]*255),int(c1[1]*255),int(c1[2]*255)<br />         fc2.r,fc2.g,fc2.b = int(c2[0]*255),int(c2[1]*255),int(c2[2]*255)<br />      if ase_f.smooth_groups:<br />         f.smooth = 1<br /><br />   # import UV layer's<br />   if IMP_UV and ase_me.hasUV:<br />      for uv_chan in ase_me.ase_uv_channels.itervalues():<br />         me.addUVLayer(uv_chan.uv_layer_name)<br />         me.activeUVLayer = uv_chan.uv_layer_name<br />         tverts = uv_chan.ase_tverts<br />         for fi,uvis in uv_chan.ase_tfaces.iteritems():<br />            try:f = me.faces[fi]<br />            except: continue<br />            uv1,uv2,uv3 = tverts[uvis[0]],tverts[uvis[1]],tverts[uvis[2]]<br />            f.uv = [Blender.Mathutils.Vector(uv1), Blender.Mathutils.Vector(uv2), Blender.Mathutils.Vector(uv3)]<br />      me.activeUVLayer = ase_me.ase_uv_channels[1].uv_layer_name<br /><br />   # EXPERIMENTAL!<br />   # convert tris to quads<br />   # this is currently the easiest way i found without destroying uvs or vcolors<br />   # but don't work like expected...:/<br />   if IMP_QUADS:<br />      #quad_teams = set([i for i,ase_f in ase_me.ase_faces.iteritems() if ase_f.quad_team != None])<br />      quad_teams = []<br />      for i,ase_f in ase_me.ase_faces.iteritems():<br />         if ase_f.quad_team != None:<br />            if ase_f.index &lt; ase_f.quad_team: qt = ase_f.index,ase_f.quad_team<br />            elif ase_f.index &gt; ase_f.quad_team: qt = ase_f.quad_team,ase_f.index<br />            if qt not in quad_teams:<br />               quad_teams.append(qt)<br /><br />      faces = me.faces<br />      # first deselect all faces<br />      for f in faces: f.sel = 0<br />      for t0,t1 in quad_teams:<br />         ase_f0 = ase_me.ase_faces[t0]<br />         ase_f1 = ase_me.ase_faces[t1]<br />         try: f0,f1 = me.faces[ase_f0.index], me.faces[ase_f1.index]<br />         except: continue<br />         f0.sel = 1<br />         f1.sel = 1<br />         me.triangleToQuad()<br />         for i in faces.selected():<br />            faces[i].sel = 0<br /><br />   # apply the matrix to mesh (and optional fit the ob and me to blender)<br />   if IMP_SCALED:<br />      # seems this isn't accurate because of precision of the location vector<br />      scale = Blender.Mathutils.ScaleMatrix(OPT_SCALE,4)<br />      inv_matrix = ob.getMatrix().copy().invert() * scale<br />      ob.setLocation(ob.getMatrix().translationPart() * scale)<br />   else:<br />      inv_matrix = ob.getMatrix().copy().invert()<br />   me.transform(inv_matrix, 1)<br />   me.calcNormals()<br /><br />   # apply sharp, seam and fgon flags to edges.<br />   add_EDGESPLIT = False<br />   if IMP_FGONS or IMP_SEAMS or IMP_SMOOTHGROUPS:<br />      SHARP = Mesh.EdgeFlags.SHARP<br />      SEAM = Mesh.EdgeFlags.SEAM<br />      FGON = Mesh.EdgeFlags.FGON<br />      seam_keys = []<br />      if ase_me.hasUV: seam_keys = ase_me.ase_uv_channels[1].seams<br />      for k,ase_ed in ase_me.ase_edges.iteritems():<br />         if ase_ed.sharp or not ase_ed.visible or k in seam_keys:<br />            edi = me.findEdges(k[0],k[1])<br />            if edi:<br />               ed = me.edges[edi]<br />               if ase_me.hasUV and k in seam_keys and IMP_SEAMS: ed.flag |= SEAM<br />               if not ase_ed.visible and IMP_FGONS: ed.flag |= FGON<br />               if ase_ed.sharp and IMP_SMOOTHGROUPS:<br />                    ed.flag |= SHARP<br />                  add_EDGESPLIT = True<br /><br /><br /><br />   # add EdgeSplit Modiefier when the mesh has sharp edges<br />   # autosmooth is EXPERIMENTAL! because i dont know if this is correct!<br />   if add_EDGESPLIT and OPT_MOD_EDGESPLIT:<br />      mod = ob.modifiers.append(Blender.Modifier.Types.EDGESPLIT)<br />      if not ase_me.autosmooth:<br />         mod[Blender.Modifier.Settings.EDGESPLIT_FROM_ANGLE] = 0<br />      else:<br />         mod[Blender.Modifier.Settings.EDGESPLIT_ANGLE] = ase_me.autosmooth<br />      mod[Blender.Modifier.Settings.EDGESPLIT_FROM_SHARP] = 1<br />      ob.makeDisplayList() # Needed to apply the modifier<br />   elif not add_EDGESPLIT and ase_me.autosmooth:<br />      AUTOSMOOTH = Mesh.Modes.AUTOSMOOTH<br />      me.modes |= AUTOSMOOTH<br />      me.degr = ase_me.autosmooth<br /><br />   me.update()<br />   counts['verts'] += ase_me.num['VERTEX']<br />   counts['tris'] += ase_me.num['FACES']<br />   counts['faces'] += len(me.faces)<br />   print 'Imported Mesh-Object: ', ob.name<br /><br />#def oj_the_object_jockey(file):<br />def read_file(file):<br />   '''<br />   Read an .ase file and return a list of ase_objects<br />   '''<br />   lines= file.readlines()<br /><br />   print 'Read file...'<br />   PB_index = 0.0<br />   PB_num = float(len(lines))<br />   if OPT_PROGRESSBAR: Blender.Window.DrawProgressBar(0.0, "Read File...")<br /><br />   # it is needed to read UV if Seams should be imported even when importing UV is disabled<br />   READ_UV = False<br />   if IMP_UV or IMP_SEAMS: READ_UV = True<br />   #if IMP_AUTOSMOOTH and not IMP_SMOOTHGROUPS: IMP_AUTOSMOOTH = False<br /><br />   ase_objects = []<br />   ase_ob = False<br />   for line in lines:<br />      if OPT_PROGRESSBAR and not (PB_index % 10000):<br />         Blender.Window.DrawProgressBar(PB_index / PB_num, "Read File...")<br />      PB_index += 1<br /><br />      words = line.split()<br />      if not words:<br />         continue<br />      word0 = words[0]<br />      if word0 == '*GEOMOBJECT':<br />         #if ase_ob: ase_objects.append(ase_ob)<br />         ase_ob_type = word0.lower()[1:-6] #get rid of '*' and 'OBJECT'<br />         ase_ob = Ase_object(ase_ob_type)<br />         ase_objects.append(ase_ob)<br />         continue<br />      elif word0 in ['*HELPEROBJECT','*SHAPEOBJECT','*LIGHTOBJECT','*CAMERAOBJECT','*GROUP']:<br />         # Not supported objects!<br />         # because these objects too use a TM_NODE,<br />         # ase_ob should be set back to False to prevent errors.<br />         ase_ob = False<br />         continue<br />      elif word0 == '*NODE_NAME' and ase_ob:<br />         name = words[1][1:-1] #get rid of '"'<br />         if ase_ob and ase_ob.name != '': ase_ob.ase_data.name = name<br />         elif ase_ob: ase_ob.name = name<br />         continue<br />      elif word0 == '*NODE_PARENT' and ase_ob:<br />         ase_ob.parent = words[1][1:-1] #get rid of '"'<br />         continue<br />      elif word0 == '*TM_ROW0' and ase_ob:<br />         ase_ob.row0 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*TM_ROW1' and ase_ob:<br />         ase_ob.row1 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*TM_ROW2' and ase_ob:<br />         ase_ob.row2 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*TM_ROW3' and ase_ob:<br />         ase_ob.row3 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*MESH':<br />         ase_me = ase_ob.ase_data<br />         continue<br />      elif word0 == '*MESH_NUMVERTEX':<br />         ase_me.num['VERTEX'] = int(words[1])<br />         continue<br />      elif word0 == '*MESH_NUMFACES':<br />         ase_me.num['FACES'] = int(words[1])<br />         continue<br />      elif word0 == '*MESH_VERTEX':<br />         #vert_index, x, y, z<br />         ase_me.append_vert(int(words[1]),float(words[2]),float(words[3]),float(words[4]))<br />         continue<br />      elif word0 == '*MESH_FACE':<br />         #ase_face_index, vi0, vi1, vi2, AB, BC, CA, smooth_groups, mat_indicies<br />         #smooth = mat = False<br />         ase_face_index = words[1]<br />         if ase_face_index.endswith(':'):<br />            ase_face_index = ase_face_index[:-1]<br /><br />         smooth_groups = mat_indices = []<br />         for i,w in enumerate(words):<br />            if w == '*MESH_SMOOTHING' and IMP_SMOOTHGROUPS:<br />               try:<br />                  if words[i+1] != '*MESH_MTLID':<br />                     smooth_groups = [int(i) for i in words[i+1].split(',')]<br />               except:<br />                  smooth_groups = 0<br />            elif w == '*MESH_MTLID' and IMP_SMOOTHGROUPS:<br />               try:<br />                  mat_indices = [int(i) for i in words[i+1].split(',')]<br />               except:<br />                  mat_indices = 0<br />         ase_me.append_face(int(ase_face_index),int(words[3]),int(words[5]),int(words[7]),int(words[9]),int(words[11]),int(words[13]),smooth_groups,mat_indices)<br />         continue<br />      elif READ_UV:<br />         if word0 == '*MESH_NUMTVERTEX':<br />            if not ase_me.ase_uv_channels: ase_me.append_uv_channel()<br />            ase_me.active_uv.num['TVERTEX'] = int(words[1])<br />            ase_me.hasUV = True<br />            continue<br />         elif word0 == '*MESH_MAPPINGCHANNEL':<br />            # uv_channel_index<br />            ase_me.append_uv_channel(int(words[1]))<br />            continue<br />         elif word0 == '*MESH_TVERT':<br />            #uv_index, u, v, w<br />            ase_me.append_tvert(int(words[1]),float(words[2]),float(words[3]),float(words[4]))<br />            continue<br />         elif word0 == '*MESH_NUMTVFACES':<br />            ase_me.active_uv.num['TVFACES'] = int(words[1])<br />            continue<br />         elif word0 == '*MESH_TFACE':<br />            #ase_face_index, uv0, uv1, uv2, opt_IMP_SEAMS<br />            ase_face_index = words[1]<br />            if ase_face_index.endswith(':'):<br />               ase_face_index = ase_face_index[:-1]<br />            ase_me.append_tface(int(ase_face_index),int(words[2]),int(words[3]),int(words[4]),IMP_SEAMS)<br />            continue<br />      elif IMP_VCOLOR:<br />         if word0 == '*MESH_NUMCVERTEX':<br />            ase_me.num['CVERTEX'] = int(words[1])<br />            if ase_me.num['CVERTEX']:<br />               ase_me.hasVC = True<br />            continue<br />         elif word0 == '*MESH_VERTCOL':<br />            #color_index, r, g, b<br />            ase_me.append_vertcol(int(words[1]),float(words[2]),float(words[3]),float(words[4]))<br />            continue<br />         elif word0 == '*MESH_NUMCVFACES':<br />            ase_me.num['CVFACES'] = words[1]<br />            continue<br />         elif word0 == '*MESH_CFACE':<br />            #ase_face_index, ci0, ci1, ci2<br />            ase_face_index = words[1]<br />            if ase_face_index.endswith(':'):<br />               ase_face_index = ase_face_index[:-1]<br />            ase_me.append_cface(int(ase_face_index),int(words[2]),int(words[3]),int(words[4]))<br />            continue<br />      #elif word0 == '*MESH_NORMALS':<br />      elif IMP_AUTOSMOOTH:<br />         if word0 == '*MESH_FACENORMAL':<br />            # ase_face_index, x, y, z<br />            ase_face_index = int(words[1])<br />            ase_me.append_normal(ase_face_index,float(words[2]),float(words[3]),float(words[4]))<br />            continue<br />         elif word0 == '*MESH_VERTEXNORMAL':<br />            # ase_face_index, ase_vert_index, x, y, z<br />            ase_me.append_vnormal(ase_face_index,int(words[1]),float(words[2]),float(words[3]),float(words[4]),IMP_AUTOSMOOTH)<br />            continue<br />      else:<br />         continue<br />   return ase_objects<br /><br />def print_boxed(text): #Copy/Paste from meshtools, only to remove the beep :)<br />   lines = text.splitlines()<br />   maxlinelen = max(map(len, lines))<br />   if sys.platform[:3] == "win":<br />      print chr(218)+chr(196) + chr(196)*maxlinelen + chr(196)+chr(191) <br />      for line in lines: <br />         print chr(179) + ' ' + line.ljust(maxlinelen) + ' ' + chr(179) <br />      print chr(192)+chr(196) + chr(196)*maxlinelen + chr(196)+chr(217) <br />   else: <br />      print '+-' + '-'*maxlinelen + '-+' <br />      for line in lines: print '| ' + line.ljust(maxlinelen) + ' |' <br />      print '+-' + '-'*maxlinelen + '-+' <br /><br />def read(filename):<br /><br />   global counts<br />   counts = {'verts':0,'tris':0,'faces':0}<br /><br />   start = time.clock()<br /><br />   print_boxed("----------ASCII Scene Import----------")<br />   print 'Import File: ', filename<br /><br />   mode = Blender.Window.EditMode()     # are we in edit mode?  If so ...<br />   if mode: Blender.Window.EditMode(0) # leave edit mode before getting the mesh<br /><br />   file = open(filename,'r', OPT_FILE_BUFFER)<br />   ase_objects = read_file(file)<br />   file.close()<br />   spawn(ase_objects)<br />   Blender.Redraw()<br />   if OPT_PROGRESSBAR: Blender.Window.DrawProgressBar(1.0, '')  # clear progressbar<br />   # Blender.Window.EditMode(mode)<br /><br />   end = time.clock()<br />   seconds = " in %.2f %s" % (end-start, "seconds") <br />   #totals = "Imported Verts: %i Faces: %i Tris: %i " % (counts['verts'],counts['tris'],counts['faces'])<br />   #print_boxed(totals)<br />   message = "Successfully imported " + Blender.sys.basename(filename) + seconds <br />   print_boxed(message)<br /><br /><br /><br /><br />def read_ui(filename): <br /><br />   global IMPORT_SC, IMPORT_VC, IMP_UV, IMPORT_GO, IMPORT_SE, IMPORT_SM<br />   global IMP_SCALED,IMP_SMOOTHGROUPS,IMP_VCOLOR,IMP_UV,IMP_FGONS,IMP_QUADS,IMP_SEAMS,IMP_SMOOTHGROUPS,IMP_AUTOSMOOTH<br /><br />   IMPORT_SC = Blender.Draw.Create(IMP_SCALED)<br />   IMPORT_VC = Blender.Draw.Create(IMP_VCOLOR)<br />   IMP_UV = Blender.Draw.Create(IMP_UV)<br />   IMPORT_SE = Blender.Draw.Create(IMP_SEAMS)<br />   IMPORT_SM = Blender.Draw.Create(IMP_SMOOTHGROUPS)<br /><br />   # Get USER Options <br />   pup_block = [('Import Options'),('Scale Meshes', IMPORT_SC, 'Scale the Objects so that they better fit into Blender\'s grid size'),('Vertex Colors', IMPORT_VC, 'Import Vertex Colors if existing'),('UV (Layer)', IMP_UV, 'Import UV and UV layer\'s if existing'),('Smoothing', IMPORT_SM, 'Surround Smoothgroups with sharp edges'),('Seams', IMPORT_SE, 'Try to import Seams from UV islands (from the first UV layer!)')]<br /><br />   if not Blender.Draw.PupBlock('Import ASCII Scene...', pup_block):<br />      return<br /><br />   Blender.Window.WaitCursor(1)<br /><br />   IMP_SCALED = IMPORT_SC.val<br />   IMP_VCOLOR = IMPORT_VC.val<br />   IMP_UV = IMP_UV.val<br />   IMP_SEAMS = IMPORT_SE.val<br />   IMP_SMOOTHGROUPS = IMPORT_SM.val<br /><br />   read(filename)<br /><br />   Blender.Window.WaitCursor(0)<br />   Blender.Redraw()<br /><br /><br />if __name__ == '__main__' and OPT_FILESELECTOR:<br />   Blender.Window.FileSelector(read_ui, 'Import ASCII Scene', ('.ase'))<br />elif __name__ == '__main__':<br />   read_ui(OPT_STATIC_FILENAME)</div></div>]]></body></post><post id="p140320" date="Posted: Mon Apr 17, 2006 1:12 pm "><author>Bittoman</author><body><![CDATA[<div class="postbody">Nice job, thanks Goofos!</div>]]></body></post><post id="p140355" date="Posted: Mon Apr 17, 2006 10:30 pm "><author>kat</author><body><![CDATA[<div class="postbody">Not tried it yet but 'GG' on doing this one. Another step up the ladder for Blender!</div>]]></body></post><post id="p143616" date="Posted: Fri May 19, 2006 8:04 pm "><author>kat</author><body><![CDATA[<div class="postbody">Just tried this script for the 1st time and encountered the following error with Blender 2.41 when run as a script from the text window (Alt+P).
<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">IndentationError: unindent does not match any outer indentation level<br />  File "goofosASE_import_17Ap", line 295<br />    if obj.objType == 'Mesh':<br />                             ^</div></div>]]></body></post><post id="p143762" date="Posted: Sun May 21, 2006 3:58 pm "><author>Goofos</author><body><![CDATA[<div class="postbody">Should work now. Seems my OS is a bit more tollerant with format errors :&gt;</div>]]></body></post><post id="p144077" date="Posted: Fri May 26, 2006 10:43 am "><author>OrbWeaver</author><body><![CDATA[<div class="postbody">I haven't tried this but it sounds great. Until now ASE has been almost universally considered an "export-only" format.</div>]]></body></post><post id="p144120" date="Posted: Fri May 26, 2006 5:33 pm "><author>kat</author><body><![CDATA[<div class="postbody">New error when doing Ctrl+P to run the script<div class="codetitle"><b>Code:</b></div><div class="codecontent">SyntaxError: invalid token<br />  File "goofosASE_import_26Ma", line 382<br />    pup_block = [\<br />                  ^</div></div>]]></body></post><post id="p144546" date="Posted: Wed May 31, 2006 3:07 pm "><author>Goofos</author><body><![CDATA[<div class="postbody">There was a space at end of the line if you copy/paste the script from the forum. I have put the array in one line, should work now.</div>]]></body></post><post id="p144572" date="Posted: Wed May 31, 2006 6:19 pm "><author>kat</author><body><![CDATA[<div class="postbody">DUDE!! sorted. Both vertex and UVW import work fine and dandy.</div>]]></body></post><post id="p153676" date="Posted: Tue Aug 15, 2006 12:07 pm "><author>Goofos</author><body><![CDATA[<div class="postbody">Fixed a problem with the matrices, dont know why this suddenly happened.
<br /><br />[edit]
<br />I quickly updated it again (to v0.12) <img src="https://web.archive.org/web/20081203142618im_/http://www.doom3world.org/phpbb2/images/smilies/icon_biggrin.gif" alt=":D" title="Very Happy" /> to use some improvements of 2.42 (which doesn't worked with 2.40). Now it should import (big) meshes much faster.</div>]]></body></post><post id="p154876" date="Posted: Fri Aug 25, 2006 2:29 am "><author>Tweaker</author><body><![CDATA[<div class="postbody">Excellent, I was having problems importing with 2.42a, but this seems to have fixed it.  Thanks.   <img src="https://web.archive.org/web/20081203142618im_/http://www.doom3world.org/phpbb2/images/smilies/icon_biggrin.gif" alt=":D" title="Very Happy" /></div>]]></body></post><post id="p175749" date="Posted: Wed Apr 11, 2007 7:52 pm "><author>kat</author><body><![CDATA[<div class="postbody">Goofos, can you double check the script to make sure it works in 2.42/2.43 et-al.. I'm getting reports of the script working for some but not for others, I've not recently checked the script post 2.41.</div>]]></body></post><post id="p175836" date="Posted: Fri Apr 13, 2007 11:35 am "><author>Goofos</author><body><![CDATA[<div class="postbody">So far it works with 2.43, at least with ase files exported with 3ds or blender. The only problems i found are if the file has key animations or if you set the faces to smooth it looks a bit wrong but the smooth problem is fixed when you enter edit mode.</div>]]></body></post><post id="p175842" date="Posted: Fri Apr 13, 2007 1:03 pm "><author>kat</author><body><![CDATA[<div class="postbody">Thanks for double checking  <img src="https://web.archive.org/web/20081203142618im_/http://www.doom3world.org/phpbb2/images/smilies/icon_wink.gif" alt=":wink:" title="Wink" /></div>]]></body></post><post id="p179416" date="Posted: Thu May 31, 2007 2:27 pm "><author>Trakerz</author><body><![CDATA[<div class="postbody">Hi Goofos
<br /><br />Since multiple mapping coordinates have been introduced in blender 2.43 is there any way you could update ASE importer so we can see the models in blender with 2 or more UV coordinates?
<br /><br />Also is there a fix for importing the smoothing of the faces?..i`m using blender 2.44</div>]]></body></post><post id="p179431" date="Posted: Thu May 31, 2007 5:31 pm "><author>Goofos</author><body><![CDATA[<div class="postbody">On the way for the next version, which should be ready within one or two weeks.</div>]]></body></post><post id="p180702" date="Posted: Tue Jun 12, 2007 8:13 am "><author>Trakerz</author><body><![CDATA[<div class="postbody">That sounds great..i have searched all the importers for blender and none of them support multiple uv`s
<br /><br />Can`t wait for the new ASE importer  <img src="https://web.archive.org/web/20081203142618im_/http://www.doom3world.org/phpbb2/images/smilies/icon_cool.gif" alt="8)" title="Cool" /></div>]]></body></post><post id="p181219" date="Posted: Sun Jun 17, 2007 7:06 pm "><author>Goofos</author><body><![CDATA[<div class="postbody">Updated the script (v0.13).
<br /><br />I think this version needs some testing and a bit cleanup but i think this can wait for Blender 2.44a.</div>]]></body></post><post id="p181303" date="Posted: Mon Jun 18, 2007 8:40 pm "><author>Trakerz</author><body><![CDATA[<div class="postbody">GREAT WORK Goofos!!!!!!
<br />I just tested an ASE file and works like a charm <img src="https://web.archive.org/web/20081203142618im_/http://www.doom3world.org/phpbb2/images/smilies/icon_wink.gif" alt=";)" title="Wink" /><br /><br /><br />BTW in the code there is a problem at line 485 : unexpected indent 
<br />i fixed mine by just fixing the right alingment to the 'if' statement <img src="https://web.archive.org/web/20081203142618im_/http://www.doom3world.org/phpbb2/images/smilies/icon_wink.gif" alt=";)" title="Wink" /><br /><br />Here is the file if you with to do a try:
<br /><br />The tank model is not mine...is a free low poly tank from turbo squid for testing purposes:
<br /><br />The archive contains
<br /><br />tank.3ds
<br />tank.ASE
<br />tank_diff.tga - diffuse texture that goes on UV 1
<br />tabk_AO.tga - ambient occlusion(lightmap) texture that goes on UV 2
<br /><br />the 3ds file is for the smoothing comparision
<br /><br />from what i have seen the smoothings are ok on the entire model...
<br /><br /><!-- m --><a class="postlink" href="https://web.archive.org/web/20081203142618/http://www.4shared.com/file/18162300/42ec9c5b/tank.html">http://www.4shared.com/file/18162300/42ec9c5b/tank.html</a><!-- m -->
<br /><br />FINALY!!! an importer with multi UV support!!!  <img src="https://web.archive.org/web/20081203142618im_/http://www.doom3world.org/phpbb2/images/smilies/icon_cool.gif" alt="8)" title="Cool" /></div>]]></body></post><post id="p181384" date="Posted: Tue Jun 19, 2007 5:33 pm "><author>Goofos</author><body><![CDATA[<div class="postbody">I have no idea how the ase Materials/Maps deal with multiple UV channels. There is no reference either to a specific UV channel in the maps or in the UV channels itself to a specific map. 
<br /><br />According to a <a href="https://web.archive.org/web/20081203142618/http://udn.epicgames.com/Two/VertexBlendingTutorial.html#Blending%20Materials%20with%20Two%20Different%20UV%20Channels" class="postlink">manual/tutorial of the UT2kx Engine</a> you have to create a new Material in the Unreal Editor if you want to use a second UV channel, therefore my guess is that the ase file format don't support Materials/Maps referencing multiple UV channels.</div>]]></body></post><post id="p184686" date="Posted: Sun Jul 29, 2007 10:31 pm "><author>hyp3rfocus</author><body><![CDATA[<div class="postbody">hi, i've had some problems with this script. i was getting the "python script error : check console" error message as soon as i selected this script. the output from the console said this...<br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">  File "&lt;string&gt;", line 485<br />    add_EDGESPLIT = True<br />                       ^<br />IndentationError: unindent does not match any outer indentation level</div>...so i opened the file and added a couple of spaces so that it matched the line above and that seemed to do the trick.<br /><br />apart from that little glitch it's a fantastic script. thanks for all your work.</div>]]></body></post><post id="p202659" date="Posted: Sat Jul 26, 2008 10:03 pm "><author>kissaki</author><body><![CDATA[<div class="postbody">with that fix from the previous post it also seems to work with recent Blender 2.46<br />(just a short note)<br />nice! thx <img src="https://web.archive.org/web/20081203141010im_/http://www.doom3world.org/phpbb2/images/smilies/icon_smile.gif" alt=":)" title="Smile" /></div>]]></body></post><post id="p140291" date="Posted: Mon Apr 17, 2006 2:00 am "><author>Goofos</author><body><![CDATA[<div class="postbody"><img src="https://web.archive.org/web/20081203142739im_/http://www.doom3world.org/phpbb2/images/smilies/icon_arrow.gif" alt=":arrow:" title="Arrow" /> Version: 0.13
<br /><br />Supports Mesh Objects with vertex colors, multiple UV, smoothgroups.
<br /><br />A little Note!: you should not try to import very big ase files (&gt;50 MB with 512 MB RAM). With much RAM you might can try this.
<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">#!BPY<br /><br />"""<br />Name: 'ASCII Scene (.ase) v0.13'<br />Blender: 244<br />Group: 'Import'<br />Tooltip: 'Import from ASCII Scene Export file format (.ase)'<br />""" <br />__author__ = "Goofos"<br />__version__ = "0.13"<br /><br /># goofos<br />#<br /># ***** BEGIN GPL LICENSE BLOCK *****<br />#<br /># This program is free software; you can redistribute it and/or<br /># modify it under the terms of the GNU General Public License<br /># as published by the Free Software Foundation; either version 2<br /># of the License, or (at your option) any later version.<br /># <br /># This program is distributed in the hope that it will be useful,<br /># but WITHOUT ANY WARRANTY; without even the implied warranty of<br /># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<br /># GNU General Public License for more details.<br /># <br /># You should have received a copy of the GNU General Public License<br /># along with this program; if not, write to the Free Software Foundation,<br /># Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.<br /># <br /># ***** END GPL LICENCE BLOCK *****<br /><br />import time, sys<br />import Blender<br />from Blender import Scene, Object, Mesh<br /><br />'''<br />Some Options<br />'''<br /># Scale Factor (float)<br />OPT_SCALE = 0.1<br /># Add EdgeSplit Modifier when importing sharp edges (bool)<br />OPT_MOD_EDGESPLIT = True<br /># Enable the fileselector (bool)<br />OPT_FILESELECTOR = True<br /># If the fileselector is disabled, specify a static filename (string)<br />OPT_STATIC_FILENAME = 'E:\ASE Files\garage.ASE'<br /># Enable Progressbar (bool)<br />OPT_PROGRESSBAR = False<br /># File buffer. After testing with big files i think there is no real difference.<br /># -1 = system default, 0 = unbuffered, 1 = line buffered, &gt;1 = buffer size<br />OPT_FILE_BUFFER = -1<br /><br />'''<br />Import Options<br />'''<br /># Import Meshes scaled, defined by the scale factor of OPT_SCALE (bool)<br /># Note: Object location data looses some precision, .. i think!<br />IMP_SCALED = True<br /># Import Vertex Colors (bool)<br />IMP_VCOLOR = True<br /># Import UV Coords and UV layers (bool)<br />IMP_UV = True<br /># Import NGons as Blender FGons (bool)<br /># Note: Include quads, too.<br />IMP_FGONS = False<br /># Try to find possible quads and convert the two tris to a quad (bool)<br /># Note: Very slow!! ablsolutely doesn't work accurate :/<br /># i don't know wether this is a script problem or a blender problem!<br />IMP_QUADS = False<br /># Surround UV islands with seams (bool)<br />IMP_SEAMS = False<br /># Surround smooth groups with sharp edges (bool)<br />IMP_SMOOTHGROUPS = True<br /># Try to find the lowest autosmooth angle in vertex normals (bool)<br /># Note: i dont know if this is correct :&gt;<br />IMP_AUTOSMOOTH = False<br /><br /><br /><br /><br /><br />class Ase_group:<br />   def __init__(self):<br />      self.name = 'Name'<br />      self.ase_type = 'GROUP'<br />      self.ase_helper = None<br />      self.ase_objects = []<br /><br />class Ase_object:<br /><br />   def __init__(self, ase_object_type, name=''):<br />      #if ase_object_type not in ['GEOM','HELPER','SHAPE','LIGHT','CAMERA']: return<br />      if ase_object_type not in ['geom','helper','shape','light','camera']: return<br />      self.name = name<br />      self.ase_type = ase_object_type #GEOM, HELPER, SHAPE, LIGHT, CAMERA<br />      self.row0 = None<br />      self.row1 = None<br />      self.row2 = None<br />      self.row3 = None<br />      self.parent = None<br /><br />      #new_ase_data = None<br />      if ase_object_type == 'geom':<br />         new_ase_data = Ase_mesh(self)<br />      self.ase_data = new_ase_data<br /><br />class Ase_mesh:<br />   def __init__(self, ase_obj=None):<br />      self.name = 'Name'<br />      self.num = {'VERTS':0,'FACES':0,'CVERTEX':0,'CVFACES':0}<br />      self.ase_verts = {}<br />      self.vertseq = []<br />      self.ase_edges = {}<br />      self.ase_faces = {}<br />      self.faceseq = []<br />      self.ase_uv_channels = {}<br />      self.active_uv = None<br />      self.ase_vertcolors = {}<br />      self.ase_cfaces = {}<br />      self.autosmooth = 0<br />      self.hasUV = 0<br />      self.hasVC = 0 <br /><br />   def sort_edgekeys(self,vi0,vi1,vi2):<br />      '''<br />      Returns sorted edge keys of the given triangle vert indicies.<br />      '''<br />      if vi0 &gt; vi1: ed_k0 = vi1,vi0<br />      else: ed_k0 = vi0,vi1<br />      if vi1 &gt; vi2: ed_k1 = vi2,vi1<br />      else: ed_k1 = vi1,vi2<br />      if vi0 &gt; vi2: ed_k2 = vi2,vi0<br />      else: ed_k2 = vi0,vi2<br />      return ed_k0,ed_k1,ed_k2<br /><br />   def append_vert(self, ase_vert_index, x, y, z):<br />      '''<br />      Create a new Vertex for this Mesh.<br />      '''<br />      ase_v = Ase_vert(ase_vert_index, x, y, z)<br />      self.ase_verts[ase_vert_index] = ase_v<br />      #self.vertseq.insert(ase_vert_index, (ase_v.co.x,ase_v.co.y,ase_v.co.z))<br />      self.vertseq.insert(ase_vert_index, ase_v.co)<br />      <br />   def append_face(self, index, vi0, vi1, vi2, AB=1, BC=1, CA=1, smooth_groups=[0], mat_indices=0):<br />      '''<br />      Uhm ... work in progress!<br />      '''<br />      # create a new Ase_face<br />      ase_f = Ase_face(index, vi0, vi1, vi2, smooth_groups, mat_indices)<br />      ed_keys = self.sort_edgekeys(vi0,vi1,vi2)<br />      #ed_keys = [vi0,vi1].sort(),[vi1,vi2].sort(),[vi0,vi2].sort()<br />      ase_f.edge_keys = ed_keys<br />      ase_f.vis_sum = AB+BC+CA<br />      if ase_f.vis_sum == 2:<br />         if not AB: ase_f.tri_edge = ed_keys[0]<br />         elif not BC: ase_f.tri_edge = ed_keys[1]<br />         elif not CA: ase_f.tri_edge = ed_keys[2]<br /><br />      # set visibility (fgon) and sharp for edges<br />      # and look if the two face users might form a quad<br />      # or create a new Ase_edge<br />      for k,vis in zip(ed_keys,[AB,BC,CA]):<br />         # Ase_edge already exist or create a new one<br />         if not self.ase_edges.has_key(k):<br />            ase_ed = Ase_edge(k)<br />            ase_ed.fusers.append(ase_f.index)<br />            ase_ed.visible = vis<br />            self.ase_edges[k] = ase_ed<br />            continue<br />         else:<br />            ase_ed = self.ase_edges[k]<br />            ase_ed.fusers.append(ase_f.index)<br />            if ase_f.vis_sum == 2 and not ase_ed.visible:<br />               ase_f.tri_edge = k<br /><br />         fusers = [i for i in ase_ed.fusers if i != ase_f.index]<br />         if not fusers: continue<br />         for i in fusers:<br />            ase_f2 = self.ase_faces[i]<br />            # if this edge is invisible and both tris only have<br />            # this invisible edge, than the two tris could form a quad<br />            # easy done with a sum of all vis variables of the edges<br />            if k == ase_f.tri_edge:<br />               if ase_f.tri_edge == ase_f2.tri_edge:<br />                  ase_f.quad_team = ase_f2.index<br />                  ase_f2.quad_team = ase_f.index<br /><br />            # look if this edge is sharp<br />            # if not both faces share at least one smoothgroup var<br />            # than this edge is sharp<br />            #if ase_ed.sharp: continue<br />            for sg in smooth_groups:<br />               if sg not in ase_f2.smooth_groups:<br />                  ase_ed.sharp = True<br /><br />      self.ase_faces[ase_f.index] = ase_f<br />      self.faceseq.insert(ase_f.index, (ase_f.v0, ase_f.v1, ase_f.v2))<br /><br />   def append_uv_channel(self, layer_index=1):<br />      ''' <br />      Create a new UV Layer and set it active.<br />      '''<br />      self.ase_uv_channels[layer_index] = Ase_uv_channel(layer_index)<br />      self.active_uv = self.ase_uv_channels[layer_index]<br /><br />   def append_tvert(self, ase_uv_index, u, v, w=0):<br />      '''<br />      Create a new UV Vector in the active! UV Channel.<br />      '''<br />      if not self.active_uv: return<br />      #self.active_uv.ase_tverts[ase_uv_index] = Ase_tvert(ase_uv_index,u,v,w)<br />      self.active_uv.ase_tverts[ase_uv_index] = (u,v)<br /><br />   def append_tface(self, ase_face_index, uvi0, uvi1, uvi2, opt_check_seams=False):<br />      '''<br />      Create a new Face UV with indicies to UV Vectors in the active UV Layer.<br />      Optional check for Seams and store into the UV Channel.<br />      '''<br />      if not self.active_uv: return<br />      self.active_uv.ase_tfaces[ase_face_index] = [uvi0, uvi1, uvi2]<br />      # look if this face has seams<br />      # might useless because it makes no sense to import seams for all UV layers<br />      # that's why those edge keys are separately written to each ase UV layer<br />      if opt_check_seams:<br />         edge_keys = self.ase_faces[ase_face_index].edge_keys<br />         for ed_key,uvs in zip(edge_keys,[[uvi0,uvi1],[uvi1,uvi2],[uvi0,uvi2]]):<br />            uvs.sort()<br />            ase_ed,active_uv = self.ase_edges[ed_key],self.active_uv<br />            if not active_uv.ase_tedges.has_key(ed_key):<br />               active_uv.ase_tedges[ed_key] = uvs<br />               continue<br />            elif active_uv.ase_tedges[ed_key] != uvs:<br />               active_uv.seams.append(ed_key)<br /><br />   def append_vertcol(self, ase_color_index, r, g, b):<br />      #new = Ase_vertcolor(ase_color_index, r, g, b)<br />      #self.ase_vertcolors[ase_color_index] = new<br />      self.ase_vertcolors[ase_color_index] = (r,g,b)<br />      <br />   def append_cface(self, ase_face_index, ci0, ci1, ci2):<br />      ase_f = self.ase_faces[ase_face_index]<br />      #f.c0, f.c1, f.c2 = ci0, ci1, ci2<br />      self.ase_cfaces[ase_face_index] = (ci0, ci1, ci2)<br /><br />   def append_normal(self, ase_face_index, x, y, z):<br />      self.ase_faces[ase_face_index].normal = Blender.Mathutils.Vector(x,y,z)<br /><br />   def append_vnormal(self, ase_face_index, ase_vert_index, x, y, z, opt_check_smooth=False):<br />      ase_f = self.ase_faces[ase_face_index]<br />      self.ase_verts[ase_vert_index].normals[ase_face_index] = Blender.Mathutils.Vector(x,y,z)<br />      if opt_check_smooth and ase_f.smooth_groups:<br />         ase_edges = [self.ase_edges[key] for key in ase_f.edge_keys]<br />         for ed_key,ase_ed in zip(ase_f.edge_keys,ase_edges):<br />            if ase_ed.sharp or len(ase_ed.fusers) &lt; 2: continue<br />            for vi in ed_key:<br />               if not self.ase_verts.has_key(vi): continue<br />               vnormals = self.ase_verts[vi].normals<br />               fi0, fi1 = ase_ed.fusers[0:2]<br />               if vnormals.has_key(fi0) and vnormals.has_key(fi1):<br />                  vnor0, vnor1 = vnormals[fi0],vnormals[fi1]<br />                  if vnor0 == vnor1:<br />                     continue<br />                  else:<br />                     angle = round(Blender.Mathutils.AngleBetweenVecs(vnor0, vnor1))<br />                     if not self.autosmooth: self.autosmooth = angle<br />                     elif angle and self.autosmooth &gt; angle:<br />                        print angle<br />                        self.autosmooth = angle<br /><br /><br />class Ase_vert:<br />   def __init__(self, index, x, y, z):<br />      self.index = index<br />      #self.co = Blender.Mathutils.Vector(x,y,z)<br />      self.co = (x,y,z)<br />      self.normals = {}<br /><br />class Ase_edge:<br />   def __init__(self, key):<br />      self.key = key<br />      self.fusers = []<br />      self.uvs = None<br />      self.visible = 1<br />      self.sharp = False<br /><br />class Ase_face:<br />   def __init__(self, ase_face_index, v0, v1, v2, smooth_groups=0, mat_indices=0):<br />      self.index = ase_face_index<br />      self.v0 = v0<br />      self.v1 = v1<br />      self.v2 = v2<br />      self.edge_keys = None<br />      self.c0 = None<br />      self.c1 = None<br />      self.c2 = None<br />      self.normal = None<br />      #self.vert_normals = {}<br />      self.mat_indices = mat_indices<br />      self.smooth_groups = smooth_groups # 0 = solid face<br />      self.vis_sum = 3<br />      self.quad_team = None<br />      self.tri_edge = None<br /><br />class Ase_uv_channel:<br />   def __init__(self, index=1):<br />      self.index = index<br />      self.num = {'TVERTEX':0,'TVFACES':0}<br />      self.uv_layer_name = 'UVTex#' + str(self.index)<br />      self.ase_tverts = {}<br />      self.ase_tfaces = {}<br />      self.ase_tedges = {}<br />      self.seams = []<br /><br />class Ase_tvert:<br />   def __init__(self,index, u, v, w=0):<br />      self.index = index<br />      #self.vec = Blender.Mathutils.Vector(u,v)<br />      self.vec = (u,v)<br /><br />class Ase_tface:<br />   def __init__(self, index, uvi0, uvi1, uvi2):<br />      self.index = index<br />      self.uv = {0:uvi0, 1:uvi1, 2:uvi2}<br /><br />class Ase_vertcolor:<br />   def __init__(self, index, r, g, b):<br />      self.index = 0 <br />      self.r = round(r*256)<br />      self.g = round(g*256)<br />      self.b = round(b*256)<br />      self.a = 255.0<br /><br /><br />def spawn(ase_objects):<br /><br />   PB_index = 0.0<br />   PB_num = float(len(ase_objects))<br /><br />   print 'Import Objects...'<br />   if OPT_PROGRESSBAR: Blender.Window.DrawProgressBar(0.0, "Importing Objects...")<br /><br />   scene = Blender.Scene.GetCurrent()<br />   for ase_ob in ase_objects: <br />      if OPT_PROGRESSBAR and not (PB_index % PB_num):<br />         Blender.Window.DrawProgressBar(PB_index / PB_num, "Importing Objects...")<br /><br />      if ase_ob.ase_type == 'geom':<br />         spawn_mesh(scene,ase_ob)<br /><br />      PB_index += 1.0<br /><br />def spawn_mesh(scene,ase_ob):<br /><br />   ase_me = ase_ob.ase_data<br />   #normal_flag = 1<br /><br />   row0 = ase_ob.row0<br />   row1 = ase_ob.row1<br />   row2 = ase_ob.row2<br />   row3 = ase_ob.row3<br /><br />   matrix = Blender.Mathutils.Matrix(row0, row1, row2, row3)<br />   matrix.resize4x4()<br /><br />   # create new Blender Object and link to scene<br />   ob = Blender.Object.New('Mesh', ase_ob.name)<br />   ob.setMatrix(matrix)<br />   scene.objects.link(ob)<br /><br />   # get Mesh data from Object<br />   me = ob.getData(0,1)<br />   me.vertexColors = me.faceUV = False<br /><br />   # create Verts and Faces<br />   # seems like extend() is limited to a length of 64000?<br />   # this is a problem when importing big meshes.<br />   div = divmod(ase_me.num['VERTEX'], 64000)<br />   if div[1]: div = div[0]+1<br />   else: div = div[0]<br />   start = 0<br />   for i in range(div):<br />      end = start+64000<br />      me.verts.extend(ase_me.vertseq[start:end])<br />      start = end<br />   div = divmod(ase_me.num['FACES'], 64000)<br />   face_index_list = []<br />   if div[1]: div = div[0]+1<br />   else: div = div[0]<br />   start = 0<br />   for i in range(div):<br />      end = start+64000<br />      me.faces.extend(ase_me.faceseq[start:end])<br />      start = end<br /><br />   # import Vertex Colors, Solid/Smooth to faces<br />   if IMP_VCOLOR:<br />      me.vertexColors = ase_me.hasVC<br />      ase_vcolors = ase_me.ase_vertcolors<br />   for i,ase_f in ase_me.ase_faces.iteritems():<br />      try:f = me.faces[i]<br />      except:<br />         # dont know what's the problem with this<br />         print 'array index out of range:', i<br />         continue<br />      if me.vertexColors:<br />         cface = ase_me.ase_cfaces[i]<br />         c0,c1,c2 = ase_vcolors[cface[0]],ase_vcolors[cface[1]],ase_vcolors[cface[2]]<br />         fc0,fc1,fc2 = f.col[:]<br />         fc0.r,fc0.g,fc0.b = int(c0[0]*255),int(c0[1]*255),int(c0[2]*255)<br />         fc1.r,fc1.g,fc1.b = int(c1[0]*255),int(c1[1]*255),int(c1[2]*255)<br />         fc2.r,fc2.g,fc2.b = int(c2[0]*255),int(c2[1]*255),int(c2[2]*255)<br />      if ase_f.smooth_groups:<br />         f.smooth = 1<br /><br />   # import UV layer's<br />   if IMP_UV and ase_me.hasUV:<br />      for uv_chan in ase_me.ase_uv_channels.itervalues():<br />         me.addUVLayer(uv_chan.uv_layer_name)<br />         me.activeUVLayer = uv_chan.uv_layer_name<br />         tverts = uv_chan.ase_tverts<br />         for fi,uvis in uv_chan.ase_tfaces.iteritems():<br />            try:f = me.faces[fi]<br />            except: continue<br />            uv1,uv2,uv3 = tverts[uvis[0]],tverts[uvis[1]],tverts[uvis[2]]<br />            f.uv = [Blender.Mathutils.Vector(uv1), Blender.Mathutils.Vector(uv2), Blender.Mathutils.Vector(uv3)]<br />      me.activeUVLayer = ase_me.ase_uv_channels[1].uv_layer_name<br /><br />   # EXPERIMENTAL!<br />   # convert tris to quads<br />   # this is currently the easiest way i found without destroying uvs or vcolors<br />   # but don't work like expected...:/<br />   if IMP_QUADS:<br />      #quad_teams = set([i for i,ase_f in ase_me.ase_faces.iteritems() if ase_f.quad_team != None])<br />      quad_teams = []<br />      for i,ase_f in ase_me.ase_faces.iteritems():<br />         if ase_f.quad_team != None:<br />            if ase_f.index &lt; ase_f.quad_team: qt = ase_f.index,ase_f.quad_team<br />            elif ase_f.index &gt; ase_f.quad_team: qt = ase_f.quad_team,ase_f.index<br />            if qt not in quad_teams:<br />               quad_teams.append(qt)<br /><br />      faces = me.faces<br />      # first deselect all faces<br />      for f in faces: f.sel = 0<br />      for t0,t1 in quad_teams:<br />         ase_f0 = ase_me.ase_faces[t0]<br />         ase_f1 = ase_me.ase_faces[t1]<br />         try: f0,f1 = me.faces[ase_f0.index], me.faces[ase_f1.index]<br />         except: continue<br />         f0.sel = 1<br />         f1.sel = 1<br />         me.triangleToQuad()<br />         for i in faces.selected():<br />            faces[i].sel = 0<br /><br />   # apply the matrix to mesh (and optional fit the ob and me to blender)<br />   if IMP_SCALED:<br />      # seems this isn't accurate because of precision of the location vector<br />      scale = Blender.Mathutils.ScaleMatrix(OPT_SCALE,4)<br />      inv_matrix = ob.getMatrix().copy().invert() * scale<br />      ob.setLocation(ob.getMatrix().translationPart() * scale)<br />   else:<br />      inv_matrix = ob.getMatrix().copy().invert()<br />   me.transform(inv_matrix, 1)<br />   me.calcNormals()<br /><br />   # apply sharp, seam and fgon flags to edges.<br />   add_EDGESPLIT = False<br />   if IMP_FGONS or IMP_SEAMS or IMP_SMOOTHGROUPS:<br />      SHARP = Mesh.EdgeFlags.SHARP<br />      SEAM = Mesh.EdgeFlags.SEAM<br />      FGON = Mesh.EdgeFlags.FGON<br />      seam_keys = []<br />      if ase_me.hasUV: seam_keys = ase_me.ase_uv_channels[1].seams<br />      for k,ase_ed in ase_me.ase_edges.iteritems():<br />         if ase_ed.sharp or not ase_ed.visible or k in seam_keys:<br />            edi = me.findEdges(k[0],k[1])<br />            if edi:<br />               ed = me.edges[edi]<br />               if ase_me.hasUV and k in seam_keys and IMP_SEAMS: ed.flag |= SEAM<br />               if not ase_ed.visible and IMP_FGONS: ed.flag |= FGON<br />               if ase_ed.sharp and IMP_SMOOTHGROUPS:<br />                    ed.flag |= SHARP<br />                  add_EDGESPLIT = True<br /><br /><br /><br />   # add EdgeSplit Modiefier when the mesh has sharp edges<br />   # autosmooth is EXPERIMENTAL! because i dont know if this is correct!<br />   if add_EDGESPLIT and OPT_MOD_EDGESPLIT:<br />      mod = ob.modifiers.append(Blender.Modifier.Types.EDGESPLIT)<br />      if not ase_me.autosmooth:<br />         mod[Blender.Modifier.Settings.EDGESPLIT_FROM_ANGLE] = 0<br />      else:<br />         mod[Blender.Modifier.Settings.EDGESPLIT_ANGLE] = ase_me.autosmooth<br />      mod[Blender.Modifier.Settings.EDGESPLIT_FROM_SHARP] = 1<br />      ob.makeDisplayList() # Needed to apply the modifier<br />   elif not add_EDGESPLIT and ase_me.autosmooth:<br />      AUTOSMOOTH = Mesh.Modes.AUTOSMOOTH<br />      me.modes |= AUTOSMOOTH<br />      me.degr = ase_me.autosmooth<br /><br />   me.update()<br />   counts['verts'] += ase_me.num['VERTEX']<br />   counts['tris'] += ase_me.num['FACES']<br />   counts['faces'] += len(me.faces)<br />   print 'Imported Mesh-Object: ', ob.name<br /><br />#def oj_the_object_jockey(file):<br />def read_file(file):<br />   '''<br />   Read an .ase file and return a list of ase_objects<br />   '''<br />   lines= file.readlines()<br /><br />   print 'Read file...'<br />   PB_index = 0.0<br />   PB_num = float(len(lines))<br />   if OPT_PROGRESSBAR: Blender.Window.DrawProgressBar(0.0, "Read File...")<br /><br />   # it is needed to read UV if Seams should be imported even when importing UV is disabled<br />   READ_UV = False<br />   if IMP_UV or IMP_SEAMS: READ_UV = True<br />   #if IMP_AUTOSMOOTH and not IMP_SMOOTHGROUPS: IMP_AUTOSMOOTH = False<br /><br />   ase_objects = []<br />   ase_ob = False<br />   for line in lines:<br />      if OPT_PROGRESSBAR and not (PB_index % 10000):<br />         Blender.Window.DrawProgressBar(PB_index / PB_num, "Read File...")<br />      PB_index += 1<br /><br />      words = line.split()<br />      if not words:<br />         continue<br />      word0 = words[0]<br />      if word0 == '*GEOMOBJECT':<br />         #if ase_ob: ase_objects.append(ase_ob)<br />         ase_ob_type = word0.lower()[1:-6] #get rid of '*' and 'OBJECT'<br />         ase_ob = Ase_object(ase_ob_type)<br />         ase_objects.append(ase_ob)<br />         continue<br />      elif word0 in ['*HELPEROBJECT','*SHAPEOBJECT','*LIGHTOBJECT','*CAMERAOBJECT','*GROUP']:<br />         # Not supported objects!<br />         # because these objects too use a TM_NODE,<br />         # ase_ob should be set back to False to prevent errors.<br />         ase_ob = False<br />         continue<br />      elif word0 == '*NODE_NAME' and ase_ob:<br />         name = words[1][1:-1] #get rid of '"'<br />         if ase_ob and ase_ob.name != '': ase_ob.ase_data.name = name<br />         elif ase_ob: ase_ob.name = name<br />         continue<br />      elif word0 == '*NODE_PARENT' and ase_ob:<br />         ase_ob.parent = words[1][1:-1] #get rid of '"'<br />         continue<br />      elif word0 == '*TM_ROW0' and ase_ob:<br />         ase_ob.row0 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*TM_ROW1' and ase_ob:<br />         ase_ob.row1 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*TM_ROW2' and ase_ob:<br />         ase_ob.row2 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*TM_ROW3' and ase_ob:<br />         ase_ob.row3 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*MESH':<br />         ase_me = ase_ob.ase_data<br />         continue<br />      elif word0 == '*MESH_NUMVERTEX':<br />         ase_me.num['VERTEX'] = int(words[1])<br />         continue<br />      elif word0 == '*MESH_NUMFACES':<br />         ase_me.num['FACES'] = int(words[1])<br />         continue<br />      elif word0 == '*MESH_VERTEX':<br />         #vert_index, x, y, z<br />         ase_me.append_vert(int(words[1]),float(words[2]),float(words[3]),float(words[4]))<br />         continue<br />      elif word0 == '*MESH_FACE':<br />         #ase_face_index, vi0, vi1, vi2, AB, BC, CA, smooth_groups, mat_indicies<br />         #smooth = mat = False<br />         ase_face_index = words[1]<br />         if ase_face_index.endswith(':'):<br />            ase_face_index = ase_face_index[:-1]<br /><br />         smooth_groups = mat_indices = []<br />         for i,w in enumerate(words):<br />            if w == '*MESH_SMOOTHING' and IMP_SMOOTHGROUPS:<br />               try:<br />                  if words[i+1] != '*MESH_MTLID':<br />                     smooth_groups = [int(i) for i in words[i+1].split(',')]<br />               except:<br />                  smooth_groups = 0<br />            elif w == '*MESH_MTLID' and IMP_SMOOTHGROUPS:<br />               try:<br />                  mat_indices = [int(i) for i in words[i+1].split(',')]<br />               except:<br />                  mat_indices = 0<br />         ase_me.append_face(int(ase_face_index),int(words[3]),int(words[5]),int(words[7]),int(words[9]),int(words[11]),int(words[13]),smooth_groups,mat_indices)<br />         continue<br />      elif READ_UV:<br />         if word0 == '*MESH_NUMTVERTEX':<br />            if not ase_me.ase_uv_channels: ase_me.append_uv_channel()<br />            ase_me.active_uv.num['TVERTEX'] = int(words[1])<br />            ase_me.hasUV = True<br />            continue<br />         elif word0 == '*MESH_MAPPINGCHANNEL':<br />            # uv_channel_index<br />            ase_me.append_uv_channel(int(words[1]))<br />            continue<br />         elif word0 == '*MESH_TVERT':<br />            #uv_index, u, v, w<br />            ase_me.append_tvert(int(words[1]),float(words[2]),float(words[3]),float(words[4]))<br />            continue<br />         elif word0 == '*MESH_NUMTVFACES':<br />            ase_me.active_uv.num['TVFACES'] = int(words[1])<br />            continue<br />         elif word0 == '*MESH_TFACE':<br />            #ase_face_index, uv0, uv1, uv2, opt_IMP_SEAMS<br />            ase_face_index = words[1]<br />            if ase_face_index.endswith(':'):<br />               ase_face_index = ase_face_index[:-1]<br />            ase_me.append_tface(int(ase_face_index),int(words[2]),int(words[3]),int(words[4]),IMP_SEAMS)<br />            continue<br />      elif IMP_VCOLOR:<br />         if word0 == '*MESH_NUMCVERTEX':<br />            ase_me.num['CVERTEX'] = int(words[1])<br />            if ase_me.num['CVERTEX']:<br />               ase_me.hasVC = True<br />            continue<br />         elif word0 == '*MESH_VERTCOL':<br />            #color_index, r, g, b<br />            ase_me.append_vertcol(int(words[1]),float(words[2]),float(words[3]),float(words[4]))<br />            continue<br />         elif word0 == '*MESH_NUMCVFACES':<br />            ase_me.num['CVFACES'] = words[1]<br />            continue<br />         elif word0 == '*MESH_CFACE':<br />            #ase_face_index, ci0, ci1, ci2<br />            ase_face_index = words[1]<br />            if ase_face_index.endswith(':'):<br />               ase_face_index = ase_face_index[:-1]<br />            ase_me.append_cface(int(ase_face_index),int(words[2]),int(words[3]),int(words[4]))<br />            continue<br />      #elif word0 == '*MESH_NORMALS':<br />      elif IMP_AUTOSMOOTH:<br />         if word0 == '*MESH_FACENORMAL':<br />            # ase_face_index, x, y, z<br />            ase_face_index = int(words[1])<br />            ase_me.append_normal(ase_face_index,float(words[2]),float(words[3]),float(words[4]))<br />            continue<br />         elif word0 == '*MESH_VERTEXNORMAL':<br />            # ase_face_index, ase_vert_index, x, y, z<br />            ase_me.append_vnormal(ase_face_index,int(words[1]),float(words[2]),float(words[3]),float(words[4]),IMP_AUTOSMOOTH)<br />            continue<br />      else:<br />         continue<br />   return ase_objects<br /><br />def print_boxed(text): #Copy/Paste from meshtools, only to remove the beep :)<br />   lines = text.splitlines()<br />   maxlinelen = max(map(len, lines))<br />   if sys.platform[:3] == "win":<br />      print chr(218)+chr(196) + chr(196)*maxlinelen + chr(196)+chr(191) <br />      for line in lines: <br />         print chr(179) + ' ' + line.ljust(maxlinelen) + ' ' + chr(179) <br />      print chr(192)+chr(196) + chr(196)*maxlinelen + chr(196)+chr(217) <br />   else: <br />      print '+-' + '-'*maxlinelen + '-+' <br />      for line in lines: print '| ' + line.ljust(maxlinelen) + ' |' <br />      print '+-' + '-'*maxlinelen + '-+' <br /><br />def read(filename):<br /><br />   global counts<br />   counts = {'verts':0,'tris':0,'faces':0}<br /><br />   start = time.clock()<br /><br />   print_boxed("----------ASCII Scene Import----------")<br />   print 'Import File: ', filename<br /><br />   mode = Blender.Window.EditMode()     # are we in edit mode?  If so ...<br />   if mode: Blender.Window.EditMode(0) # leave edit mode before getting the mesh<br /><br />   file = open(filename,'r', OPT_FILE_BUFFER)<br />   ase_objects = read_file(file)<br />   file.close()<br />   spawn(ase_objects)<br />   Blender.Redraw()<br />   if OPT_PROGRESSBAR: Blender.Window.DrawProgressBar(1.0, '')  # clear progressbar<br />   # Blender.Window.EditMode(mode)<br /><br />   end = time.clock()<br />   seconds = " in %.2f %s" % (end-start, "seconds") <br />   #totals = "Imported Verts: %i Faces: %i Tris: %i " % (counts['verts'],counts['tris'],counts['faces'])<br />   #print_boxed(totals)<br />   message = "Successfully imported " + Blender.sys.basename(filename) + seconds <br />   print_boxed(message)<br /><br /><br /><br /><br />def read_ui(filename): <br /><br />   global IMPORT_SC, IMPORT_VC, IMP_UV, IMPORT_GO, IMPORT_SE, IMPORT_SM<br />   global IMP_SCALED,IMP_SMOOTHGROUPS,IMP_VCOLOR,IMP_UV,IMP_FGONS,IMP_QUADS,IMP_SEAMS,IMP_SMOOTHGROUPS,IMP_AUTOSMOOTH<br /><br />   IMPORT_SC = Blender.Draw.Create(IMP_SCALED)<br />   IMPORT_VC = Blender.Draw.Create(IMP_VCOLOR)<br />   IMP_UV = Blender.Draw.Create(IMP_UV)<br />   IMPORT_SE = Blender.Draw.Create(IMP_SEAMS)<br />   IMPORT_SM = Blender.Draw.Create(IMP_SMOOTHGROUPS)<br /><br />   # Get USER Options <br />   pup_block = [('Import Options'),('Scale Meshes', IMPORT_SC, 'Scale the Objects so that they better fit into Blender\'s grid size'),('Vertex Colors', IMPORT_VC, 'Import Vertex Colors if existing'),('UV (Layer)', IMP_UV, 'Import UV and UV layer\'s if existing'),('Smoothing', IMPORT_SM, 'Surround Smoothgroups with sharp edges'),('Seams', IMPORT_SE, 'Try to import Seams from UV islands (from the first UV layer!)')]<br /><br />   if not Blender.Draw.PupBlock('Import ASCII Scene...', pup_block):<br />      return<br /><br />   Blender.Window.WaitCursor(1)<br /><br />   IMP_SCALED = IMPORT_SC.val<br />   IMP_VCOLOR = IMPORT_VC.val<br />   IMP_UV = IMP_UV.val<br />   IMP_SEAMS = IMPORT_SE.val<br />   IMP_SMOOTHGROUPS = IMPORT_SM.val<br /><br />   read(filename)<br /><br />   Blender.Window.WaitCursor(0)<br />   Blender.Redraw()<br /><br /><br />if __name__ == '__main__' and OPT_FILESELECTOR:<br />   Blender.Window.FileSelector(read_ui, 'Import ASCII Scene', ('.ase'))<br />elif __name__ == '__main__':<br />   read_ui(OPT_STATIC_FILENAME)</div></div>]]></body></post><post id="p140320" date="Posted: Mon Apr 17, 2006 1:12 pm "><author>Bittoman</author><body><![CDATA[<div class="postbody">Nice job, thanks Goofos!</div>]]></body></post><post id="p140355" date="Posted: Mon Apr 17, 2006 10:30 pm "><author>kat</author><body><![CDATA[<div class="postbody">Not tried it yet but 'GG' on doing this one. Another step up the ladder for Blender!</div>]]></body></post><post id="p143616" date="Posted: Fri May 19, 2006 8:04 pm "><author>kat</author><body><![CDATA[<div class="postbody">Just tried this script for the 1st time and encountered the following error with Blender 2.41 when run as a script from the text window (Alt+P).
<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">IndentationError: unindent does not match any outer indentation level<br />  File "goofosASE_import_17Ap", line 295<br />    if obj.objType == 'Mesh':<br />                             ^</div></div>]]></body></post><post id="p143762" date="Posted: Sun May 21, 2006 3:58 pm "><author>Goofos</author><body><![CDATA[<div class="postbody">Should work now. Seems my OS is a bit more tollerant with format errors :&gt;</div>]]></body></post><post id="p144077" date="Posted: Fri May 26, 2006 10:43 am "><author>OrbWeaver</author><body><![CDATA[<div class="postbody">I haven't tried this but it sounds great. Until now ASE has been almost universally considered an "export-only" format.</div>]]></body></post><post id="p144120" date="Posted: Fri May 26, 2006 5:33 pm "><author>kat</author><body><![CDATA[<div class="postbody">New error when doing Ctrl+P to run the script<div class="codetitle"><b>Code:</b></div><div class="codecontent">SyntaxError: invalid token<br />  File "goofosASE_import_26Ma", line 382<br />    pup_block = [\<br />                  ^</div></div>]]></body></post><post id="p144546" date="Posted: Wed May 31, 2006 3:07 pm "><author>Goofos</author><body><![CDATA[<div class="postbody">There was a space at end of the line if you copy/paste the script from the forum. I have put the array in one line, should work now.</div>]]></body></post><post id="p144572" date="Posted: Wed May 31, 2006 6:19 pm "><author>kat</author><body><![CDATA[<div class="postbody">DUDE!! sorted. Both vertex and UVW import work fine and dandy.</div>]]></body></post><post id="p153676" date="Posted: Tue Aug 15, 2006 12:07 pm "><author>Goofos</author><body><![CDATA[<div class="postbody">Fixed a problem with the matrices, dont know why this suddenly happened.
<br /><br />[edit]
<br />I quickly updated it again (to v0.12) <img src="https://web.archive.org/web/20081203142739im_/http://www.doom3world.org/phpbb2/images/smilies/icon_biggrin.gif" alt=":D" title="Very Happy" /> to use some improvements of 2.42 (which doesn't worked with 2.40). Now it should import (big) meshes much faster.</div>]]></body></post><post id="p154876" date="Posted: Fri Aug 25, 2006 2:29 am "><author>Tweaker</author><body><![CDATA[<div class="postbody">Excellent, I was having problems importing with 2.42a, but this seems to have fixed it.  Thanks.   <img src="https://web.archive.org/web/20081203142739im_/http://www.doom3world.org/phpbb2/images/smilies/icon_biggrin.gif" alt=":D" title="Very Happy" /></div>]]></body></post><post id="p175749" date="Posted: Wed Apr 11, 2007 7:52 pm "><author>kat</author><body><![CDATA[<div class="postbody">Goofos, can you double check the script to make sure it works in 2.42/2.43 et-al.. I'm getting reports of the script working for some but not for others, I've not recently checked the script post 2.41.</div>]]></body></post><post id="p175836" date="Posted: Fri Apr 13, 2007 11:35 am "><author>Goofos</author><body><![CDATA[<div class="postbody">So far it works with 2.43, at least with ase files exported with 3ds or blender. The only problems i found are if the file has key animations or if you set the faces to smooth it looks a bit wrong but the smooth problem is fixed when you enter edit mode.</div>]]></body></post><post id="p175842" date="Posted: Fri Apr 13, 2007 1:03 pm "><author>kat</author><body><![CDATA[<div class="postbody">Thanks for double checking  <img src="https://web.archive.org/web/20081203142739im_/http://www.doom3world.org/phpbb2/images/smilies/icon_wink.gif" alt=":wink:" title="Wink" /></div>]]></body></post><post id="p179416" date="Posted: Thu May 31, 2007 2:27 pm "><author>Trakerz</author><body><![CDATA[<div class="postbody">Hi Goofos
<br /><br />Since multiple mapping coordinates have been introduced in blender 2.43 is there any way you could update ASE importer so we can see the models in blender with 2 or more UV coordinates?
<br /><br />Also is there a fix for importing the smoothing of the faces?..i`m using blender 2.44</div>]]></body></post><post id="p179431" date="Posted: Thu May 31, 2007 5:31 pm "><author>Goofos</author><body><![CDATA[<div class="postbody">On the way for the next version, which should be ready within one or two weeks.</div>]]></body></post><post id="p180702" date="Posted: Tue Jun 12, 2007 8:13 am "><author>Trakerz</author><body><![CDATA[<div class="postbody">That sounds great..i have searched all the importers for blender and none of them support multiple uv`s
<br /><br />Can`t wait for the new ASE importer  <img src="https://web.archive.org/web/20081203142739im_/http://www.doom3world.org/phpbb2/images/smilies/icon_cool.gif" alt="8)" title="Cool" /></div>]]></body></post><post id="p181219" date="Posted: Sun Jun 17, 2007 7:06 pm "><author>Goofos</author><body><![CDATA[<div class="postbody">Updated the script (v0.13).
<br /><br />I think this version needs some testing and a bit cleanup but i think this can wait for Blender 2.44a.</div>]]></body></post><post id="p181303" date="Posted: Mon Jun 18, 2007 8:40 pm "><author>Trakerz</author><body><![CDATA[<div class="postbody">GREAT WORK Goofos!!!!!!
<br />I just tested an ASE file and works like a charm <img src="https://web.archive.org/web/20081203142739im_/http://www.doom3world.org/phpbb2/images/smilies/icon_wink.gif" alt=";)" title="Wink" /><br /><br /><br />BTW in the code there is a problem at line 485 : unexpected indent 
<br />i fixed mine by just fixing the right alingment to the 'if' statement <img src="https://web.archive.org/web/20081203142739im_/http://www.doom3world.org/phpbb2/images/smilies/icon_wink.gif" alt=";)" title="Wink" /><br /><br />Here is the file if you with to do a try:
<br /><br />The tank model is not mine...is a free low poly tank from turbo squid for testing purposes:
<br /><br />The archive contains
<br /><br />tank.3ds
<br />tank.ASE
<br />tank_diff.tga - diffuse texture that goes on UV 1
<br />tabk_AO.tga - ambient occlusion(lightmap) texture that goes on UV 2
<br /><br />the 3ds file is for the smoothing comparision
<br /><br />from what i have seen the smoothings are ok on the entire model...
<br /><br /><!-- m --><a class="postlink" href="https://web.archive.org/web/20081203142739/http://www.4shared.com/file/18162300/42ec9c5b/tank.html">http://www.4shared.com/file/18162300/42ec9c5b/tank.html</a><!-- m -->
<br /><br />FINALY!!! an importer with multi UV support!!!  <img src="https://web.archive.org/web/20081203142739im_/http://www.doom3world.org/phpbb2/images/smilies/icon_cool.gif" alt="8)" title="Cool" /></div>]]></body></post><post id="p181384" date="Posted: Tue Jun 19, 2007 5:33 pm "><author>Goofos</author><body><![CDATA[<div class="postbody">I have no idea how the ase Materials/Maps deal with multiple UV channels. There is no reference either to a specific UV channel in the maps or in the UV channels itself to a specific map. 
<br /><br />According to a <a href="https://web.archive.org/web/20081203142739/http://udn.epicgames.com/Two/VertexBlendingTutorial.html#Blending%20Materials%20with%20Two%20Different%20UV%20Channels" class="postlink">manual/tutorial of the UT2kx Engine</a> you have to create a new Material in the Unreal Editor if you want to use a second UV channel, therefore my guess is that the ase file format don't support Materials/Maps referencing multiple UV channels.</div>]]></body></post><post id="p184686" date="Posted: Sun Jul 29, 2007 10:31 pm "><author>hyp3rfocus</author><body><![CDATA[<div class="postbody">hi, i've had some problems with this script. i was getting the "python script error : check console" error message as soon as i selected this script. the output from the console said this...<br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">  File "&lt;string&gt;", line 485<br />    add_EDGESPLIT = True<br />                       ^<br />IndentationError: unindent does not match any outer indentation level</div>...so i opened the file and added a couple of spaces so that it matched the line above and that seemed to do the trick.<br /><br />apart from that little glitch it's a fantastic script. thanks for all your work.</div>]]></body></post><post id="p202659" date="Posted: Sat Jul 26, 2008 10:03 pm "><author>kissaki</author><body><![CDATA[<div class="postbody">with that fix from the previous post it also seems to work with recent Blender 2.46<br />(just a short note)<br />nice! thx <img src="https://web.archive.org/web/20081203142322im_/http://www.doom3world.org/phpbb2/images/smilies/icon_smile.gif" alt=":)" title="Smile" /></div>]]></body></post><post id="p140291" date="Posted: Mon Apr 17, 2006 2:00 am "><author>Goofos</author><body><![CDATA[<div class="postbody"><img src="https://web.archive.org/web/20081203141031im_/http://www.doom3world.org/phpbb2/images/smilies/icon_arrow.gif" alt=":arrow:" title="Arrow" /> Version: 0.13
<br /><br />Supports Mesh Objects with vertex colors, multiple UV, smoothgroups.
<br /><br />A little Note!: you should not try to import very big ase files (&gt;50 MB with 512 MB RAM). With much RAM you might can try this.
<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">#!BPY<br /><br />"""<br />Name: 'ASCII Scene (.ase) v0.13'<br />Blender: 244<br />Group: 'Import'<br />Tooltip: 'Import from ASCII Scene Export file format (.ase)'<br />""" <br />__author__ = "Goofos"<br />__version__ = "0.13"<br /><br /># goofos<br />#<br /># ***** BEGIN GPL LICENSE BLOCK *****<br />#<br /># This program is free software; you can redistribute it and/or<br /># modify it under the terms of the GNU General Public License<br /># as published by the Free Software Foundation; either version 2<br /># of the License, or (at your option) any later version.<br /># <br /># This program is distributed in the hope that it will be useful,<br /># but WITHOUT ANY WARRANTY; without even the implied warranty of<br /># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<br /># GNU General Public License for more details.<br /># <br /># You should have received a copy of the GNU General Public License<br /># along with this program; if not, write to the Free Software Foundation,<br /># Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.<br /># <br /># ***** END GPL LICENCE BLOCK *****<br /><br />import time, sys<br />import Blender<br />from Blender import Scene, Object, Mesh<br /><br />'''<br />Some Options<br />'''<br /># Scale Factor (float)<br />OPT_SCALE = 0.1<br /># Add EdgeSplit Modifier when importing sharp edges (bool)<br />OPT_MOD_EDGESPLIT = True<br /># Enable the fileselector (bool)<br />OPT_FILESELECTOR = True<br /># If the fileselector is disabled, specify a static filename (string)<br />OPT_STATIC_FILENAME = 'E:\ASE Files\garage.ASE'<br /># Enable Progressbar (bool)<br />OPT_PROGRESSBAR = False<br /># File buffer. After testing with big files i think there is no real difference.<br /># -1 = system default, 0 = unbuffered, 1 = line buffered, &gt;1 = buffer size<br />OPT_FILE_BUFFER = -1<br /><br />'''<br />Import Options<br />'''<br /># Import Meshes scaled, defined by the scale factor of OPT_SCALE (bool)<br /># Note: Object location data looses some precision, .. i think!<br />IMP_SCALED = True<br /># Import Vertex Colors (bool)<br />IMP_VCOLOR = True<br /># Import UV Coords and UV layers (bool)<br />IMP_UV = True<br /># Import NGons as Blender FGons (bool)<br /># Note: Include quads, too.<br />IMP_FGONS = False<br /># Try to find possible quads and convert the two tris to a quad (bool)<br /># Note: Very slow!! ablsolutely doesn't work accurate :/<br /># i don't know wether this is a script problem or a blender problem!<br />IMP_QUADS = False<br /># Surround UV islands with seams (bool)<br />IMP_SEAMS = False<br /># Surround smooth groups with sharp edges (bool)<br />IMP_SMOOTHGROUPS = True<br /># Try to find the lowest autosmooth angle in vertex normals (bool)<br /># Note: i dont know if this is correct :&gt;<br />IMP_AUTOSMOOTH = False<br /><br /><br /><br /><br /><br />class Ase_group:<br />   def __init__(self):<br />      self.name = 'Name'<br />      self.ase_type = 'GROUP'<br />      self.ase_helper = None<br />      self.ase_objects = []<br /><br />class Ase_object:<br /><br />   def __init__(self, ase_object_type, name=''):<br />      #if ase_object_type not in ['GEOM','HELPER','SHAPE','LIGHT','CAMERA']: return<br />      if ase_object_type not in ['geom','helper','shape','light','camera']: return<br />      self.name = name<br />      self.ase_type = ase_object_type #GEOM, HELPER, SHAPE, LIGHT, CAMERA<br />      self.row0 = None<br />      self.row1 = None<br />      self.row2 = None<br />      self.row3 = None<br />      self.parent = None<br /><br />      #new_ase_data = None<br />      if ase_object_type == 'geom':<br />         new_ase_data = Ase_mesh(self)<br />      self.ase_data = new_ase_data<br /><br />class Ase_mesh:<br />   def __init__(self, ase_obj=None):<br />      self.name = 'Name'<br />      self.num = {'VERTS':0,'FACES':0,'CVERTEX':0,'CVFACES':0}<br />      self.ase_verts = {}<br />      self.vertseq = []<br />      self.ase_edges = {}<br />      self.ase_faces = {}<br />      self.faceseq = []<br />      self.ase_uv_channels = {}<br />      self.active_uv = None<br />      self.ase_vertcolors = {}<br />      self.ase_cfaces = {}<br />      self.autosmooth = 0<br />      self.hasUV = 0<br />      self.hasVC = 0 <br /><br />   def sort_edgekeys(self,vi0,vi1,vi2):<br />      '''<br />      Returns sorted edge keys of the given triangle vert indicies.<br />      '''<br />      if vi0 &gt; vi1: ed_k0 = vi1,vi0<br />      else: ed_k0 = vi0,vi1<br />      if vi1 &gt; vi2: ed_k1 = vi2,vi1<br />      else: ed_k1 = vi1,vi2<br />      if vi0 &gt; vi2: ed_k2 = vi2,vi0<br />      else: ed_k2 = vi0,vi2<br />      return ed_k0,ed_k1,ed_k2<br /><br />   def append_vert(self, ase_vert_index, x, y, z):<br />      '''<br />      Create a new Vertex for this Mesh.<br />      '''<br />      ase_v = Ase_vert(ase_vert_index, x, y, z)<br />      self.ase_verts[ase_vert_index] = ase_v<br />      #self.vertseq.insert(ase_vert_index, (ase_v.co.x,ase_v.co.y,ase_v.co.z))<br />      self.vertseq.insert(ase_vert_index, ase_v.co)<br />      <br />   def append_face(self, index, vi0, vi1, vi2, AB=1, BC=1, CA=1, smooth_groups=[0], mat_indices=0):<br />      '''<br />      Uhm ... work in progress!<br />      '''<br />      # create a new Ase_face<br />      ase_f = Ase_face(index, vi0, vi1, vi2, smooth_groups, mat_indices)<br />      ed_keys = self.sort_edgekeys(vi0,vi1,vi2)<br />      #ed_keys = [vi0,vi1].sort(),[vi1,vi2].sort(),[vi0,vi2].sort()<br />      ase_f.edge_keys = ed_keys<br />      ase_f.vis_sum = AB+BC+CA<br />      if ase_f.vis_sum == 2:<br />         if not AB: ase_f.tri_edge = ed_keys[0]<br />         elif not BC: ase_f.tri_edge = ed_keys[1]<br />         elif not CA: ase_f.tri_edge = ed_keys[2]<br /><br />      # set visibility (fgon) and sharp for edges<br />      # and look if the two face users might form a quad<br />      # or create a new Ase_edge<br />      for k,vis in zip(ed_keys,[AB,BC,CA]):<br />         # Ase_edge already exist or create a new one<br />         if not self.ase_edges.has_key(k):<br />            ase_ed = Ase_edge(k)<br />            ase_ed.fusers.append(ase_f.index)<br />            ase_ed.visible = vis<br />            self.ase_edges[k] = ase_ed<br />            continue<br />         else:<br />            ase_ed = self.ase_edges[k]<br />            ase_ed.fusers.append(ase_f.index)<br />            if ase_f.vis_sum == 2 and not ase_ed.visible:<br />               ase_f.tri_edge = k<br /><br />         fusers = [i for i in ase_ed.fusers if i != ase_f.index]<br />         if not fusers: continue<br />         for i in fusers:<br />            ase_f2 = self.ase_faces[i]<br />            # if this edge is invisible and both tris only have<br />            # this invisible edge, than the two tris could form a quad<br />            # easy done with a sum of all vis variables of the edges<br />            if k == ase_f.tri_edge:<br />               if ase_f.tri_edge == ase_f2.tri_edge:<br />                  ase_f.quad_team = ase_f2.index<br />                  ase_f2.quad_team = ase_f.index<br /><br />            # look if this edge is sharp<br />            # if not both faces share at least one smoothgroup var<br />            # than this edge is sharp<br />            #if ase_ed.sharp: continue<br />            for sg in smooth_groups:<br />               if sg not in ase_f2.smooth_groups:<br />                  ase_ed.sharp = True<br /><br />      self.ase_faces[ase_f.index] = ase_f<br />      self.faceseq.insert(ase_f.index, (ase_f.v0, ase_f.v1, ase_f.v2))<br /><br />   def append_uv_channel(self, layer_index=1):<br />      ''' <br />      Create a new UV Layer and set it active.<br />      '''<br />      self.ase_uv_channels[layer_index] = Ase_uv_channel(layer_index)<br />      self.active_uv = self.ase_uv_channels[layer_index]<br /><br />   def append_tvert(self, ase_uv_index, u, v, w=0):<br />      '''<br />      Create a new UV Vector in the active! UV Channel.<br />      '''<br />      if not self.active_uv: return<br />      #self.active_uv.ase_tverts[ase_uv_index] = Ase_tvert(ase_uv_index,u,v,w)<br />      self.active_uv.ase_tverts[ase_uv_index] = (u,v)<br /><br />   def append_tface(self, ase_face_index, uvi0, uvi1, uvi2, opt_check_seams=False):<br />      '''<br />      Create a new Face UV with indicies to UV Vectors in the active UV Layer.<br />      Optional check for Seams and store into the UV Channel.<br />      '''<br />      if not self.active_uv: return<br />      self.active_uv.ase_tfaces[ase_face_index] = [uvi0, uvi1, uvi2]<br />      # look if this face has seams<br />      # might useless because it makes no sense to import seams for all UV layers<br />      # that's why those edge keys are separately written to each ase UV layer<br />      if opt_check_seams:<br />         edge_keys = self.ase_faces[ase_face_index].edge_keys<br />         for ed_key,uvs in zip(edge_keys,[[uvi0,uvi1],[uvi1,uvi2],[uvi0,uvi2]]):<br />            uvs.sort()<br />            ase_ed,active_uv = self.ase_edges[ed_key],self.active_uv<br />            if not active_uv.ase_tedges.has_key(ed_key):<br />               active_uv.ase_tedges[ed_key] = uvs<br />               continue<br />            elif active_uv.ase_tedges[ed_key] != uvs:<br />               active_uv.seams.append(ed_key)<br /><br />   def append_vertcol(self, ase_color_index, r, g, b):<br />      #new = Ase_vertcolor(ase_color_index, r, g, b)<br />      #self.ase_vertcolors[ase_color_index] = new<br />      self.ase_vertcolors[ase_color_index] = (r,g,b)<br />      <br />   def append_cface(self, ase_face_index, ci0, ci1, ci2):<br />      ase_f = self.ase_faces[ase_face_index]<br />      #f.c0, f.c1, f.c2 = ci0, ci1, ci2<br />      self.ase_cfaces[ase_face_index] = (ci0, ci1, ci2)<br /><br />   def append_normal(self, ase_face_index, x, y, z):<br />      self.ase_faces[ase_face_index].normal = Blender.Mathutils.Vector(x,y,z)<br /><br />   def append_vnormal(self, ase_face_index, ase_vert_index, x, y, z, opt_check_smooth=False):<br />      ase_f = self.ase_faces[ase_face_index]<br />      self.ase_verts[ase_vert_index].normals[ase_face_index] = Blender.Mathutils.Vector(x,y,z)<br />      if opt_check_smooth and ase_f.smooth_groups:<br />         ase_edges = [self.ase_edges[key] for key in ase_f.edge_keys]<br />         for ed_key,ase_ed in zip(ase_f.edge_keys,ase_edges):<br />            if ase_ed.sharp or len(ase_ed.fusers) &lt; 2: continue<br />            for vi in ed_key:<br />               if not self.ase_verts.has_key(vi): continue<br />               vnormals = self.ase_verts[vi].normals<br />               fi0, fi1 = ase_ed.fusers[0:2]<br />               if vnormals.has_key(fi0) and vnormals.has_key(fi1):<br />                  vnor0, vnor1 = vnormals[fi0],vnormals[fi1]<br />                  if vnor0 == vnor1:<br />                     continue<br />                  else:<br />                     angle = round(Blender.Mathutils.AngleBetweenVecs(vnor0, vnor1))<br />                     if not self.autosmooth: self.autosmooth = angle<br />                     elif angle and self.autosmooth &gt; angle:<br />                        print angle<br />                        self.autosmooth = angle<br /><br /><br />class Ase_vert:<br />   def __init__(self, index, x, y, z):<br />      self.index = index<br />      #self.co = Blender.Mathutils.Vector(x,y,z)<br />      self.co = (x,y,z)<br />      self.normals = {}<br /><br />class Ase_edge:<br />   def __init__(self, key):<br />      self.key = key<br />      self.fusers = []<br />      self.uvs = None<br />      self.visible = 1<br />      self.sharp = False<br /><br />class Ase_face:<br />   def __init__(self, ase_face_index, v0, v1, v2, smooth_groups=0, mat_indices=0):<br />      self.index = ase_face_index<br />      self.v0 = v0<br />      self.v1 = v1<br />      self.v2 = v2<br />      self.edge_keys = None<br />      self.c0 = None<br />      self.c1 = None<br />      self.c2 = None<br />      self.normal = None<br />      #self.vert_normals = {}<br />      self.mat_indices = mat_indices<br />      self.smooth_groups = smooth_groups # 0 = solid face<br />      self.vis_sum = 3<br />      self.quad_team = None<br />      self.tri_edge = None<br /><br />class Ase_uv_channel:<br />   def __init__(self, index=1):<br />      self.index = index<br />      self.num = {'TVERTEX':0,'TVFACES':0}<br />      self.uv_layer_name = 'UVTex#' + str(self.index)<br />      self.ase_tverts = {}<br />      self.ase_tfaces = {}<br />      self.ase_tedges = {}<br />      self.seams = []<br /><br />class Ase_tvert:<br />   def __init__(self,index, u, v, w=0):<br />      self.index = index<br />      #self.vec = Blender.Mathutils.Vector(u,v)<br />      self.vec = (u,v)<br /><br />class Ase_tface:<br />   def __init__(self, index, uvi0, uvi1, uvi2):<br />      self.index = index<br />      self.uv = {0:uvi0, 1:uvi1, 2:uvi2}<br /><br />class Ase_vertcolor:<br />   def __init__(self, index, r, g, b):<br />      self.index = 0 <br />      self.r = round(r*256)<br />      self.g = round(g*256)<br />      self.b = round(b*256)<br />      self.a = 255.0<br /><br /><br />def spawn(ase_objects):<br /><br />   PB_index = 0.0<br />   PB_num = float(len(ase_objects))<br /><br />   print 'Import Objects...'<br />   if OPT_PROGRESSBAR: Blender.Window.DrawProgressBar(0.0, "Importing Objects...")<br /><br />   scene = Blender.Scene.GetCurrent()<br />   for ase_ob in ase_objects: <br />      if OPT_PROGRESSBAR and not (PB_index % PB_num):<br />         Blender.Window.DrawProgressBar(PB_index / PB_num, "Importing Objects...")<br /><br />      if ase_ob.ase_type == 'geom':<br />         spawn_mesh(scene,ase_ob)<br /><br />      PB_index += 1.0<br /><br />def spawn_mesh(scene,ase_ob):<br /><br />   ase_me = ase_ob.ase_data<br />   #normal_flag = 1<br /><br />   row0 = ase_ob.row0<br />   row1 = ase_ob.row1<br />   row2 = ase_ob.row2<br />   row3 = ase_ob.row3<br /><br />   matrix = Blender.Mathutils.Matrix(row0, row1, row2, row3)<br />   matrix.resize4x4()<br /><br />   # create new Blender Object and link to scene<br />   ob = Blender.Object.New('Mesh', ase_ob.name)<br />   ob.setMatrix(matrix)<br />   scene.objects.link(ob)<br /><br />   # get Mesh data from Object<br />   me = ob.getData(0,1)<br />   me.vertexColors = me.faceUV = False<br /><br />   # create Verts and Faces<br />   # seems like extend() is limited to a length of 64000?<br />   # this is a problem when importing big meshes.<br />   div = divmod(ase_me.num['VERTEX'], 64000)<br />   if div[1]: div = div[0]+1<br />   else: div = div[0]<br />   start = 0<br />   for i in range(div):<br />      end = start+64000<br />      me.verts.extend(ase_me.vertseq[start:end])<br />      start = end<br />   div = divmod(ase_me.num['FACES'], 64000)<br />   face_index_list = []<br />   if div[1]: div = div[0]+1<br />   else: div = div[0]<br />   start = 0<br />   for i in range(div):<br />      end = start+64000<br />      me.faces.extend(ase_me.faceseq[start:end])<br />      start = end<br /><br />   # import Vertex Colors, Solid/Smooth to faces<br />   if IMP_VCOLOR:<br />      me.vertexColors = ase_me.hasVC<br />      ase_vcolors = ase_me.ase_vertcolors<br />   for i,ase_f in ase_me.ase_faces.iteritems():<br />      try:f = me.faces[i]<br />      except:<br />         # dont know what's the problem with this<br />         print 'array index out of range:', i<br />         continue<br />      if me.vertexColors:<br />         cface = ase_me.ase_cfaces[i]<br />         c0,c1,c2 = ase_vcolors[cface[0]],ase_vcolors[cface[1]],ase_vcolors[cface[2]]<br />         fc0,fc1,fc2 = f.col[:]<br />         fc0.r,fc0.g,fc0.b = int(c0[0]*255),int(c0[1]*255),int(c0[2]*255)<br />         fc1.r,fc1.g,fc1.b = int(c1[0]*255),int(c1[1]*255),int(c1[2]*255)<br />         fc2.r,fc2.g,fc2.b = int(c2[0]*255),int(c2[1]*255),int(c2[2]*255)<br />      if ase_f.smooth_groups:<br />         f.smooth = 1<br /><br />   # import UV layer's<br />   if IMP_UV and ase_me.hasUV:<br />      for uv_chan in ase_me.ase_uv_channels.itervalues():<br />         me.addUVLayer(uv_chan.uv_layer_name)<br />         me.activeUVLayer = uv_chan.uv_layer_name<br />         tverts = uv_chan.ase_tverts<br />         for fi,uvis in uv_chan.ase_tfaces.iteritems():<br />            try:f = me.faces[fi]<br />            except: continue<br />            uv1,uv2,uv3 = tverts[uvis[0]],tverts[uvis[1]],tverts[uvis[2]]<br />            f.uv = [Blender.Mathutils.Vector(uv1), Blender.Mathutils.Vector(uv2), Blender.Mathutils.Vector(uv3)]<br />      me.activeUVLayer = ase_me.ase_uv_channels[1].uv_layer_name<br /><br />   # EXPERIMENTAL!<br />   # convert tris to quads<br />   # this is currently the easiest way i found without destroying uvs or vcolors<br />   # but don't work like expected...:/<br />   if IMP_QUADS:<br />      #quad_teams = set([i for i,ase_f in ase_me.ase_faces.iteritems() if ase_f.quad_team != None])<br />      quad_teams = []<br />      for i,ase_f in ase_me.ase_faces.iteritems():<br />         if ase_f.quad_team != None:<br />            if ase_f.index &lt; ase_f.quad_team: qt = ase_f.index,ase_f.quad_team<br />            elif ase_f.index &gt; ase_f.quad_team: qt = ase_f.quad_team,ase_f.index<br />            if qt not in quad_teams:<br />               quad_teams.append(qt)<br /><br />      faces = me.faces<br />      # first deselect all faces<br />      for f in faces: f.sel = 0<br />      for t0,t1 in quad_teams:<br />         ase_f0 = ase_me.ase_faces[t0]<br />         ase_f1 = ase_me.ase_faces[t1]<br />         try: f0,f1 = me.faces[ase_f0.index], me.faces[ase_f1.index]<br />         except: continue<br />         f0.sel = 1<br />         f1.sel = 1<br />         me.triangleToQuad()<br />         for i in faces.selected():<br />            faces[i].sel = 0<br /><br />   # apply the matrix to mesh (and optional fit the ob and me to blender)<br />   if IMP_SCALED:<br />      # seems this isn't accurate because of precision of the location vector<br />      scale = Blender.Mathutils.ScaleMatrix(OPT_SCALE,4)<br />      inv_matrix = ob.getMatrix().copy().invert() * scale<br />      ob.setLocation(ob.getMatrix().translationPart() * scale)<br />   else:<br />      inv_matrix = ob.getMatrix().copy().invert()<br />   me.transform(inv_matrix, 1)<br />   me.calcNormals()<br /><br />   # apply sharp, seam and fgon flags to edges.<br />   add_EDGESPLIT = False<br />   if IMP_FGONS or IMP_SEAMS or IMP_SMOOTHGROUPS:<br />      SHARP = Mesh.EdgeFlags.SHARP<br />      SEAM = Mesh.EdgeFlags.SEAM<br />      FGON = Mesh.EdgeFlags.FGON<br />      seam_keys = []<br />      if ase_me.hasUV: seam_keys = ase_me.ase_uv_channels[1].seams<br />      for k,ase_ed in ase_me.ase_edges.iteritems():<br />         if ase_ed.sharp or not ase_ed.visible or k in seam_keys:<br />            edi = me.findEdges(k[0],k[1])<br />            if edi:<br />               ed = me.edges[edi]<br />               if ase_me.hasUV and k in seam_keys and IMP_SEAMS: ed.flag |= SEAM<br />               if not ase_ed.visible and IMP_FGONS: ed.flag |= FGON<br />               if ase_ed.sharp and IMP_SMOOTHGROUPS:<br />                    ed.flag |= SHARP<br />                  add_EDGESPLIT = True<br /><br /><br /><br />   # add EdgeSplit Modiefier when the mesh has sharp edges<br />   # autosmooth is EXPERIMENTAL! because i dont know if this is correct!<br />   if add_EDGESPLIT and OPT_MOD_EDGESPLIT:<br />      mod = ob.modifiers.append(Blender.Modifier.Types.EDGESPLIT)<br />      if not ase_me.autosmooth:<br />         mod[Blender.Modifier.Settings.EDGESPLIT_FROM_ANGLE] = 0<br />      else:<br />         mod[Blender.Modifier.Settings.EDGESPLIT_ANGLE] = ase_me.autosmooth<br />      mod[Blender.Modifier.Settings.EDGESPLIT_FROM_SHARP] = 1<br />      ob.makeDisplayList() # Needed to apply the modifier<br />   elif not add_EDGESPLIT and ase_me.autosmooth:<br />      AUTOSMOOTH = Mesh.Modes.AUTOSMOOTH<br />      me.modes |= AUTOSMOOTH<br />      me.degr = ase_me.autosmooth<br /><br />   me.update()<br />   counts['verts'] += ase_me.num['VERTEX']<br />   counts['tris'] += ase_me.num['FACES']<br />   counts['faces'] += len(me.faces)<br />   print 'Imported Mesh-Object: ', ob.name<br /><br />#def oj_the_object_jockey(file):<br />def read_file(file):<br />   '''<br />   Read an .ase file and return a list of ase_objects<br />   '''<br />   lines= file.readlines()<br /><br />   print 'Read file...'<br />   PB_index = 0.0<br />   PB_num = float(len(lines))<br />   if OPT_PROGRESSBAR: Blender.Window.DrawProgressBar(0.0, "Read File...")<br /><br />   # it is needed to read UV if Seams should be imported even when importing UV is disabled<br />   READ_UV = False<br />   if IMP_UV or IMP_SEAMS: READ_UV = True<br />   #if IMP_AUTOSMOOTH and not IMP_SMOOTHGROUPS: IMP_AUTOSMOOTH = False<br /><br />   ase_objects = []<br />   ase_ob = False<br />   for line in lines:<br />      if OPT_PROGRESSBAR and not (PB_index % 10000):<br />         Blender.Window.DrawProgressBar(PB_index / PB_num, "Read File...")<br />      PB_index += 1<br /><br />      words = line.split()<br />      if not words:<br />         continue<br />      word0 = words[0]<br />      if word0 == '*GEOMOBJECT':<br />         #if ase_ob: ase_objects.append(ase_ob)<br />         ase_ob_type = word0.lower()[1:-6] #get rid of '*' and 'OBJECT'<br />         ase_ob = Ase_object(ase_ob_type)<br />         ase_objects.append(ase_ob)<br />         continue<br />      elif word0 in ['*HELPEROBJECT','*SHAPEOBJECT','*LIGHTOBJECT','*CAMERAOBJECT','*GROUP']:<br />         # Not supported objects!<br />         # because these objects too use a TM_NODE,<br />         # ase_ob should be set back to False to prevent errors.<br />         ase_ob = False<br />         continue<br />      elif word0 == '*NODE_NAME' and ase_ob:<br />         name = words[1][1:-1] #get rid of '"'<br />         if ase_ob and ase_ob.name != '': ase_ob.ase_data.name = name<br />         elif ase_ob: ase_ob.name = name<br />         continue<br />      elif word0 == '*NODE_PARENT' and ase_ob:<br />         ase_ob.parent = words[1][1:-1] #get rid of '"'<br />         continue<br />      elif word0 == '*TM_ROW0' and ase_ob:<br />         ase_ob.row0 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*TM_ROW1' and ase_ob:<br />         ase_ob.row1 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*TM_ROW2' and ase_ob:<br />         ase_ob.row2 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*TM_ROW3' and ase_ob:<br />         ase_ob.row3 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*MESH':<br />         ase_me = ase_ob.ase_data<br />         continue<br />      elif word0 == '*MESH_NUMVERTEX':<br />         ase_me.num['VERTEX'] = int(words[1])<br />         continue<br />      elif word0 == '*MESH_NUMFACES':<br />         ase_me.num['FACES'] = int(words[1])<br />         continue<br />      elif word0 == '*MESH_VERTEX':<br />         #vert_index, x, y, z<br />         ase_me.append_vert(int(words[1]),float(words[2]),float(words[3]),float(words[4]))<br />         continue<br />      elif word0 == '*MESH_FACE':<br />         #ase_face_index, vi0, vi1, vi2, AB, BC, CA, smooth_groups, mat_indicies<br />         #smooth = mat = False<br />         ase_face_index = words[1]<br />         if ase_face_index.endswith(':'):<br />            ase_face_index = ase_face_index[:-1]<br /><br />         smooth_groups = mat_indices = []<br />         for i,w in enumerate(words):<br />            if w == '*MESH_SMOOTHING' and IMP_SMOOTHGROUPS:<br />               try:<br />                  if words[i+1] != '*MESH_MTLID':<br />                     smooth_groups = [int(i) for i in words[i+1].split(',')]<br />               except:<br />                  smooth_groups = 0<br />            elif w == '*MESH_MTLID' and IMP_SMOOTHGROUPS:<br />               try:<br />                  mat_indices = [int(i) for i in words[i+1].split(',')]<br />               except:<br />                  mat_indices = 0<br />         ase_me.append_face(int(ase_face_index),int(words[3]),int(words[5]),int(words[7]),int(words[9]),int(words[11]),int(words[13]),smooth_groups,mat_indices)<br />         continue<br />      elif READ_UV:<br />         if word0 == '*MESH_NUMTVERTEX':<br />            if not ase_me.ase_uv_channels: ase_me.append_uv_channel()<br />            ase_me.active_uv.num['TVERTEX'] = int(words[1])<br />            ase_me.hasUV = True<br />            continue<br />         elif word0 == '*MESH_MAPPINGCHANNEL':<br />            # uv_channel_index<br />            ase_me.append_uv_channel(int(words[1]))<br />            continue<br />         elif word0 == '*MESH_TVERT':<br />            #uv_index, u, v, w<br />            ase_me.append_tvert(int(words[1]),float(words[2]),float(words[3]),float(words[4]))<br />            continue<br />         elif word0 == '*MESH_NUMTVFACES':<br />            ase_me.active_uv.num['TVFACES'] = int(words[1])<br />            continue<br />         elif word0 == '*MESH_TFACE':<br />            #ase_face_index, uv0, uv1, uv2, opt_IMP_SEAMS<br />            ase_face_index = words[1]<br />            if ase_face_index.endswith(':'):<br />               ase_face_index = ase_face_index[:-1]<br />            ase_me.append_tface(int(ase_face_index),int(words[2]),int(words[3]),int(words[4]),IMP_SEAMS)<br />            continue<br />      elif IMP_VCOLOR:<br />         if word0 == '*MESH_NUMCVERTEX':<br />            ase_me.num['CVERTEX'] = int(words[1])<br />            if ase_me.num['CVERTEX']:<br />               ase_me.hasVC = True<br />            continue<br />         elif word0 == '*MESH_VERTCOL':<br />            #color_index, r, g, b<br />            ase_me.append_vertcol(int(words[1]),float(words[2]),float(words[3]),float(words[4]))<br />            continue<br />         elif word0 == '*MESH_NUMCVFACES':<br />            ase_me.num['CVFACES'] = words[1]<br />            continue<br />         elif word0 == '*MESH_CFACE':<br />            #ase_face_index, ci0, ci1, ci2<br />            ase_face_index = words[1]<br />            if ase_face_index.endswith(':'):<br />               ase_face_index = ase_face_index[:-1]<br />            ase_me.append_cface(int(ase_face_index),int(words[2]),int(words[3]),int(words[4]))<br />            continue<br />      #elif word0 == '*MESH_NORMALS':<br />      elif IMP_AUTOSMOOTH:<br />         if word0 == '*MESH_FACENORMAL':<br />            # ase_face_index, x, y, z<br />            ase_face_index = int(words[1])<br />            ase_me.append_normal(ase_face_index,float(words[2]),float(words[3]),float(words[4]))<br />            continue<br />         elif word0 == '*MESH_VERTEXNORMAL':<br />            # ase_face_index, ase_vert_index, x, y, z<br />            ase_me.append_vnormal(ase_face_index,int(words[1]),float(words[2]),float(words[3]),float(words[4]),IMP_AUTOSMOOTH)<br />            continue<br />      else:<br />         continue<br />   return ase_objects<br /><br />def print_boxed(text): #Copy/Paste from meshtools, only to remove the beep :)<br />   lines = text.splitlines()<br />   maxlinelen = max(map(len, lines))<br />   if sys.platform[:3] == "win":<br />      print chr(218)+chr(196) + chr(196)*maxlinelen + chr(196)+chr(191) <br />      for line in lines: <br />         print chr(179) + ' ' + line.ljust(maxlinelen) + ' ' + chr(179) <br />      print chr(192)+chr(196) + chr(196)*maxlinelen + chr(196)+chr(217) <br />   else: <br />      print '+-' + '-'*maxlinelen + '-+' <br />      for line in lines: print '| ' + line.ljust(maxlinelen) + ' |' <br />      print '+-' + '-'*maxlinelen + '-+' <br /><br />def read(filename):<br /><br />   global counts<br />   counts = {'verts':0,'tris':0,'faces':0}<br /><br />   start = time.clock()<br /><br />   print_boxed("----------ASCII Scene Import----------")<br />   print 'Import File: ', filename<br /><br />   mode = Blender.Window.EditMode()     # are we in edit mode?  If so ...<br />   if mode: Blender.Window.EditMode(0) # leave edit mode before getting the mesh<br /><br />   file = open(filename,'r', OPT_FILE_BUFFER)<br />   ase_objects = read_file(file)<br />   file.close()<br />   spawn(ase_objects)<br />   Blender.Redraw()<br />   if OPT_PROGRESSBAR: Blender.Window.DrawProgressBar(1.0, '')  # clear progressbar<br />   # Blender.Window.EditMode(mode)<br /><br />   end = time.clock()<br />   seconds = " in %.2f %s" % (end-start, "seconds") <br />   #totals = "Imported Verts: %i Faces: %i Tris: %i " % (counts['verts'],counts['tris'],counts['faces'])<br />   #print_boxed(totals)<br />   message = "Successfully imported " + Blender.sys.basename(filename) + seconds <br />   print_boxed(message)<br /><br /><br /><br /><br />def read_ui(filename): <br /><br />   global IMPORT_SC, IMPORT_VC, IMP_UV, IMPORT_GO, IMPORT_SE, IMPORT_SM<br />   global IMP_SCALED,IMP_SMOOTHGROUPS,IMP_VCOLOR,IMP_UV,IMP_FGONS,IMP_QUADS,IMP_SEAMS,IMP_SMOOTHGROUPS,IMP_AUTOSMOOTH<br /><br />   IMPORT_SC = Blender.Draw.Create(IMP_SCALED)<br />   IMPORT_VC = Blender.Draw.Create(IMP_VCOLOR)<br />   IMP_UV = Blender.Draw.Create(IMP_UV)<br />   IMPORT_SE = Blender.Draw.Create(IMP_SEAMS)<br />   IMPORT_SM = Blender.Draw.Create(IMP_SMOOTHGROUPS)<br /><br />   # Get USER Options <br />   pup_block = [('Import Options'),('Scale Meshes', IMPORT_SC, 'Scale the Objects so that they better fit into Blender\'s grid size'),('Vertex Colors', IMPORT_VC, 'Import Vertex Colors if existing'),('UV (Layer)', IMP_UV, 'Import UV and UV layer\'s if existing'),('Smoothing', IMPORT_SM, 'Surround Smoothgroups with sharp edges'),('Seams', IMPORT_SE, 'Try to import Seams from UV islands (from the first UV layer!)')]<br /><br />   if not Blender.Draw.PupBlock('Import ASCII Scene...', pup_block):<br />      return<br /><br />   Blender.Window.WaitCursor(1)<br /><br />   IMP_SCALED = IMPORT_SC.val<br />   IMP_VCOLOR = IMPORT_VC.val<br />   IMP_UV = IMP_UV.val<br />   IMP_SEAMS = IMPORT_SE.val<br />   IMP_SMOOTHGROUPS = IMPORT_SM.val<br /><br />   read(filename)<br /><br />   Blender.Window.WaitCursor(0)<br />   Blender.Redraw()<br /><br /><br />if __name__ == '__main__' and OPT_FILESELECTOR:<br />   Blender.Window.FileSelector(read_ui, 'Import ASCII Scene', ('.ase'))<br />elif __name__ == '__main__':<br />   read_ui(OPT_STATIC_FILENAME)</div></div>]]></body></post><post id="p140320" date="Posted: Mon Apr 17, 2006 1:12 pm "><author>Bittoman</author><body><![CDATA[<div class="postbody">Nice job, thanks Goofos!</div>]]></body></post><post id="p140355" date="Posted: Mon Apr 17, 2006 10:30 pm "><author>kat</author><body><![CDATA[<div class="postbody">Not tried it yet but 'GG' on doing this one. Another step up the ladder for Blender!</div>]]></body></post><post id="p143616" date="Posted: Fri May 19, 2006 8:04 pm "><author>kat</author><body><![CDATA[<div class="postbody">Just tried this script for the 1st time and encountered the following error with Blender 2.41 when run as a script from the text window (Alt+P).
<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">IndentationError: unindent does not match any outer indentation level<br />  File "goofosASE_import_17Ap", line 295<br />    if obj.objType == 'Mesh':<br />                             ^</div></div>]]></body></post><post id="p143762" date="Posted: Sun May 21, 2006 3:58 pm "><author>Goofos</author><body><![CDATA[<div class="postbody">Should work now. Seems my OS is a bit more tollerant with format errors :&gt;</div>]]></body></post><post id="p144077" date="Posted: Fri May 26, 2006 10:43 am "><author>OrbWeaver</author><body><![CDATA[<div class="postbody">I haven't tried this but it sounds great. Until now ASE has been almost universally considered an "export-only" format.</div>]]></body></post><post id="p144120" date="Posted: Fri May 26, 2006 5:33 pm "><author>kat</author><body><![CDATA[<div class="postbody">New error when doing Ctrl+P to run the script<div class="codetitle"><b>Code:</b></div><div class="codecontent">SyntaxError: invalid token<br />  File "goofosASE_import_26Ma", line 382<br />    pup_block = [\<br />                  ^</div></div>]]></body></post><post id="p144546" date="Posted: Wed May 31, 2006 3:07 pm "><author>Goofos</author><body><![CDATA[<div class="postbody">There was a space at end of the line if you copy/paste the script from the forum. I have put the array in one line, should work now.</div>]]></body></post><post id="p144572" date="Posted: Wed May 31, 2006 6:19 pm "><author>kat</author><body><![CDATA[<div class="postbody">DUDE!! sorted. Both vertex and UVW import work fine and dandy.</div>]]></body></post><post id="p153676" date="Posted: Tue Aug 15, 2006 12:07 pm "><author>Goofos</author><body><![CDATA[<div class="postbody">Fixed a problem with the matrices, dont know why this suddenly happened.
<br /><br />[edit]
<br />I quickly updated it again (to v0.12) <img src="https://web.archive.org/web/20081203141031im_/http://www.doom3world.org/phpbb2/images/smilies/icon_biggrin.gif" alt=":D" title="Very Happy" /> to use some improvements of 2.42 (which doesn't worked with 2.40). Now it should import (big) meshes much faster.</div>]]></body></post><post id="p154876" date="Posted: Fri Aug 25, 2006 2:29 am "><author>Tweaker</author><body><![CDATA[<div class="postbody">Excellent, I was having problems importing with 2.42a, but this seems to have fixed it.  Thanks.   <img src="https://web.archive.org/web/20081203141031im_/http://www.doom3world.org/phpbb2/images/smilies/icon_biggrin.gif" alt=":D" title="Very Happy" /></div>]]></body></post><post id="p175749" date="Posted: Wed Apr 11, 2007 7:52 pm "><author>kat</author><body><![CDATA[<div class="postbody">Goofos, can you double check the script to make sure it works in 2.42/2.43 et-al.. I'm getting reports of the script working for some but not for others, I've not recently checked the script post 2.41.</div>]]></body></post><post id="p175836" date="Posted: Fri Apr 13, 2007 11:35 am "><author>Goofos</author><body><![CDATA[<div class="postbody">So far it works with 2.43, at least with ase files exported with 3ds or blender. The only problems i found are if the file has key animations or if you set the faces to smooth it looks a bit wrong but the smooth problem is fixed when you enter edit mode.</div>]]></body></post><post id="p175842" date="Posted: Fri Apr 13, 2007 1:03 pm "><author>kat</author><body><![CDATA[<div class="postbody">Thanks for double checking  <img src="https://web.archive.org/web/20081203141031im_/http://www.doom3world.org/phpbb2/images/smilies/icon_wink.gif" alt=":wink:" title="Wink" /></div>]]></body></post><post id="p179416" date="Posted: Thu May 31, 2007 2:27 pm "><author>Trakerz</author><body><![CDATA[<div class="postbody">Hi Goofos
<br /><br />Since multiple mapping coordinates have been introduced in blender 2.43 is there any way you could update ASE importer so we can see the models in blender with 2 or more UV coordinates?
<br /><br />Also is there a fix for importing the smoothing of the faces?..i`m using blender 2.44</div>]]></body></post><post id="p179431" date="Posted: Thu May 31, 2007 5:31 pm "><author>Goofos</author><body><![CDATA[<div class="postbody">On the way for the next version, which should be ready within one or two weeks.</div>]]></body></post><post id="p180702" date="Posted: Tue Jun 12, 2007 8:13 am "><author>Trakerz</author><body><![CDATA[<div class="postbody">That sounds great..i have searched all the importers for blender and none of them support multiple uv`s
<br /><br />Can`t wait for the new ASE importer  <img src="https://web.archive.org/web/20081203141031im_/http://www.doom3world.org/phpbb2/images/smilies/icon_cool.gif" alt="8)" title="Cool" /></div>]]></body></post><post id="p181219" date="Posted: Sun Jun 17, 2007 7:06 pm "><author>Goofos</author><body><![CDATA[<div class="postbody">Updated the script (v0.13).
<br /><br />I think this version needs some testing and a bit cleanup but i think this can wait for Blender 2.44a.</div>]]></body></post><post id="p181303" date="Posted: Mon Jun 18, 2007 8:40 pm "><author>Trakerz</author><body><![CDATA[<div class="postbody">GREAT WORK Goofos!!!!!!
<br />I just tested an ASE file and works like a charm <img src="https://web.archive.org/web/20081203141031im_/http://www.doom3world.org/phpbb2/images/smilies/icon_wink.gif" alt=";)" title="Wink" /><br /><br /><br />BTW in the code there is a problem at line 485 : unexpected indent 
<br />i fixed mine by just fixing the right alingment to the 'if' statement <img src="https://web.archive.org/web/20081203141031im_/http://www.doom3world.org/phpbb2/images/smilies/icon_wink.gif" alt=";)" title="Wink" /><br /><br />Here is the file if you with to do a try:
<br /><br />The tank model is not mine...is a free low poly tank from turbo squid for testing purposes:
<br /><br />The archive contains
<br /><br />tank.3ds
<br />tank.ASE
<br />tank_diff.tga - diffuse texture that goes on UV 1
<br />tabk_AO.tga - ambient occlusion(lightmap) texture that goes on UV 2
<br /><br />the 3ds file is for the smoothing comparision
<br /><br />from what i have seen the smoothings are ok on the entire model...
<br /><br /><!-- m --><a class="postlink" href="https://web.archive.org/web/20081203141031/http://www.4shared.com/file/18162300/42ec9c5b/tank.html">http://www.4shared.com/file/18162300/42ec9c5b/tank.html</a><!-- m -->
<br /><br />FINALY!!! an importer with multi UV support!!!  <img src="https://web.archive.org/web/20081203141031im_/http://www.doom3world.org/phpbb2/images/smilies/icon_cool.gif" alt="8)" title="Cool" /></div>]]></body></post><post id="p181384" date="Posted: Tue Jun 19, 2007 5:33 pm "><author>Goofos</author><body><![CDATA[<div class="postbody">I have no idea how the ase Materials/Maps deal with multiple UV channels. There is no reference either to a specific UV channel in the maps or in the UV channels itself to a specific map. 
<br /><br />According to a <a href="https://web.archive.org/web/20081203141031/http://udn.epicgames.com/Two/VertexBlendingTutorial.html#Blending%20Materials%20with%20Two%20Different%20UV%20Channels" class="postlink">manual/tutorial of the UT2kx Engine</a> you have to create a new Material in the Unreal Editor if you want to use a second UV channel, therefore my guess is that the ase file format don't support Materials/Maps referencing multiple UV channels.</div>]]></body></post><post id="p140291" date="Posted: Mon Apr 17, 2006 2:00 am "><author>Goofos</author><body><![CDATA[<div class="postbody"><img src="https://web.archive.org/web/20070509181516im_/http://www.doom3world.org/phpbb2/images/smilies/icon_arrow.gif" alt=":arrow:" title="Arrow" /> Version: 0.13&#13;<br /><br />Supports Mesh Objects with vertex colors, multiple UV, smoothgroups.&#13;<br /><br />A little Note!: you should not try to import very big ase files (&gt;50 MB with 512 MB RAM). With much RAM you might can try this.&#13;<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">#!BPY<br /><br />"""<br />Name: 'ASCII Scene (.ase) v0.13'<br />Blender: 244<br />Group: 'Import'<br />Tooltip: 'Import from ASCII Scene Export file format (.ase)'<br />""" <br />__author__ = "Goofos"<br />__version__ = "0.13"<br /><br /># goofos<br />#<br /># ***** BEGIN GPL LICENSE BLOCK *****<br />#<br /># This program is free software; you can redistribute it and/or<br /># modify it under the terms of the GNU General Public License<br /># as published by the Free Software Foundation; either version 2<br /># of the License, or (at your option) any later version.<br /># <br /># This program is distributed in the hope that it will be useful,<br /># but WITHOUT ANY WARRANTY; without even the implied warranty of<br /># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<br /># GNU General Public License for more details.<br /># <br /># You should have received a copy of the GNU General Public License<br /># along with this program; if not, write to the Free Software Foundation,<br /># Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.<br /># <br /># ***** END GPL LICENCE BLOCK *****<br /><br />import time, sys<br />import Blender<br />from Blender import Scene, Object, Mesh<br /><br />'''<br />Some Options<br />'''<br /># Scale Factor (float)<br />OPT_SCALE = 0.1<br /># Add EdgeSplit Modifier when importing sharp edges (bool)<br />OPT_MOD_EDGESPLIT = True<br /># Enable the fileselector (bool)<br />OPT_FILESELECTOR = True<br /># If the fileselector is disabled, specify a static filename (string)<br />OPT_STATIC_FILENAME = 'E:\ASE Files\garage.ASE'<br /># Enable Progressbar (bool)<br />OPT_PROGRESSBAR = False<br /># File buffer. After testing with big files i think there is no real difference.<br /># -1 = system default, 0 = unbuffered, 1 = line buffered, &gt;1 = buffer size<br />OPT_FILE_BUFFER = -1<br /><br />'''<br />Import Options<br />'''<br /># Import Meshes scaled, defined by the scale factor of OPT_SCALE (bool)<br /># Note: Object location data looses some precision, .. i think!<br />IMP_SCALED = True<br /># Import Vertex Colors (bool)<br />IMP_VCOLOR = True<br /># Import UV Coords and UV layers (bool)<br />IMP_UV = True<br /># Import NGons as Blender FGons (bool)<br /># Note: Include quads, too.<br />IMP_FGONS = False<br /># Try to find possible quads and convert the two tris to a quad (bool)<br /># Note: Very slow!! ablsolutely doesn't work accurate :/<br /># i don't know wether this is a script problem or a blender problem!<br />IMP_QUADS = False<br /># Surround UV islands with seams (bool)<br />IMP_SEAMS = False<br /># Surround smooth groups with sharp edges (bool)<br />IMP_SMOOTHGROUPS = True<br /># Try to find the lowest autosmooth angle in vertex normals (bool)<br /># Note: i dont know if this is correct :&gt;<br />IMP_AUTOSMOOTH = False<br /><br /><br /><br /><br /><br />class Ase_group:<br />   def __init__(self):<br />      self.name = 'Name'<br />      self.ase_type = 'GROUP'<br />      self.ase_helper = None<br />      self.ase_objects = []<br /><br />class Ase_object:<br /><br />   def __init__(self, ase_object_type, name=''):<br />      #if ase_object_type not in ['GEOM','HELPER','SHAPE','LIGHT','CAMERA']: return<br />      if ase_object_type not in ['geom','helper','shape','light','camera']: return<br />      self.name = name<br />      self.ase_type = ase_object_type #GEOM, HELPER, SHAPE, LIGHT, CAMERA<br />      self.row0 = None<br />      self.row1 = None<br />      self.row2 = None<br />      self.row3 = None<br />      self.parent = None<br /><br />      #new_ase_data = None<br />      if ase_object_type == 'geom':<br />         new_ase_data = Ase_mesh(self)<br />      self.ase_data = new_ase_data<br /><br />class Ase_mesh:<br />   def __init__(self, ase_obj=None):<br />      self.name = 'Name'<br />      self.num = {'VERTS':0,'FACES':0,'CVERTEX':0,'CVFACES':0}<br />      self.ase_verts = {}<br />      self.vertseq = []<br />      self.ase_edges = {}<br />      self.ase_faces = {}<br />      self.faceseq = []<br />      self.ase_uv_channels = {}<br />      self.active_uv = None<br />      self.ase_vertcolors = {}<br />      self.ase_cfaces = {}<br />      self.autosmooth = 0<br />      self.hasUV = 0<br />      self.hasVC = 0 <br /><br />   def sort_edgekeys(self,vi0,vi1,vi2):<br />      '''<br />      Returns sorted edge keys of the given triangle vert indicies.<br />      '''<br />      if vi0 &gt; vi1: ed_k0 = vi1,vi0<br />      else: ed_k0 = vi0,vi1<br />      if vi1 &gt; vi2: ed_k1 = vi2,vi1<br />      else: ed_k1 = vi1,vi2<br />      if vi0 &gt; vi2: ed_k2 = vi2,vi0<br />      else: ed_k2 = vi0,vi2<br />      return ed_k0,ed_k1,ed_k2<br /><br />   def append_vert(self, ase_vert_index, x, y, z):<br />      '''<br />      Create a new Vertex for this Mesh.<br />      '''<br />      ase_v = Ase_vert(ase_vert_index, x, y, z)<br />      self.ase_verts[ase_vert_index] = ase_v<br />      #self.vertseq.insert(ase_vert_index, (ase_v.co.x,ase_v.co.y,ase_v.co.z))<br />      self.vertseq.insert(ase_vert_index, ase_v.co)<br />      <br />   def append_face(self, index, vi0, vi1, vi2, AB=1, BC=1, CA=1, smooth_groups=[0], mat_indices=0):<br />      '''<br />      Uhm ... work in progress!<br />      '''<br />      # create a new Ase_face<br />      ase_f = Ase_face(index, vi0, vi1, vi2, smooth_groups, mat_indices)<br />      ed_keys = self.sort_edgekeys(vi0,vi1,vi2)<br />      #ed_keys = [vi0,vi1].sort(),[vi1,vi2].sort(),[vi0,vi2].sort()<br />      ase_f.edge_keys = ed_keys<br />      ase_f.vis_sum = AB+BC+CA<br />      if ase_f.vis_sum == 2:<br />         if not AB: ase_f.tri_edge = ed_keys[0]<br />         elif not BC: ase_f.tri_edge = ed_keys[1]<br />         elif not CA: ase_f.tri_edge = ed_keys[2]<br /><br />      # set visibility (fgon) and sharp for edges<br />      # and look if the two face users might form a quad<br />      # or create a new Ase_edge<br />      for k,vis in zip(ed_keys,[AB,BC,CA]):<br />         # Ase_edge already exist or create a new one<br />         if not self.ase_edges.has_key(k):<br />            ase_ed = Ase_edge(k)<br />            ase_ed.fusers.append(ase_f.index)<br />            ase_ed.visible = vis<br />            self.ase_edges[k] = ase_ed<br />            continue<br />         else:<br />            ase_ed = self.ase_edges[k]<br />            ase_ed.fusers.append(ase_f.index)<br />            if ase_f.vis_sum == 2 and not ase_ed.visible:<br />               ase_f.tri_edge = k<br /><br />         fusers = [i for i in ase_ed.fusers if i != ase_f.index]<br />         if not fusers: continue<br />         for i in fusers:<br />            ase_f2 = self.ase_faces[i]<br />            # if this edge is invisible and both tris only have<br />            # this invisible edge, than the two tris could form a quad<br />            # easy done with a sum of all vis variables of the edges<br />            if k == ase_f.tri_edge:<br />               if ase_f.tri_edge == ase_f2.tri_edge:<br />                  ase_f.quad_team = ase_f2.index<br />                  ase_f2.quad_team = ase_f.index<br /><br />            # look if this edge is sharp<br />            # if not both faces share at least one smoothgroup var<br />            # than this edge is sharp<br />            #if ase_ed.sharp: continue<br />            for sg in smooth_groups:<br />               if sg not in ase_f2.smooth_groups:<br />                  ase_ed.sharp = True<br /><br />      self.ase_faces[ase_f.index] = ase_f<br />      self.faceseq.insert(ase_f.index, (ase_f.v0, ase_f.v1, ase_f.v2))<br /><br />   def append_uv_channel(self, layer_index=1):<br />      ''' <br />      Create a new UV Layer and set it active.<br />      '''<br />      self.ase_uv_channels[layer_index] = Ase_uv_channel(layer_index)<br />      self.active_uv = self.ase_uv_channels[layer_index]<br /><br />   def append_tvert(self, ase_uv_index, u, v, w=0):<br />      '''<br />      Create a new UV Vector in the active! UV Channel.<br />      '''<br />      if not self.active_uv: return<br />      #self.active_uv.ase_tverts[ase_uv_index] = Ase_tvert(ase_uv_index,u,v,w)<br />      self.active_uv.ase_tverts[ase_uv_index] = (u,v)<br /><br />   def append_tface(self, ase_face_index, uvi0, uvi1, uvi2, opt_check_seams=False):<br />      '''<br />      Create a new Face UV with indicies to UV Vectors in the active UV Layer.<br />      Optional check for Seams and store into the UV Channel.<br />      '''<br />      if not self.active_uv: return<br />      self.active_uv.ase_tfaces[ase_face_index] = [uvi0, uvi1, uvi2]<br />      # look if this face has seams<br />      # might useless because it makes no sense to import seams for all UV layers<br />      # that's why those edge keys are separately written to each ase UV layer<br />      if opt_check_seams:<br />         edge_keys = self.ase_faces[ase_face_index].edge_keys<br />         for ed_key,uvs in zip(edge_keys,[[uvi0,uvi1],[uvi1,uvi2],[uvi0,uvi2]]):<br />            uvs.sort()<br />            ase_ed,active_uv = self.ase_edges[ed_key],self.active_uv<br />            if not active_uv.ase_tedges.has_key(ed_key):<br />               active_uv.ase_tedges[ed_key] = uvs<br />               continue<br />            elif active_uv.ase_tedges[ed_key] != uvs:<br />               active_uv.seams.append(ed_key)<br /><br />   def append_vertcol(self, ase_color_index, r, g, b):<br />      #new = Ase_vertcolor(ase_color_index, r, g, b)<br />      #self.ase_vertcolors[ase_color_index] = new<br />      self.ase_vertcolors[ase_color_index] = (r,g,b)<br />      <br />   def append_cface(self, ase_face_index, ci0, ci1, ci2):<br />      ase_f = self.ase_faces[ase_face_index]<br />      #f.c0, f.c1, f.c2 = ci0, ci1, ci2<br />      self.ase_cfaces[ase_face_index] = (ci0, ci1, ci2)<br /><br />   def append_normal(self, ase_face_index, x, y, z):<br />      self.ase_faces[ase_face_index].normal = Blender.Mathutils.Vector(x,y,z)<br /><br />   def append_vnormal(self, ase_face_index, ase_vert_index, x, y, z, opt_check_smooth=False):<br />      ase_f = self.ase_faces[ase_face_index]<br />      self.ase_verts[ase_vert_index].normals[ase_face_index] = Blender.Mathutils.Vector(x,y,z)<br />      if opt_check_smooth and ase_f.smooth_groups:<br />         ase_edges = [self.ase_edges[key] for key in ase_f.edge_keys]<br />         for ed_key,ase_ed in zip(ase_f.edge_keys,ase_edges):<br />            if ase_ed.sharp or len(ase_ed.fusers) &lt; 2: continue<br />            for vi in ed_key:<br />               if not self.ase_verts.has_key(vi): continue<br />               vnormals = self.ase_verts[vi].normals<br />               fi0, fi1 = ase_ed.fusers[0:2]<br />               if vnormals.has_key(fi0) and vnormals.has_key(fi1):<br />                  vnor0, vnor1 = vnormals[fi0],vnormals[fi1]<br />                  if vnor0 == vnor1:<br />                     continue<br />                  else:<br />                     angle = round(Blender.Mathutils.AngleBetweenVecs(vnor0, vnor1))<br />                     if not self.autosmooth: self.autosmooth = angle<br />                     elif angle and self.autosmooth &gt; angle:<br />                        print angle<br />                        self.autosmooth = angle<br /><br /><br />class Ase_vert:<br />   def __init__(self, index, x, y, z):<br />      self.index = index<br />      #self.co = Blender.Mathutils.Vector(x,y,z)<br />      self.co = (x,y,z)<br />      self.normals = {}<br /><br />class Ase_edge:<br />   def __init__(self, key):<br />      self.key = key<br />      self.fusers = []<br />      self.uvs = None<br />      self.visible = 1<br />      self.sharp = False<br /><br />class Ase_face:<br />   def __init__(self, ase_face_index, v0, v1, v2, smooth_groups=0, mat_indices=0):<br />      self.index = ase_face_index<br />      self.v0 = v0<br />      self.v1 = v1<br />      self.v2 = v2<br />      self.edge_keys = None<br />      self.c0 = None<br />      self.c1 = None<br />      self.c2 = None<br />      self.normal = None<br />      #self.vert_normals = {}<br />      self.mat_indices = mat_indices<br />      self.smooth_groups = smooth_groups # 0 = solid face<br />      self.vis_sum = 3<br />      self.quad_team = None<br />      self.tri_edge = None<br /><br />class Ase_uv_channel:<br />   def __init__(self, index=1):<br />      self.index = index<br />      self.num = {'TVERTEX':0,'TVFACES':0}<br />      self.uv_layer_name = 'UVTex#' + str(self.index)<br />      self.ase_tverts = {}<br />      self.ase_tfaces = {}<br />      self.ase_tedges = {}<br />      self.seams = []<br /><br />class Ase_tvert:<br />   def __init__(self,index, u, v, w=0):<br />      self.index = index<br />      #self.vec = Blender.Mathutils.Vector(u,v)<br />      self.vec = (u,v)<br /><br />class Ase_tface:<br />   def __init__(self, index, uvi0, uvi1, uvi2):<br />      self.index = index<br />      self.uv = {0:uvi0, 1:uvi1, 2:uvi2}<br /><br />class Ase_vertcolor:<br />   def __init__(self, index, r, g, b):<br />      self.index = 0 <br />      self.r = round(r*256)<br />      self.g = round(g*256)<br />      self.b = round(b*256)<br />      self.a = 255.0<br /><br /><br />def spawn(ase_objects):<br /><br />   PB_index = 0.0<br />   PB_num = float(len(ase_objects))<br /><br />   print 'Import Objects...'<br />   if OPT_PROGRESSBAR: Blender.Window.DrawProgressBar(0.0, "Importing Objects...")<br /><br />   scene = Blender.Scene.GetCurrent()<br />   for ase_ob in ase_objects: <br />      if OPT_PROGRESSBAR and not (PB_index % PB_num):<br />         Blender.Window.DrawProgressBar(PB_index / PB_num, "Importing Objects...")<br /><br />      if ase_ob.ase_type == 'geom':<br />         spawn_mesh(scene,ase_ob)<br /><br />      PB_index += 1.0<br /><br />def spawn_mesh(scene,ase_ob):<br /><br />   ase_me = ase_ob.ase_data<br />   #normal_flag = 1<br /><br />   row0 = ase_ob.row0<br />   row1 = ase_ob.row1<br />   row2 = ase_ob.row2<br />   row3 = ase_ob.row3<br /><br />   matrix = Blender.Mathutils.Matrix(row0, row1, row2, row3)<br />   matrix.resize4x4()<br /><br />   # create new Blender Object and link to scene<br />   ob = Blender.Object.New('Mesh', ase_ob.name)<br />   ob.setMatrix(matrix)<br />   scene.objects.link(ob)<br /><br />   # get Mesh data from Object<br />   me = ob.getData(0,1)<br />   me.vertexColors = me.faceUV = False<br /><br />   # create Verts and Faces<br />   # seems like extend() is limited to a length of 64000?<br />   # this is a problem when importing big meshes.<br />   div = divmod(ase_me.num['VERTEX'], 64000)<br />   if div[1]: div = div[0]+1<br />   else: div = div[0]<br />   start = 0<br />   for i in range(div):<br />      end = start+64000<br />      me.verts.extend(ase_me.vertseq[start:end])<br />      start = end<br />   div = divmod(ase_me.num['FACES'], 64000)<br />   face_index_list = []<br />   if div[1]: div = div[0]+1<br />   else: div = div[0]<br />   start = 0<br />   for i in range(div):<br />      end = start+64000<br />      me.faces.extend(ase_me.faceseq[start:end])<br />      start = end<br /><br />   # import Vertex Colors, Solid/Smooth to faces<br />   if IMP_VCOLOR:<br />      me.vertexColors = ase_me.hasVC<br />      ase_vcolors = ase_me.ase_vertcolors<br />   for i,ase_f in ase_me.ase_faces.iteritems():<br />      try:f = me.faces[i]<br />      except:<br />         # dont know what's the problem with this<br />         print 'array index out of range:', i<br />         continue<br />      if me.vertexColors:<br />         cface = ase_me.ase_cfaces[i]<br />         c0,c1,c2 = ase_vcolors[cface[0]],ase_vcolors[cface[1]],ase_vcolors[cface[2]]<br />         fc0,fc1,fc2 = f.col[:]<br />         fc0.r,fc0.g,fc0.b = int(c0[0]*255),int(c0[1]*255),int(c0[2]*255)<br />         fc1.r,fc1.g,fc1.b = int(c1[0]*255),int(c1[1]*255),int(c1[2]*255)<br />         fc2.r,fc2.g,fc2.b = int(c2[0]*255),int(c2[1]*255),int(c2[2]*255)<br />      if ase_f.smooth_groups:<br />         f.smooth = 1<br /><br />   # import UV layer's<br />   if IMP_UV and ase_me.hasUV:<br />      for uv_chan in ase_me.ase_uv_channels.itervalues():<br />         me.addUVLayer(uv_chan.uv_layer_name)<br />         me.activeUVLayer = uv_chan.uv_layer_name<br />         tverts = uv_chan.ase_tverts<br />         for fi,uvis in uv_chan.ase_tfaces.iteritems():<br />            try:f = me.faces[fi]<br />            except: continue<br />            uv1,uv2,uv3 = tverts[uvis[0]],tverts[uvis[1]],tverts[uvis[2]]<br />            f.uv = [Blender.Mathutils.Vector(uv1), Blender.Mathutils.Vector(uv2), Blender.Mathutils.Vector(uv3)]<br />      me.activeUVLayer = ase_me.ase_uv_channels[1].uv_layer_name<br /><br />   # EXPERIMENTAL!<br />   # convert tris to quads<br />   # this is currently the easiest way i found without destroying uvs or vcolors<br />   # but don't work like expected...:/<br />   if IMP_QUADS:<br />      #quad_teams = set([i for i,ase_f in ase_me.ase_faces.iteritems() if ase_f.quad_team != None])<br />      quad_teams = []<br />      for i,ase_f in ase_me.ase_faces.iteritems():<br />         if ase_f.quad_team != None:<br />            if ase_f.index &lt; ase_f.quad_team: qt = ase_f.index,ase_f.quad_team<br />            elif ase_f.index &gt; ase_f.quad_team: qt = ase_f.quad_team,ase_f.index<br />            if qt not in quad_teams:<br />               quad_teams.append(qt)<br /><br />      faces = me.faces<br />      # first deselect all faces<br />      for f in faces: f.sel = 0<br />      for t0,t1 in quad_teams:<br />         ase_f0 = ase_me.ase_faces[t0]<br />         ase_f1 = ase_me.ase_faces[t1]<br />         try: f0,f1 = me.faces[ase_f0.index], me.faces[ase_f1.index]<br />         except: continue<br />         f0.sel = 1<br />         f1.sel = 1<br />         me.triangleToQuad()<br />         for i in faces.selected():<br />            faces[i].sel = 0<br /><br />   # apply the matrix to mesh (and optional fit the ob and me to blender)<br />   if IMP_SCALED:<br />      # seems this isn't accurate because of precision of the location vector<br />      scale = Blender.Mathutils.ScaleMatrix(OPT_SCALE,4)<br />      inv_matrix = ob.getMatrix().copy().invert() * scale<br />      ob.setLocation(ob.getMatrix().translationPart() * scale)<br />   else:<br />      inv_matrix = ob.getMatrix().copy().invert()<br />   me.transform(inv_matrix, 1)<br />   me.calcNormals()<br /><br />   # apply sharp, seam and fgon flags to edges.<br />   add_EDGESPLIT = False<br />   if IMP_FGONS or IMP_SEAMS or IMP_SMOOTHGROUPS:<br />      SHARP = Mesh.EdgeFlags.SHARP<br />      SEAM = Mesh.EdgeFlags.SEAM<br />      FGON = Mesh.EdgeFlags.FGON<br />      seam_keys = []<br />      if ase_me.hasUV: seam_keys = ase_me.ase_uv_channels[1].seams<br />      for k,ase_ed in ase_me.ase_edges.iteritems():<br />         if ase_ed.sharp or not ase_ed.visible or k in seam_keys:<br />            edi = me.findEdges(k[0],k[1])<br />            if edi:<br />               ed = me.edges[edi]<br />               if ase_me.hasUV and k in seam_keys and IMP_SEAMS: ed.flag |= SEAM<br />               if not ase_ed.visible and IMP_FGONS: ed.flag |= FGON<br />               if ase_ed.sharp and IMP_SMOOTHGROUPS:<br />                    ed.flag |= SHARP<br />                  add_EDGESPLIT = True<br /><br /><br /><br />   # add EdgeSplit Modiefier when the mesh has sharp edges<br />   # autosmooth is EXPERIMENTAL! because i dont know if this is correct!<br />   if add_EDGESPLIT and OPT_MOD_EDGESPLIT:<br />      mod = ob.modifiers.append(Blender.Modifier.Types.EDGESPLIT)<br />      if not ase_me.autosmooth:<br />         mod[Blender.Modifier.Settings.EDGESPLIT_FROM_ANGLE] = 0<br />      else:<br />         mod[Blender.Modifier.Settings.EDGESPLIT_ANGLE] = ase_me.autosmooth<br />      mod[Blender.Modifier.Settings.EDGESPLIT_FROM_SHARP] = 1<br />      ob.makeDisplayList() # Needed to apply the modifier<br />   elif not add_EDGESPLIT and ase_me.autosmooth:<br />      AUTOSMOOTH = Mesh.Modes.AUTOSMOOTH<br />      me.modes |= AUTOSMOOTH<br />      me.degr = ase_me.autosmooth<br /><br />   me.update()<br />   counts['verts'] += ase_me.num['VERTEX']<br />   counts['tris'] += ase_me.num['FACES']<br />   counts['faces'] += len(me.faces)<br />   print 'Imported Mesh-Object: ', ob.name<br /><br />#def oj_the_object_jockey(file):<br />def read_file(file):<br />   '''<br />   Read an .ase file and return a list of ase_objects<br />   '''<br />   lines= file.readlines()<br /><br />   print 'Read file...'<br />   PB_index = 0.0<br />   PB_num = float(len(lines))<br />   if OPT_PROGRESSBAR: Blender.Window.DrawProgressBar(0.0, "Read File...")<br /><br />   # it is needed to read UV if Seams should be imported even when importing UV is disabled<br />   READ_UV = False<br />   if IMP_UV or IMP_SEAMS: READ_UV = True<br />   #if IMP_AUTOSMOOTH and not IMP_SMOOTHGROUPS: IMP_AUTOSMOOTH = False<br /><br />   ase_objects = []<br />   ase_ob = False<br />   for line in lines:<br />      if OPT_PROGRESSBAR and not (PB_index % 10000):<br />         Blender.Window.DrawProgressBar(PB_index / PB_num, "Read File...")<br />      PB_index += 1<br /><br />      words = line.split()<br />      if not words:<br />         continue<br />      word0 = words[0]<br />      if word0 == '*GEOMOBJECT':<br />         #if ase_ob: ase_objects.append(ase_ob)<br />         ase_ob_type = word0.lower()[1:-6] #get rid of '*' and 'OBJECT'<br />         ase_ob = Ase_object(ase_ob_type)<br />         ase_objects.append(ase_ob)<br />         continue<br />      elif word0 in ['*HELPEROBJECT','*SHAPEOBJECT','*LIGHTOBJECT','*CAMERAOBJECT','*GROUP']:<br />         # Not supported objects!<br />         # because these objects too use a TM_NODE,<br />         # ase_ob should be set back to False to prevent errors.<br />         ase_ob = False<br />         continue<br />      elif word0 == '*NODE_NAME' and ase_ob:<br />         name = words[1][1:-1] #get rid of '"'<br />         if ase_ob and ase_ob.name != '': ase_ob.ase_data.name = name<br />         elif ase_ob: ase_ob.name = name<br />         continue<br />      elif word0 == '*NODE_PARENT' and ase_ob:<br />         ase_ob.parent = words[1][1:-1] #get rid of '"'<br />         continue<br />      elif word0 == '*TM_ROW0' and ase_ob:<br />         ase_ob.row0 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*TM_ROW1' and ase_ob:<br />         ase_ob.row1 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*TM_ROW2' and ase_ob:<br />         ase_ob.row2 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*TM_ROW3' and ase_ob:<br />         ase_ob.row3 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*MESH':<br />         ase_me = ase_ob.ase_data<br />         continue<br />      elif word0 == '*MESH_NUMVERTEX':<br />         ase_me.num['VERTEX'] = int(words[1])<br />         continue<br />      elif word0 == '*MESH_NUMFACES':<br />         ase_me.num['FACES'] = int(words[1])<br />         continue<br />      elif word0 == '*MESH_VERTEX':<br />         #vert_index, x, y, z<br />         ase_me.append_vert(int(words[1]),float(words[2]),float(words[3]),float(words[4]))<br />         continue<br />      elif word0 == '*MESH_FACE':<br />         #ase_face_index, vi0, vi1, vi2, AB, BC, CA, smooth_groups, mat_indicies<br />         #smooth = mat = False<br />         ase_face_index = words[1]<br />         if ase_face_index.endswith(':'):<br />            ase_face_index = ase_face_index[:-1]<br /><br />         smooth_groups = mat_indices = []<br />         for i,w in enumerate(words):<br />            if w == '*MESH_SMOOTHING' and IMP_SMOOTHGROUPS:<br />               try:<br />                  if words[i+1] != '*MESH_MTLID':<br />                     smooth_groups = [int(i) for i in words[i+1].split(',')]<br />               except:<br />                  smooth_groups = 0<br />            elif w == '*MESH_MTLID' and IMP_SMOOTHGROUPS:<br />               try:<br />                  mat_indices = [int(i) for i in words[i+1].split(',')]<br />               except:<br />                  mat_indices = 0<br />         ase_me.append_face(int(ase_face_index),int(words[3]),int(words[5]),int(words[7]),int(words[9]),int(words[11]),int(words[13]),smooth_groups,mat_indices)<br />         continue<br />      elif READ_UV:<br />         if word0 == '*MESH_NUMTVERTEX':<br />            if not ase_me.ase_uv_channels: ase_me.append_uv_channel()<br />            ase_me.active_uv.num['TVERTEX'] = int(words[1])<br />            ase_me.hasUV = True<br />            continue<br />         elif word0 == '*MESH_MAPPINGCHANNEL':<br />            # uv_channel_index<br />            ase_me.append_uv_channel(int(words[1]))<br />            continue<br />         elif word0 == '*MESH_TVERT':<br />            #uv_index, u, v, w<br />            ase_me.append_tvert(int(words[1]),float(words[2]),float(words[3]),float(words[4]))<br />            continue<br />         elif word0 == '*MESH_NUMTVFACES':<br />            ase_me.active_uv.num['TVFACES'] = int(words[1])<br />            continue<br />         elif word0 == '*MESH_TFACE':<br />            #ase_face_index, uv0, uv1, uv2, opt_IMP_SEAMS<br />            ase_face_index = words[1]<br />            if ase_face_index.endswith(':'):<br />               ase_face_index = ase_face_index[:-1]<br />            ase_me.append_tface(int(ase_face_index),int(words[2]),int(words[3]),int(words[4]),IMP_SEAMS)<br />            continue<br />      elif IMP_VCOLOR:<br />         if word0 == '*MESH_NUMCVERTEX':<br />            ase_me.num['CVERTEX'] = int(words[1])<br />            if ase_me.num['CVERTEX']:<br />               ase_me.hasVC = True<br />            continue<br />         elif word0 == '*MESH_VERTCOL':<br />            #color_index, r, g, b<br />            ase_me.append_vertcol(int(words[1]),float(words[2]),float(words[3]),float(words[4]))<br />            continue<br />         elif word0 == '*MESH_NUMCVFACES':<br />            ase_me.num['CVFACES'] = words[1]<br />            continue<br />         elif word0 == '*MESH_CFACE':<br />            #ase_face_index, ci0, ci1, ci2<br />            ase_face_index = words[1]<br />            if ase_face_index.endswith(':'):<br />               ase_face_index = ase_face_index[:-1]<br />            ase_me.append_cface(int(ase_face_index),int(words[2]),int(words[3]),int(words[4]))<br />            continue<br />      #elif word0 == '*MESH_NORMALS':<br />      elif IMP_AUTOSMOOTH:<br />         if word0 == '*MESH_FACENORMAL':<br />            # ase_face_index, x, y, z<br />            ase_face_index = int(words[1])<br />            ase_me.append_normal(ase_face_index,float(words[2]),float(words[3]),float(words[4]))<br />            continue<br />         elif word0 == '*MESH_VERTEXNORMAL':<br />            # ase_face_index, ase_vert_index, x, y, z<br />            ase_me.append_vnormal(ase_face_index,int(words[1]),float(words[2]),float(words[3]),float(words[4]),IMP_AUTOSMOOTH)<br />            continue<br />      else:<br />         continue<br />   return ase_objects<br /><br />def print_boxed(text): #Copy/Paste from meshtools, only to remove the beep :)<br />   lines = text.splitlines()<br />   maxlinelen = max(map(len, lines))<br />   if sys.platform[:3] == "win":<br />      print chr(218)+chr(196) + chr(196)*maxlinelen + chr(196)+chr(191) <br />      for line in lines: <br />         print chr(179) + ' ' + line.ljust(maxlinelen) + ' ' + chr(179) <br />      print chr(192)+chr(196) + chr(196)*maxlinelen + chr(196)+chr(217) <br />   else: <br />      print '+-' + '-'*maxlinelen + '-+' <br />      for line in lines: print '| ' + line.ljust(maxlinelen) + ' |' <br />      print '+-' + '-'*maxlinelen + '-+' <br /><br />def read(filename):<br /><br />   global counts<br />   counts = {'verts':0,'tris':0,'faces':0}<br /><br />   start = time.clock()<br /><br />   print_boxed("----------ASCII Scene Import----------")<br />   print 'Import File: ', filename<br /><br />   mode = Blender.Window.EditMode()     # are we in edit mode?  If so ...<br />   if mode: Blender.Window.EditMode(0) # leave edit mode before getting the mesh<br /><br />   file = open(filename,'r', OPT_FILE_BUFFER)<br />   ase_objects = read_file(file)<br />   file.close()<br />   spawn(ase_objects)<br />   Blender.Redraw()<br />   if OPT_PROGRESSBAR: Blender.Window.DrawProgressBar(1.0, '')  # clear progressbar<br />   # Blender.Window.EditMode(mode)<br /><br />   end = time.clock()<br />   seconds = " in %.2f %s" % (end-start, "seconds") <br />   #totals = "Imported Verts: %i Faces: %i Tris: %i " % (counts['verts'],counts['tris'],counts['faces'])<br />   #print_boxed(totals)<br />   message = "Successfully imported " + Blender.sys.basename(filename) + seconds <br />   print_boxed(message)<br /><br /><br /><br /><br />def read_ui(filename): <br /><br />   global IMPORT_SC, IMPORT_VC, IMP_UV, IMPORT_GO, IMPORT_SE, IMPORT_SM<br />   global IMP_SCALED,IMP_SMOOTHGROUPS,IMP_VCOLOR,IMP_UV,IMP_FGONS,IMP_QUADS,IMP_SEAMS,IMP_SMOOTHGROUPS,IMP_AUTOSMOOTH<br /><br />   IMPORT_SC = Blender.Draw.Create(IMP_SCALED)<br />   IMPORT_VC = Blender.Draw.Create(IMP_VCOLOR)<br />   IMP_UV = Blender.Draw.Create(IMP_UV)<br />   IMPORT_SE = Blender.Draw.Create(IMP_SEAMS)<br />   IMPORT_SM = Blender.Draw.Create(IMP_SMOOTHGROUPS)<br /><br />   # Get USER Options <br />   pup_block = [('Import Options'),('Scale Meshes', IMPORT_SC, 'Scale the Objects so that they better fit into Blender\'s grid size'),('Vertex Colors', IMPORT_VC, 'Import Vertex Colors if existing'),('UV (Layer)', IMP_UV, 'Import UV and UV layer\'s if existing'),('Smoothing', IMPORT_SM, 'Surround Smoothgroups with sharp edges'),('Seams', IMPORT_SE, 'Try to import Seams from UV islands (from the first UV layer!)')]<br /><br />   if not Blender.Draw.PupBlock('Import ASCII Scene...', pup_block):<br />      return<br /><br />   Blender.Window.WaitCursor(1)<br /><br />   IMP_SCALED = IMPORT_SC.val<br />   IMP_VCOLOR = IMPORT_VC.val<br />   IMP_UV = IMP_UV.val<br />   IMP_SEAMS = IMPORT_SE.val<br />   IMP_SMOOTHGROUPS = IMPORT_SM.val<br /><br />   read(filename)<br /><br />   Blender.Window.WaitCursor(0)<br />   Blender.Redraw()<br /><br /><br />if __name__ == '__main__' and OPT_FILESELECTOR:<br />   Blender.Window.FileSelector(read_ui, 'Import ASCII Scene', ('.ase'))<br />elif __name__ == '__main__':<br />   read_ui(OPT_STATIC_FILENAME)</div></div>]]></body></post><post id="p140320" date="Posted: Mon Apr 17, 2006 1:12 pm "><author>Bittoman</author><body><![CDATA[<div class="postbody">Nice job, thanks Goofos!</div>]]></body></post><post id="p140291" date="Posted: Mon Apr 17, 2006 2:00 am "><author>Goofos</author><body><![CDATA[<div class="postbody"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/images/smilies/icon_arrow.gif" alt=":arrow:" title="Arrow" /> Version: 0.13
<br /><br />Supports Mesh Objects with vertex colors, multiple UV, smoothgroups.
<br /><br />A little Note!: you should not try to import very big ase files (&gt;50 MB with 512 MB RAM). With much RAM you might can try this.
<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">#!BPY<br /><br />"""<br />Name: 'ASCII Scene (.ase) v0.13'<br />Blender: 244<br />Group: 'Import'<br />Tooltip: 'Import from ASCII Scene Export file format (.ase)'<br />""" <br />__author__ = "Goofos"<br />__version__ = "0.13"<br /><br /># goofos<br />#<br /># ***** BEGIN GPL LICENSE BLOCK *****<br />#<br /># This program is free software; you can redistribute it and/or<br /># modify it under the terms of the GNU General Public License<br /># as published by the Free Software Foundation; either version 2<br /># of the License, or (at your option) any later version.<br /># <br /># This program is distributed in the hope that it will be useful,<br /># but WITHOUT ANY WARRANTY; without even the implied warranty of<br /># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<br /># GNU General Public License for more details.<br /># <br /># You should have received a copy of the GNU General Public License<br /># along with this program; if not, write to the Free Software Foundation,<br /># Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.<br /># <br /># ***** END GPL LICENCE BLOCK *****<br /><br />import time, sys<br />import Blender<br />from Blender import Scene, Object, Mesh<br /><br />'''<br />Some Options<br />'''<br /># Scale Factor (float)<br />OPT_SCALE = 0.1<br /># Add EdgeSplit Modifier when importing sharp edges (bool)<br />OPT_MOD_EDGESPLIT = True<br /># Enable the fileselector (bool)<br />OPT_FILESELECTOR = True<br /># If the fileselector is disabled, specify a static filename (string)<br />OPT_STATIC_FILENAME = 'E:\ASE Files\garage.ASE'<br /># Enable Progressbar (bool)<br />OPT_PROGRESSBAR = False<br /># File buffer. After testing with big files i think there is no real difference.<br /># -1 = system default, 0 = unbuffered, 1 = line buffered, &gt;1 = buffer size<br />OPT_FILE_BUFFER = -1<br /><br />'''<br />Import Options<br />'''<br /># Import Meshes scaled, defined by the scale factor of OPT_SCALE (bool)<br /># Note: Object location data looses some precision, .. i think!<br />IMP_SCALED = True<br /># Import Vertex Colors (bool)<br />IMP_VCOLOR = True<br /># Import UV Coords and UV layers (bool)<br />IMP_UV = True<br /># Import NGons as Blender FGons (bool)<br /># Note: Include quads, too.<br />IMP_FGONS = False<br /># Try to find possible quads and convert the two tris to a quad (bool)<br /># Note: Very slow!! ablsolutely doesn't work accurate :/<br /># i don't know wether this is a script problem or a blender problem!<br />IMP_QUADS = False<br /># Surround UV islands with seams (bool)<br />IMP_SEAMS = False<br /># Surround smooth groups with sharp edges (bool)<br />IMP_SMOOTHGROUPS = True<br /># Try to find the lowest autosmooth angle in vertex normals (bool)<br /># Note: i dont know if this is correct :&gt;<br />IMP_AUTOSMOOTH = False<br /><br /><br /><br /><br /><br />class Ase_group:<br />   def __init__(self):<br />      self.name = 'Name'<br />      self.ase_type = 'GROUP'<br />      self.ase_helper = None<br />      self.ase_objects = []<br /><br />class Ase_object:<br /><br />   def __init__(self, ase_object_type, name=''):<br />      #if ase_object_type not in ['GEOM','HELPER','SHAPE','LIGHT','CAMERA']: return<br />      if ase_object_type not in ['geom','helper','shape','light','camera']: return<br />      self.name = name<br />      self.ase_type = ase_object_type #GEOM, HELPER, SHAPE, LIGHT, CAMERA<br />      self.row0 = None<br />      self.row1 = None<br />      self.row2 = None<br />      self.row3 = None<br />      self.parent = None<br /><br />      #new_ase_data = None<br />      if ase_object_type == 'geom':<br />         new_ase_data = Ase_mesh(self)<br />      self.ase_data = new_ase_data<br /><br />class Ase_mesh:<br />   def __init__(self, ase_obj=None):<br />      self.name = 'Name'<br />      self.num = {'VERTS':0,'FACES':0,'CVERTEX':0,'CVFACES':0}<br />      self.ase_verts = {}<br />      self.vertseq = []<br />      self.ase_edges = {}<br />      self.ase_faces = {}<br />      self.faceseq = []<br />      self.ase_uv_channels = {}<br />      self.active_uv = None<br />      self.ase_vertcolors = {}<br />      self.ase_cfaces = {}<br />      self.autosmooth = 0<br />      self.hasUV = 0<br />      self.hasVC = 0 <br /><br />   def sort_edgekeys(self,vi0,vi1,vi2):<br />      '''<br />      Returns sorted edge keys of the given triangle vert indicies.<br />      '''<br />      if vi0 &gt; vi1: ed_k0 = vi1,vi0<br />      else: ed_k0 = vi0,vi1<br />      if vi1 &gt; vi2: ed_k1 = vi2,vi1<br />      else: ed_k1 = vi1,vi2<br />      if vi0 &gt; vi2: ed_k2 = vi2,vi0<br />      else: ed_k2 = vi0,vi2<br />      return ed_k0,ed_k1,ed_k2<br /><br />   def append_vert(self, ase_vert_index, x, y, z):<br />      '''<br />      Create a new Vertex for this Mesh.<br />      '''<br />      ase_v = Ase_vert(ase_vert_index, x, y, z)<br />      self.ase_verts[ase_vert_index] = ase_v<br />      #self.vertseq.insert(ase_vert_index, (ase_v.co.x,ase_v.co.y,ase_v.co.z))<br />      self.vertseq.insert(ase_vert_index, ase_v.co)<br />      <br />   def append_face(self, index, vi0, vi1, vi2, AB=1, BC=1, CA=1, smooth_groups=[0], mat_indices=0):<br />      '''<br />      Uhm ... work in progress!<br />      '''<br />      # create a new Ase_face<br />      ase_f = Ase_face(index, vi0, vi1, vi2, smooth_groups, mat_indices)<br />      ed_keys = self.sort_edgekeys(vi0,vi1,vi2)<br />      #ed_keys = [vi0,vi1].sort(),[vi1,vi2].sort(),[vi0,vi2].sort()<br />      ase_f.edge_keys = ed_keys<br />      ase_f.vis_sum = AB+BC+CA<br />      if ase_f.vis_sum == 2:<br />         if not AB: ase_f.tri_edge = ed_keys[0]<br />         elif not BC: ase_f.tri_edge = ed_keys[1]<br />         elif not CA: ase_f.tri_edge = ed_keys[2]<br /><br />      # set visibility (fgon) and sharp for edges<br />      # and look if the two face users might form a quad<br />      # or create a new Ase_edge<br />      for k,vis in zip(ed_keys,[AB,BC,CA]):<br />         # Ase_edge already exist or create a new one<br />         if not self.ase_edges.has_key(k):<br />            ase_ed = Ase_edge(k)<br />            ase_ed.fusers.append(ase_f.index)<br />            ase_ed.visible = vis<br />            self.ase_edges[k] = ase_ed<br />            continue<br />         else:<br />            ase_ed = self.ase_edges[k]<br />            ase_ed.fusers.append(ase_f.index)<br />            if ase_f.vis_sum == 2 and not ase_ed.visible:<br />               ase_f.tri_edge = k<br /><br />         fusers = [i for i in ase_ed.fusers if i != ase_f.index]<br />         if not fusers: continue<br />         for i in fusers:<br />            ase_f2 = self.ase_faces[i]<br />            # if this edge is invisible and both tris only have<br />            # this invisible edge, than the two tris could form a quad<br />            # easy done with a sum of all vis variables of the edges<br />            if k == ase_f.tri_edge:<br />               if ase_f.tri_edge == ase_f2.tri_edge:<br />                  ase_f.quad_team = ase_f2.index<br />                  ase_f2.quad_team = ase_f.index<br /><br />            # look if this edge is sharp<br />            # if not both faces share at least one smoothgroup var<br />            # than this edge is sharp<br />            #if ase_ed.sharp: continue<br />            for sg in smooth_groups:<br />               if sg not in ase_f2.smooth_groups:<br />                  ase_ed.sharp = True<br /><br />      self.ase_faces[ase_f.index] = ase_f<br />      self.faceseq.insert(ase_f.index, (ase_f.v0, ase_f.v1, ase_f.v2))<br /><br />   def append_uv_channel(self, layer_index=1):<br />      ''' <br />      Create a new UV Layer and set it active.<br />      '''<br />      self.ase_uv_channels[layer_index] = Ase_uv_channel(layer_index)<br />      self.active_uv = self.ase_uv_channels[layer_index]<br /><br />   def append_tvert(self, ase_uv_index, u, v, w=0):<br />      '''<br />      Create a new UV Vector in the active! UV Channel.<br />      '''<br />      if not self.active_uv: return<br />      #self.active_uv.ase_tverts[ase_uv_index] = Ase_tvert(ase_uv_index,u,v,w)<br />      self.active_uv.ase_tverts[ase_uv_index] = (u,v)<br /><br />   def append_tface(self, ase_face_index, uvi0, uvi1, uvi2, opt_check_seams=False):<br />      '''<br />      Create a new Face UV with indicies to UV Vectors in the active UV Layer.<br />      Optional check for Seams and store into the UV Channel.<br />      '''<br />      if not self.active_uv: return<br />      self.active_uv.ase_tfaces[ase_face_index] = [uvi0, uvi1, uvi2]<br />      # look if this face has seams<br />      # might useless because it makes no sense to import seams for all UV layers<br />      # that's why those edge keys are separately written to each ase UV layer<br />      if opt_check_seams:<br />         edge_keys = self.ase_faces[ase_face_index].edge_keys<br />         for ed_key,uvs in zip(edge_keys,[[uvi0,uvi1],[uvi1,uvi2],[uvi0,uvi2]]):<br />            uvs.sort()<br />            ase_ed,active_uv = self.ase_edges[ed_key],self.active_uv<br />            if not active_uv.ase_tedges.has_key(ed_key):<br />               active_uv.ase_tedges[ed_key] = uvs<br />               continue<br />            elif active_uv.ase_tedges[ed_key] != uvs:<br />               active_uv.seams.append(ed_key)<br /><br />   def append_vertcol(self, ase_color_index, r, g, b):<br />      #new = Ase_vertcolor(ase_color_index, r, g, b)<br />      #self.ase_vertcolors[ase_color_index] = new<br />      self.ase_vertcolors[ase_color_index] = (r,g,b)<br />      <br />   def append_cface(self, ase_face_index, ci0, ci1, ci2):<br />      ase_f = self.ase_faces[ase_face_index]<br />      #f.c0, f.c1, f.c2 = ci0, ci1, ci2<br />      self.ase_cfaces[ase_face_index] = (ci0, ci1, ci2)<br /><br />   def append_normal(self, ase_face_index, x, y, z):<br />      self.ase_faces[ase_face_index].normal = Blender.Mathutils.Vector(x,y,z)<br /><br />   def append_vnormal(self, ase_face_index, ase_vert_index, x, y, z, opt_check_smooth=False):<br />      ase_f = self.ase_faces[ase_face_index]<br />      self.ase_verts[ase_vert_index].normals[ase_face_index] = Blender.Mathutils.Vector(x,y,z)<br />      if opt_check_smooth and ase_f.smooth_groups:<br />         ase_edges = [self.ase_edges[key] for key in ase_f.edge_keys]<br />         for ed_key,ase_ed in zip(ase_f.edge_keys,ase_edges):<br />            if ase_ed.sharp or len(ase_ed.fusers) &lt; 2: continue<br />            for vi in ed_key:<br />               if not self.ase_verts.has_key(vi): continue<br />               vnormals = self.ase_verts[vi].normals<br />               fi0, fi1 = ase_ed.fusers[0:2]<br />               if vnormals.has_key(fi0) and vnormals.has_key(fi1):<br />                  vnor0, vnor1 = vnormals[fi0],vnormals[fi1]<br />                  if vnor0 == vnor1:<br />                     continue<br />                  else:<br />                     angle = round(Blender.Mathutils.AngleBetweenVecs(vnor0, vnor1))<br />                     if not self.autosmooth: self.autosmooth = angle<br />                     elif angle and self.autosmooth &gt; angle:<br />                        print angle<br />                        self.autosmooth = angle<br /><br /><br />class Ase_vert:<br />   def __init__(self, index, x, y, z):<br />      self.index = index<br />      #self.co = Blender.Mathutils.Vector(x,y,z)<br />      self.co = (x,y,z)<br />      self.normals = {}<br /><br />class Ase_edge:<br />   def __init__(self, key):<br />      self.key = key<br />      self.fusers = []<br />      self.uvs = None<br />      self.visible = 1<br />      self.sharp = False<br /><br />class Ase_face:<br />   def __init__(self, ase_face_index, v0, v1, v2, smooth_groups=0, mat_indices=0):<br />      self.index = ase_face_index<br />      self.v0 = v0<br />      self.v1 = v1<br />      self.v2 = v2<br />      self.edge_keys = None<br />      self.c0 = None<br />      self.c1 = None<br />      self.c2 = None<br />      self.normal = None<br />      #self.vert_normals = {}<br />      self.mat_indices = mat_indices<br />      self.smooth_groups = smooth_groups # 0 = solid face<br />      self.vis_sum = 3<br />      self.quad_team = None<br />      self.tri_edge = None<br /><br />class Ase_uv_channel:<br />   def __init__(self, index=1):<br />      self.index = index<br />      self.num = {'TVERTEX':0,'TVFACES':0}<br />      self.uv_layer_name = 'UVTex#' + str(self.index)<br />      self.ase_tverts = {}<br />      self.ase_tfaces = {}<br />      self.ase_tedges = {}<br />      self.seams = []<br /><br />class Ase_tvert:<br />   def __init__(self,index, u, v, w=0):<br />      self.index = index<br />      #self.vec = Blender.Mathutils.Vector(u,v)<br />      self.vec = (u,v)<br /><br />class Ase_tface:<br />   def __init__(self, index, uvi0, uvi1, uvi2):<br />      self.index = index<br />      self.uv = {0:uvi0, 1:uvi1, 2:uvi2}<br /><br />class Ase_vertcolor:<br />   def __init__(self, index, r, g, b):<br />      self.index = 0 <br />      self.r = round(r*256)<br />      self.g = round(g*256)<br />      self.b = round(b*256)<br />      self.a = 255.0<br /><br /><br />def spawn(ase_objects):<br /><br />   PB_index = 0.0<br />   PB_num = float(len(ase_objects))<br /><br />   print 'Import Objects...'<br />   if OPT_PROGRESSBAR: Blender.Window.DrawProgressBar(0.0, "Importing Objects...")<br /><br />   scene = Blender.Scene.GetCurrent()<br />   for ase_ob in ase_objects: <br />      if OPT_PROGRESSBAR and not (PB_index % PB_num):<br />         Blender.Window.DrawProgressBar(PB_index / PB_num, "Importing Objects...")<br /><br />      if ase_ob.ase_type == 'geom':<br />         spawn_mesh(scene,ase_ob)<br /><br />      PB_index += 1.0<br /><br />def spawn_mesh(scene,ase_ob):<br /><br />   ase_me = ase_ob.ase_data<br />   #normal_flag = 1<br /><br />   row0 = ase_ob.row0<br />   row1 = ase_ob.row1<br />   row2 = ase_ob.row2<br />   row3 = ase_ob.row3<br /><br />   matrix = Blender.Mathutils.Matrix(row0, row1, row2, row3)<br />   matrix.resize4x4()<br /><br />   # create new Blender Object and link to scene<br />   ob = Blender.Object.New('Mesh', ase_ob.name)<br />   ob.setMatrix(matrix)<br />   scene.objects.link(ob)<br /><br />   # get Mesh data from Object<br />   me = ob.getData(0,1)<br />   me.vertexColors = me.faceUV = False<br /><br />   # create Verts and Faces<br />   # seems like extend() is limited to a length of 64000?<br />   # this is a problem when importing big meshes.<br />   div = divmod(ase_me.num['VERTEX'], 64000)<br />   if div[1]: div = div[0]+1<br />   else: div = div[0]<br />   start = 0<br />   for i in range(div):<br />      end = start+64000<br />      me.verts.extend(ase_me.vertseq[start:end])<br />      start = end<br />   div = divmod(ase_me.num['FACES'], 64000)<br />   face_index_list = []<br />   if div[1]: div = div[0]+1<br />   else: div = div[0]<br />   start = 0<br />   for i in range(div):<br />      end = start+64000<br />      me.faces.extend(ase_me.faceseq[start:end])<br />      start = end<br /><br />   # import Vertex Colors, Solid/Smooth to faces<br />   if IMP_VCOLOR:<br />      me.vertexColors = ase_me.hasVC<br />      ase_vcolors = ase_me.ase_vertcolors<br />   for i,ase_f in ase_me.ase_faces.iteritems():<br />      try:f = me.faces[i]<br />      except:<br />         # dont know what's the problem with this<br />         print 'array index out of range:', i<br />         continue<br />      if me.vertexColors:<br />         cface = ase_me.ase_cfaces[i]<br />         c0,c1,c2 = ase_vcolors[cface[0]],ase_vcolors[cface[1]],ase_vcolors[cface[2]]<br />         fc0,fc1,fc2 = f.col[:]<br />         fc0.r,fc0.g,fc0.b = int(c0[0]*255),int(c0[1]*255),int(c0[2]*255)<br />         fc1.r,fc1.g,fc1.b = int(c1[0]*255),int(c1[1]*255),int(c1[2]*255)<br />         fc2.r,fc2.g,fc2.b = int(c2[0]*255),int(c2[1]*255),int(c2[2]*255)<br />      if ase_f.smooth_groups:<br />         f.smooth = 1<br /><br />   # import UV layer's<br />   if IMP_UV and ase_me.hasUV:<br />      for uv_chan in ase_me.ase_uv_channels.itervalues():<br />         me.addUVLayer(uv_chan.uv_layer_name)<br />         me.activeUVLayer = uv_chan.uv_layer_name<br />         tverts = uv_chan.ase_tverts<br />         for fi,uvis in uv_chan.ase_tfaces.iteritems():<br />            try:f = me.faces[fi]<br />            except: continue<br />            uv1,uv2,uv3 = tverts[uvis[0]],tverts[uvis[1]],tverts[uvis[2]]<br />            f.uv = [Blender.Mathutils.Vector(uv1), Blender.Mathutils.Vector(uv2), Blender.Mathutils.Vector(uv3)]<br />      me.activeUVLayer = ase_me.ase_uv_channels[1].uv_layer_name<br /><br />   # EXPERIMENTAL!<br />   # convert tris to quads<br />   # this is currently the easiest way i found without destroying uvs or vcolors<br />   # but don't work like expected...:/<br />   if IMP_QUADS:<br />      #quad_teams = set([i for i,ase_f in ase_me.ase_faces.iteritems() if ase_f.quad_team != None])<br />      quad_teams = []<br />      for i,ase_f in ase_me.ase_faces.iteritems():<br />         if ase_f.quad_team != None:<br />            if ase_f.index &lt; ase_f.quad_team: qt = ase_f.index,ase_f.quad_team<br />            elif ase_f.index &gt; ase_f.quad_team: qt = ase_f.quad_team,ase_f.index<br />            if qt not in quad_teams:<br />               quad_teams.append(qt)<br /><br />      faces = me.faces<br />      # first deselect all faces<br />      for f in faces: f.sel = 0<br />      for t0,t1 in quad_teams:<br />         ase_f0 = ase_me.ase_faces[t0]<br />         ase_f1 = ase_me.ase_faces[t1]<br />         try: f0,f1 = me.faces[ase_f0.index], me.faces[ase_f1.index]<br />         except: continue<br />         f0.sel = 1<br />         f1.sel = 1<br />         me.triangleToQuad()<br />         for i in faces.selected():<br />            faces[i].sel = 0<br /><br />   # apply the matrix to mesh (and optional fit the ob and me to blender)<br />   if IMP_SCALED:<br />      # seems this isn't accurate because of precision of the location vector<br />      scale = Blender.Mathutils.ScaleMatrix(OPT_SCALE,4)<br />      inv_matrix = ob.getMatrix().copy().invert() * scale<br />      ob.setLocation(ob.getMatrix().translationPart() * scale)<br />   else:<br />      inv_matrix = ob.getMatrix().copy().invert()<br />   me.transform(inv_matrix, 1)<br />   me.calcNormals()<br /><br />   # apply sharp, seam and fgon flags to edges.<br />   add_EDGESPLIT = False<br />   if IMP_FGONS or IMP_SEAMS or IMP_SMOOTHGROUPS:<br />      SHARP = Mesh.EdgeFlags.SHARP<br />      SEAM = Mesh.EdgeFlags.SEAM<br />      FGON = Mesh.EdgeFlags.FGON<br />      seam_keys = []<br />      if ase_me.hasUV: seam_keys = ase_me.ase_uv_channels[1].seams<br />      for k,ase_ed in ase_me.ase_edges.iteritems():<br />         if ase_ed.sharp or not ase_ed.visible or k in seam_keys:<br />            edi = me.findEdges(k[0],k[1])<br />            if edi:<br />               ed = me.edges[edi]<br />               if ase_me.hasUV and k in seam_keys and IMP_SEAMS: ed.flag |= SEAM<br />               if not ase_ed.visible and IMP_FGONS: ed.flag |= FGON<br />               if ase_ed.sharp and IMP_SMOOTHGROUPS:<br />                    ed.flag |= SHARP<br />                  add_EDGESPLIT = True<br /><br /><br /><br />   # add EdgeSplit Modiefier when the mesh has sharp edges<br />   # autosmooth is EXPERIMENTAL! because i dont know if this is correct!<br />   if add_EDGESPLIT and OPT_MOD_EDGESPLIT:<br />      mod = ob.modifiers.append(Blender.Modifier.Types.EDGESPLIT)<br />      if not ase_me.autosmooth:<br />         mod[Blender.Modifier.Settings.EDGESPLIT_FROM_ANGLE] = 0<br />      else:<br />         mod[Blender.Modifier.Settings.EDGESPLIT_ANGLE] = ase_me.autosmooth<br />      mod[Blender.Modifier.Settings.EDGESPLIT_FROM_SHARP] = 1<br />      ob.makeDisplayList() # Needed to apply the modifier<br />   elif not add_EDGESPLIT and ase_me.autosmooth:<br />      AUTOSMOOTH = Mesh.Modes.AUTOSMOOTH<br />      me.modes |= AUTOSMOOTH<br />      me.degr = ase_me.autosmooth<br /><br />   me.update()<br />   counts['verts'] += ase_me.num['VERTEX']<br />   counts['tris'] += ase_me.num['FACES']<br />   counts['faces'] += len(me.faces)<br />   print 'Imported Mesh-Object: ', ob.name<br /><br />#def oj_the_object_jockey(file):<br />def read_file(file):<br />   '''<br />   Read an .ase file and return a list of ase_objects<br />   '''<br />   lines= file.readlines()<br /><br />   print 'Read file...'<br />   PB_index = 0.0<br />   PB_num = float(len(lines))<br />   if OPT_PROGRESSBAR: Blender.Window.DrawProgressBar(0.0, "Read File...")<br /><br />   # it is needed to read UV if Seams should be imported even when importing UV is disabled<br />   READ_UV = False<br />   if IMP_UV or IMP_SEAMS: READ_UV = True<br />   #if IMP_AUTOSMOOTH and not IMP_SMOOTHGROUPS: IMP_AUTOSMOOTH = False<br /><br />   ase_objects = []<br />   ase_ob = False<br />   for line in lines:<br />      if OPT_PROGRESSBAR and not (PB_index % 10000):<br />         Blender.Window.DrawProgressBar(PB_index / PB_num, "Read File...")<br />      PB_index += 1<br /><br />      words = line.split()<br />      if not words:<br />         continue<br />      word0 = words[0]<br />      if word0 == '*GEOMOBJECT':<br />         #if ase_ob: ase_objects.append(ase_ob)<br />         ase_ob_type = word0.lower()[1:-6] #get rid of '*' and 'OBJECT'<br />         ase_ob = Ase_object(ase_ob_type)<br />         ase_objects.append(ase_ob)<br />         continue<br />      elif word0 in ['*HELPEROBJECT','*SHAPEOBJECT','*LIGHTOBJECT','*CAMERAOBJECT','*GROUP']:<br />         # Not supported objects!<br />         # because these objects too use a TM_NODE,<br />         # ase_ob should be set back to False to prevent errors.<br />         ase_ob = False<br />         continue<br />      elif word0 == '*NODE_NAME' and ase_ob:<br />         name = words[1][1:-1] #get rid of '"'<br />         if ase_ob and ase_ob.name != '': ase_ob.ase_data.name = name<br />         elif ase_ob: ase_ob.name = name<br />         continue<br />      elif word0 == '*NODE_PARENT' and ase_ob:<br />         ase_ob.parent = words[1][1:-1] #get rid of '"'<br />         continue<br />      elif word0 == '*TM_ROW0' and ase_ob:<br />         ase_ob.row0 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*TM_ROW1' and ase_ob:<br />         ase_ob.row1 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*TM_ROW2' and ase_ob:<br />         ase_ob.row2 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*TM_ROW3' and ase_ob:<br />         ase_ob.row3 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*MESH':<br />         ase_me = ase_ob.ase_data<br />         continue<br />      elif word0 == '*MESH_NUMVERTEX':<br />         ase_me.num['VERTEX'] = int(words[1])<br />         continue<br />      elif word0 == '*MESH_NUMFACES':<br />         ase_me.num['FACES'] = int(words[1])<br />         continue<br />      elif word0 == '*MESH_VERTEX':<br />         #vert_index, x, y, z<br />         ase_me.append_vert(int(words[1]),float(words[2]),float(words[3]),float(words[4]))<br />         continue<br />      elif word0 == '*MESH_FACE':<br />         #ase_face_index, vi0, vi1, vi2, AB, BC, CA, smooth_groups, mat_indicies<br />         #smooth = mat = False<br />         ase_face_index = words[1]<br />         if ase_face_index.endswith(':'):<br />            ase_face_index = ase_face_index[:-1]<br /><br />         smooth_groups = mat_indices = []<br />         for i,w in enumerate(words):<br />            if w == '*MESH_SMOOTHING' and IMP_SMOOTHGROUPS:<br />               try:<br />                  if words[i+1] != '*MESH_MTLID':<br />                     smooth_groups = [int(i) for i in words[i+1].split(',')]<br />               except:<br />                  smooth_groups = 0<br />            elif w == '*MESH_MTLID' and IMP_SMOOTHGROUPS:<br />               try:<br />                  mat_indices = [int(i) for i in words[i+1].split(',')]<br />               except:<br />                  mat_indices = 0<br />         ase_me.append_face(int(ase_face_index),int(words[3]),int(words[5]),int(words[7]),int(words[9]),int(words[11]),int(words[13]),smooth_groups,mat_indices)<br />         continue<br />      elif READ_UV:<br />         if word0 == '*MESH_NUMTVERTEX':<br />            if not ase_me.ase_uv_channels: ase_me.append_uv_channel()<br />            ase_me.active_uv.num['TVERTEX'] = int(words[1])<br />            ase_me.hasUV = True<br />            continue<br />         elif word0 == '*MESH_MAPPINGCHANNEL':<br />            # uv_channel_index<br />            ase_me.append_uv_channel(int(words[1]))<br />            continue<br />         elif word0 == '*MESH_TVERT':<br />            #uv_index, u, v, w<br />            ase_me.append_tvert(int(words[1]),float(words[2]),float(words[3]),float(words[4]))<br />            continue<br />         elif word0 == '*MESH_NUMTVFACES':<br />            ase_me.active_uv.num['TVFACES'] = int(words[1])<br />            continue<br />         elif word0 == '*MESH_TFACE':<br />            #ase_face_index, uv0, uv1, uv2, opt_IMP_SEAMS<br />            ase_face_index = words[1]<br />            if ase_face_index.endswith(':'):<br />               ase_face_index = ase_face_index[:-1]<br />            ase_me.append_tface(int(ase_face_index),int(words[2]),int(words[3]),int(words[4]),IMP_SEAMS)<br />            continue<br />      elif IMP_VCOLOR:<br />         if word0 == '*MESH_NUMCVERTEX':<br />            ase_me.num['CVERTEX'] = int(words[1])<br />            if ase_me.num['CVERTEX']:<br />               ase_me.hasVC = True<br />            continue<br />         elif word0 == '*MESH_VERTCOL':<br />            #color_index, r, g, b<br />            ase_me.append_vertcol(int(words[1]),float(words[2]),float(words[3]),float(words[4]))<br />            continue<br />         elif word0 == '*MESH_NUMCVFACES':<br />            ase_me.num['CVFACES'] = words[1]<br />            continue<br />         elif word0 == '*MESH_CFACE':<br />            #ase_face_index, ci0, ci1, ci2<br />            ase_face_index = words[1]<br />            if ase_face_index.endswith(':'):<br />               ase_face_index = ase_face_index[:-1]<br />            ase_me.append_cface(int(ase_face_index),int(words[2]),int(words[3]),int(words[4]))<br />            continue<br />      #elif word0 == '*MESH_NORMALS':<br />      elif IMP_AUTOSMOOTH:<br />         if word0 == '*MESH_FACENORMAL':<br />            # ase_face_index, x, y, z<br />            ase_face_index = int(words[1])<br />            ase_me.append_normal(ase_face_index,float(words[2]),float(words[3]),float(words[4]))<br />            continue<br />         elif word0 == '*MESH_VERTEXNORMAL':<br />            # ase_face_index, ase_vert_index, x, y, z<br />            ase_me.append_vnormal(ase_face_index,int(words[1]),float(words[2]),float(words[3]),float(words[4]),IMP_AUTOSMOOTH)<br />            continue<br />      else:<br />         continue<br />   return ase_objects<br /><br />def print_boxed(text): #Copy/Paste from meshtools, only to remove the beep :)<br />   lines = text.splitlines()<br />   maxlinelen = max(map(len, lines))<br />   if sys.platform[:3] == "win":<br />      print chr(218)+chr(196) + chr(196)*maxlinelen + chr(196)+chr(191) <br />      for line in lines: <br />         print chr(179) + ' ' + line.ljust(maxlinelen) + ' ' + chr(179) <br />      print chr(192)+chr(196) + chr(196)*maxlinelen + chr(196)+chr(217) <br />   else: <br />      print '+-' + '-'*maxlinelen + '-+' <br />      for line in lines: print '| ' + line.ljust(maxlinelen) + ' |' <br />      print '+-' + '-'*maxlinelen + '-+' <br /><br />def read(filename):<br /><br />   global counts<br />   counts = {'verts':0,'tris':0,'faces':0}<br /><br />   start = time.clock()<br /><br />   print_boxed("----------ASCII Scene Import----------")<br />   print 'Import File: ', filename<br /><br />   mode = Blender.Window.EditMode()     # are we in edit mode?  If so ...<br />   if mode: Blender.Window.EditMode(0) # leave edit mode before getting the mesh<br /><br />   file = open(filename,'r', OPT_FILE_BUFFER)<br />   ase_objects = read_file(file)<br />   file.close()<br />   spawn(ase_objects)<br />   Blender.Redraw()<br />   if OPT_PROGRESSBAR: Blender.Window.DrawProgressBar(1.0, '')  # clear progressbar<br />   # Blender.Window.EditMode(mode)<br /><br />   end = time.clock()<br />   seconds = " in %.2f %s" % (end-start, "seconds") <br />   #totals = "Imported Verts: %i Faces: %i Tris: %i " % (counts['verts'],counts['tris'],counts['faces'])<br />   #print_boxed(totals)<br />   message = "Successfully imported " + Blender.sys.basename(filename) + seconds <br />   print_boxed(message)<br /><br /><br /><br /><br />def read_ui(filename): <br /><br />   global IMPORT_SC, IMPORT_VC, IMP_UV, IMPORT_GO, IMPORT_SE, IMPORT_SM<br />   global IMP_SCALED,IMP_SMOOTHGROUPS,IMP_VCOLOR,IMP_UV,IMP_FGONS,IMP_QUADS,IMP_SEAMS,IMP_SMOOTHGROUPS,IMP_AUTOSMOOTH<br /><br />   IMPORT_SC = Blender.Draw.Create(IMP_SCALED)<br />   IMPORT_VC = Blender.Draw.Create(IMP_VCOLOR)<br />   IMP_UV = Blender.Draw.Create(IMP_UV)<br />   IMPORT_SE = Blender.Draw.Create(IMP_SEAMS)<br />   IMPORT_SM = Blender.Draw.Create(IMP_SMOOTHGROUPS)<br /><br />   # Get USER Options <br />   pup_block = [('Import Options'),('Scale Meshes', IMPORT_SC, 'Scale the Objects so that they better fit into Blender\'s grid size'),('Vertex Colors', IMPORT_VC, 'Import Vertex Colors if existing'),('UV (Layer)', IMP_UV, 'Import UV and UV layer\'s if existing'),('Smoothing', IMPORT_SM, 'Surround Smoothgroups with sharp edges'),('Seams', IMPORT_SE, 'Try to import Seams from UV islands (from the first UV layer!)')]<br /><br />   if not Blender.Draw.PupBlock('Import ASCII Scene...', pup_block):<br />      return<br /><br />   Blender.Window.WaitCursor(1)<br /><br />   IMP_SCALED = IMPORT_SC.val<br />   IMP_VCOLOR = IMPORT_VC.val<br />   IMP_UV = IMP_UV.val<br />   IMP_SEAMS = IMPORT_SE.val<br />   IMP_SMOOTHGROUPS = IMPORT_SM.val<br /><br />   read(filename)<br /><br />   Blender.Window.WaitCursor(0)<br />   Blender.Redraw()<br /><br /><br />if __name__ == '__main__' and OPT_FILESELECTOR:<br />   Blender.Window.FileSelector(read_ui, 'Import ASCII Scene', ('.ase'))<br />elif __name__ == '__main__':<br />   read_ui(OPT_STATIC_FILENAME)</div></div>]]></body></post><post id="p140320" date="Posted: Mon Apr 17, 2006 1:12 pm "><author>Bittoman</author><body><![CDATA[<div class="postbody">Nice job, thanks Goofos!</div>]]></body></post><post id="p140355" date="Posted: Mon Apr 17, 2006 10:30 pm "><author>kat</author><body><![CDATA[<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en-gb" xml:lang="en-gb" xml:lang="en-gb">
  <head>
    <script type="text/javascript" src="https://web.archive.org/static/js/analytics.js"></script>
    <link type="text/css" rel="stylesheet" href="https://web.archive.org/static/css/banner-styles.css" />
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta http-equiv="content-language" content="en-gb" />
    <meta http-equiv="content-style-type" content="text/css" />
    <meta http-equiv="imagetoolbar" content="no" />
    <meta name="resource-type" content="document" />
    <meta name="distribution" content="global" />
    <meta name="copyright" content="2002-2006 phpBB Group" />
    <meta name="keywords" content="" />
    <meta name="description" content="" />
    <title>Doom3world • View topic - ASE Importer</title>
    <link rel="stylesheet" href="https://web.archive.org/web/20070509181516cs_/http://doom3world.org/phpbb2/styles/subsilver2/theme/stylesheet.css" type="text/css" />
    <script type="text/javascript">
<![CDATA[
// <![CDATA[

function popup(url, width, height, name)
{
	if (!name)
	{
		name = '_popup';
	}

	window.open(url.replace(/&amp;/g, '&'), name, 'height=' + height + ',resizable=yes,scrollbars=yes,width=' + width);
	return false;
}

function jumpto()
{
	var page = prompt('Enter the page number you wish to go to.:', '1');
	var perpage = '20';
	var base_url = './viewtopic.php?f=50&amp;t=15404&amp;st=0&amp;sk=t&amp;sd=a&amp;sid=6c494125f3651879278eb48965ace839';

	if (page !== null && !isNaN(page) && page > 0)
	{
		document.location.href = base_url.replace(/&amp;/g, '&') + '&start=' + ((page - 1) * perpage);
	}
}

/**
* Find a member
*/
function find_username(url)
{
	popup(url, 760, 570, '_usersearch');
	return false;
}

/**
* Mark/unmark checklist
* id = ID of parent container, name = name prefix, state = state [true/false]
*/
function marklist(id, name, state)
{
	var parent = document.getElementById(id);
	if (!parent)
	{
		eval('parent = document.' + id);
	}

	if (!parent)
	{
		return;
	}

	var rb = parent.getElementsByTagName('input');
	
	for (var r = 0; r < rb.length; r++)
	{
		if (rb[r].name.substr(0, name.length) == name)
		{
			rb[r].checked = state;
		}
	}
}


// ]]]] ><![CDATA[>
]] >
    </script>
  </head>
  <body class="ltr">
<!-- BEGIN WAYBACK TOOLBAR INSERT -->
<script><![CDATA[ if (window.archive_analytics) { window.archive_analytics.values['server_name']="wwwb-app3.us.archive.org";}; ]] ></script><script type="text/javascript" src="https://web.archive.org/static/js/disclaim-element.js"></script><script type="text/javascript" src="https://web.archive.org/static/js/graph-calc.js"></script><script type="text/javascript" src="https://web.archive.org/static/jflot/jquery.min.js"></script><script type="text/javascript"><![CDATA[
//<![CDATA[
var firstDate = 820454400000;
var lastDate = 1420070399999;
var wbPrefix = "/web/";
var wbCurrentUrl = "http:\/\/doom3world.org\/phpbb2\/viewtopic.php?p=140291";

var curYear = -1;
var curMonth = -1;
var yearCount = 18;
var firstYear = 1996;
var imgWidth = 475;
var yearImgWidth = 25;
var monthImgWidth = 2;
var trackerVal = "none";
var displayDay = "9";
var displayMonth = "May";
var displayYear = "2007";
var prettyMonths = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];

function showTrackers(val) {
	if(val == trackerVal) {
		return;
	}
	if(val == "inline") {
		document.getElementById("displayYearEl").style.color = "#ec008c";
		document.getElementById("displayMonthEl").style.color = "#ec008c";
		document.getElementById("displayDayEl").style.color = "#ec008c";		
	} else {
		document.getElementById("displayYearEl").innerHTML = displayYear;
		document.getElementById("displayYearEl").style.color = "#ff0";
		document.getElementById("displayMonthEl").innerHTML = displayMonth;
		document.getElementById("displayMonthEl").style.color = "#ff0";
		document.getElementById("displayDayEl").innerHTML = displayDay;
		document.getElementById("displayDayEl").style.color = "#ff0";
	}
   document.getElementById("wbMouseTrackYearImg").style.display = val;
   document.getElementById("wbMouseTrackMonthImg").style.display = val;
   trackerVal = val;
}
function getElementX2(obj) {
	var thing = jQuery(obj);
	if((thing == undefined) 
			|| (typeof thing == "undefined") 
			|| (typeof thing.offset == "undefined")) {
		return getElementX(obj);
	}
	return Math.round(thing.offset().left);
}
function trackMouseMove(event,element) {

   var eventX = getEventX(event);
   var elementX = getElementX2(element);
   var xOff = eventX - elementX;
	if(xOff < 0) {
		xOff = 0;
	} else if(xOff > imgWidth) {
		xOff = imgWidth;
	}
   var monthOff = xOff % yearImgWidth;

   var year = Math.floor(xOff / yearImgWidth);
	var yearStart = year * yearImgWidth;
   var monthOfYear = Math.floor(monthOff / monthImgWidth);
   if(monthOfYear > 11) {
       monthOfYear = 11;
   }
   // 1 extra border pixel at the left edge of the year:
   var month = (year * 12) + monthOfYear;
   var day = 1;
	if(monthOff % 2 == 1) {
		day = 15;
	}
	var dateString = 
		zeroPad(year + firstYear) + 
		zeroPad(monthOfYear+1,2) +
		zeroPad(day,2) + "000000";

	var monthString = prettyMonths[monthOfYear];
	document.getElementById("displayYearEl").innerHTML = year + 1996;
	document.getElementById("displayMonthEl").innerHTML = monthString;
	// looks too jarring when it changes..
	//document.getElementById("displayDayEl").innerHTML = zeroPad(day,2);

	var url = wbPrefix + dateString + '/' +  wbCurrentUrl;
	document.getElementById('wm-graph-anchor').href = url;

   //document.getElementById("wmtbURL").value="evX("+eventX+") elX("+elementX+") xO("+xOff+") y("+year+") m("+month+") monthOff("+monthOff+") DS("+dateString+") Moy("+monthOfYear+") ms("+monthString+")";
   if(curYear != year) {
       var yrOff = year * yearImgWidth;
       document.getElementById("wbMouseTrackYearImg").style.left = yrOff + "px";
       curYear = year;
   }
   if(curMonth != month) {
       var mtOff = year + (month * monthImgWidth) + 1;
       document.getElementById("wbMouseTrackMonthImg").style.left = mtOff + "px";
       curMonth = month;
   }
}
//]]]] ><![CDATA[>
]] ></script><style type="text/css"><![CDATA[body{margin-top:0!important;padding-top:0!important;min-width:800px!important;}#wm-ipp a:hover{text-decoration:underline!important;}]] ></style><div id="wm-ipp" lang="en" class="__wb_banner_div" style="display:none; position:relative;padding:0 5px;min-height:70px;min-width:800px" xml:lang="en">


<div id="wm-ipp-inside" class="__wb_banner_div" style="position:fixed;padding:0!important;margin:0!important;width:97%;min-width:780px;border:5px solid #000;border-top:none;background-image:url(https://web.archive.org/static/images/toolbar/wm_tb_bk_trns.png);text-align:center;-moz-box-shadow:1px 1px 3px #333;-webkit-box-shadow:1px 1px 3px #333;box-shadow:1px 1px 3px #333;font-size:11px!important;font-family:'Lucida Grande','Arial',sans-serif!important;">
   <table style="border-collapse:collapse;margin:0;padding:0;width:100%;"><tbody><tr><td style="padding:10px;vertical-align:top;min-width:110px;">
   <a href="https://web.archive.org/web/" title="Wayback Machine home page" style="background-color:transparent;border:none;"><img src="https://web.archive.org/static/images/toolbar/wayback-toolbar-logo.png" alt="Wayback Machine" width="110" height="39" border="0" /></a>
   </td>
   <td style="padding:0!important;text-align:center;vertical-align:top;width:100%;">

       <table style="border-collapse:collapse;margin:0 auto;padding:0;width:570px;"><tbody><tr><td style="padding:3px 0;" colspan="2">
       <form target="_top" method="get" action="https://web.archive.org/web/form-submit.jsp" name="wmtb" id="wmtb" style="margin:0!important;padding:0!important;"><input type="text" name="url" id="wmtbURL" value="http://doom3world.org/phpbb2/viewtopic.php?p=140291" style="width:400px;font-size:11px;font-family:'Lucida Grande','Arial',sans-serif;" onfocus="javascript:this.focus();this.select();" /><input type="hidden" name="type" value="replay" /><input type="hidden" name="date" value="20070509181516" /><input type="submit" value="Go" style="font-size:11px;font-family:'Lucida Grande','Arial',sans-serif;margin-left:5px;width: inherit !important" /><span id="wm_tb_options" style="display:block;"></span></form>
       </td>
       <td style="vertical-align:bottom;padding:5px 0 0 0!important;" rowspan="2">
           <table style="border-collapse:collapse;width:110px;color:#99a;font-family:'Helvetica','Lucida Grande','Arial',sans-serif;"><tbody><!-- NEXT/PREV MONTH NAV AND MONTH INDICATOR --><tr style="width:110px;height:16px;font-size:10px!important;"><td style="padding-right:9px;font-size:11px!important;font-weight:bold;text-transform:uppercase;text-align:right;white-space:nowrap;overflow:visible;" nowrap="nowrap">
               
		                <a href="https://web.archive.org/web/20061012234445/http://doom3world.org/phpbb2/viewtopic.php?p=140291" style="text-decoration:none;color:#33f;font-weight:bold;background-color:transparent;border:none;" title="12 Oct 2006"><strong>OCT</strong></a>
		                
               </td>
               <td id="displayMonthEl" style="background:#000;color:#ff0;font-size:11px!important;font-weight:bold;text-transform:uppercase;width:34px;height:15px;padding-top:1px;text-align:center;" title="You are here: 18:15:16 May 9, 2007">MAY</td>
				<td style="padding-left:9px;font-size:11px!important;font-weight:bold;text-transform:uppercase;white-space:nowrap;overflow:visible;" nowrap="nowrap">
               
                       Jun
                       
               </td>
           </tr><!-- NEXT/PREV CAPTURE NAV AND DAY OF MONTH INDICATOR --><tr><td style="padding-right:9px;white-space:nowrap;overflow:visible;text-align:right!important;vertical-align:middle!important;" nowrap="nowrap">
               
		                <a href="https://web.archive.org/web/20061012234445/http://doom3world.org/phpbb2/viewtopic.php?p=140291" title="23:44:45 Oct 12, 2006" style="background-color:transparent;border:none;"><img src="https://web.archive.org/static/images/toolbar/wm_tb_prv_on.png" alt="Previous capture" width="14" height="16" border="0" /></a>
		                
               </td>
               <td id="displayDayEl" style="background:#000;color:#ff0;width:34px;height:24px;padding:2px 0 0 0;text-align:center;font-size:24px;font-weight: bold;" title="You are here: 18:15:16 May 9, 2007">9</td>
				<td style="padding-left:9px;white-space:nowrap;overflow:visible;text-align:left!important;vertical-align:middle!important;" nowrap="nowrap">
               
                       <img src="https://web.archive.org/static/images/toolbar/wm_tb_nxt_off.png" alt="Next capture" width="14" height="16" border="0" /></td>
           </tr><!-- NEXT/PREV YEAR NAV AND YEAR INDICATOR --><tr style="width:110px;height:13px;font-size:9px!important;"><td style="padding-right:9px;font-size:11px!important;font-weight: bold;text-align:right;white-space:nowrap;overflow:visible;" nowrap="nowrap">
               
                       2006
                       
               </td>
               <td id="displayYearEl" style="background:#000;color:#ff0;font-size:11px!important;font-weight: bold;padding-top:1px;width:34px;height:13px;text-align:center;" title="You are here: 18:15:16 May 9, 2007">2007</td>
				<td style="padding-left:9px;font-size:11px!important;font-weight: bold;white-space:nowrap;overflow:visible;" nowrap="nowrap">
               
                       2008
                       
				</td>
           </tr></tbody></table></td>

       </tr><tr><td style="vertical-align:middle;padding:0!important;">
           <a href="https://web.archive.org/web/20070509181516*/http://doom3world.org/phpbb2/viewtopic.php?p=140291" style="color:#33f;font-size:11px;font-weight:bold;background-color:transparent;border:none;" title="See a list of every capture for this URL"><strong>2 captures</strong></a>
           <div class="__wb_banner_div" style="margin:0!important;padding:0!important;color:#666;font-size:9px;padding-top:2px!important;white-space:nowrap;" title="Timespan for captures of this URL">12 Oct 06 - 9 May 07</div>
       </td>
       <td style="padding:0!important;">
       <a style="position:relative; white-space:nowrap; width:475px;height:27px;" href="viewtopic.php?p=140291" id="wm-graph-anchor">
       <div class="__wb_banner_div" id="wm-ipp-sparkline" style="position:relative; white-space:nowrap; width:475px;height:27px;background-color:#fff;cursor:pointer;border-right:1px solid #ccc;" title="Explore captures for this URL">
			<img id="sparklineImgId" style="position:absolute; z-index:9012; top:0px; left:0px;" onmouseover="showTrackers('inline');" onmouseout="showTrackers('none');" onmousemove="trackMouseMove(event,this)" alt="sparklines" width="475" height="27" border="0" src="https://web.archive.org/web/jsp/graph.jsp?graphdata=475_27_1996:-1:000000000000_1997:-1:000000000000_1998:-1:000000000000_1999:-1:000000000000_2000:-1:000000000000_2001:-1:000000000000_2002:-1:000000000000_2003:-1:000000000000_2004:-1:000000000000_2005:-1:000000000000_2006:-1:000000000100_2007:4:000010000000_2008:-1:000000000000_2009:-1:000000000000_2010:-1:000000000000_2011:-1:000000000000_2012:-1:000000000000_2013:-1:000000000000_2014:-1:000000000000" /><img id="wbMouseTrackYearImg" style="display:none; position:absolute; z-index:9010;" width="25" height="27" border="0" src="https://web.archive.org/static/images/toolbar/transp-yellow-pixel.png" /><img id="wbMouseTrackMonthImg" style="display:none; position:absolute; z-index:9011; " width="2" height="27" border="0" src="https://web.archive.org/static/images/toolbar/transp-red-pixel.png" /></div>
		</a>

       </td>
       </tr></tbody></table></td>
   <td style="text-align:right;padding:5px;width:65px;font-size:11px!important;">
       <a href="javascript:;" onclick="document.getElementById('wm-ipp').style.display='none';" style="display:block;padding-right:18px;background:url(https://web.archive.org/static/images/toolbar/wm_tb_close.png) no-repeat 100% 0;color:#33f;font-family:'Lucida Grande','Arial',sans-serif;margin-bottom:23px;background-color:transparent;border:none;" title="Close the toolbar">Close</a>
       <a href="http://faq.web.archive.org/" style="display:block;padding-right:18px;background:url(https://web.archive.org/static/images/toolbar/wm_tb_help.png) no-repeat 100% 0;color:#33f;font-family:'Lucida Grande','Arial',sans-serif;background-color:transparent;border:none;" title="Get some help using the Wayback Machine">Help</a>
   </td>
   </tr></tbody></table></div>
</div>
<script type="text/javascript"><![CDATA[
 var wmDisclaimBanner = document.getElementById("wm-ipp");
 if(wmDisclaimBanner != null) {
   disclaimElement(wmDisclaimBanner);
 }
]] ></script><!-- END WAYBACK TOOLBAR INSERT --><a name="top" id="top"></a>

<div id="wrapheader">

	<div id="logodesc">
		<table width="100%" cellspacing="0"><tr><td><a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/index.php?sid=6c494125f3651879278eb48965ace839"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/imageset/site_logo.gif" width="300" height="71" alt="" title="" /></a></td>
			<td width="100%" align="center"><h1>Doom3world</h1><span class="gen">The world is yours! Doom 3 - Quake 4 - ET:QW - Prey - Rage</span>
      
      <br /><script type="text/javascript"><![CDATA[<!--
      google_ad_client = "pub-9445709839432880";
      google_ad_width = 468;
      google_ad_height = 60;
      google_ad_format = "468x60_as";
      google_ad_type = "text_image";
      //2007-11-04: D3WForums_banner_header
      google_ad_channel = "6206397355";
      google_color_border = "DCE1E5";
      google_color_bg = "DCE1E5";
      google_color_link = "006699";
      google_color_text = "000000";
      google_color_url = "006699";
      google_ui_features = "rc:0";
      //-->
      ]] ></script><script type="text/javascript" src="https://web.archive.org/web/20070509181516js_/http://pagead2.googlesyndication.com/pagead/show_ads.js"><![CDATA[
  ]] ></script></td>
		</tr></table></div>

	<div id="menubar">
		<table width="100%" cellspacing="0"><tr><td class="genmed">
				<a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/ucp.php?mode=login&amp;sid=6c494125f3651879278eb48965ace839"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/theme/images/icon_mini_login.gif" width="12" height="13" alt="*" /> Login</a>   <a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/ucp.php?mode=register&amp;sid=6c494125f3651879278eb48965ace839"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/theme/images/icon_mini_register.gif" width="12" height="13" alt="*" /> Register</a>
								</td>
			<td class="genmed" align="right">
				<a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/faq.php?sid=6c494125f3651879278eb48965ace839"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/theme/images/icon_mini_faq.gif" width="12" height="13" alt="*" /> FAQ</a>
				   <a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/search.php?sid=6c494125f3651879278eb48965ace839"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/theme/images/icon_mini_search.gif" width="12" height="13" alt="*" /> Search</a>			</td>
		</tr></table></div>

	<div id="datebar">
		<table width="100%" cellspacing="0"><tr><td class="gensmall"></td>
			<td class="gensmall" align="right">It is currently Sat Dec 22, 2007 4:11 pm<br /></td>
		</tr></table></div>

</div>

<div id="wrapcentre">

		<p class="searchbar">
		<span style="float: left;"><a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/search.php?search_id=unanswered&amp;sid=6c494125f3651879278eb48965ace839">View unanswered posts</a> | <a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/search.php?search_id=active_topics&amp;sid=6c494125f3651879278eb48965ace839">View active topics</a></span>
			</p>
	
	<br style="clear: both;" /><table class="tablebg" width="100%" cellspacing="1" cellpadding="0" style="margin-top: 5px;"><tr><td class="row1">
			<p class="breadcrumbs"><a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/index.php?sid=6c494125f3651879278eb48965ace839">Board index</a> 
   » <a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/viewforum.php?f=71&amp;sid=6c494125f3651879278eb48965ace839">General Discussion</a> » <a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/viewforum.php?f=72&amp;sid=6c494125f3651879278eb48965ace839">3D editing and offline rendering</a> » <a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/viewforum.php?f=50&amp;sid=6c494125f3651879278eb48965ace839">Blender</a>      
  

  
  </p>
			<p class="datetime">All times are UTC </p>
		</td>
	</tr></table><center>
  <script type="text/javascript"><![CDATA[<!--
      google_ad_client = "pub-9445709839432880";
      google_ad_width = 728;
      google_ad_height = 15;
      google_ad_format = "728x15_0ads_al_s";
      //2007-11-03: D3WForums_linkblock
      google_ad_channel = "1963952183";
      google_color_border = "FFFFFF";
      google_color_bg = "FFFFFF";
      google_color_link = "006699";
      google_color_text = "006699";
      google_color_url = "006699";
      //-->
      ]] ></script><script type="text/javascript" src="https://web.archive.org/web/20070509181516js_/http://pagead2.googlesyndication.com/pagead/show_ads.js"><![CDATA[
  ]] ></script></center>
	<br /><div id="pageheader">
	<h2><a class="titles" href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/viewtopic.php?f=50&amp;t=15404&amp;start=0&amp;st=0&amp;sk=t&amp;sd=a&amp;sid=6c494125f3651879278eb48965ace839">ASE Importer</a></h2>

	<p class="moderators">Moderator: <a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/memberlist.php?mode=group&amp;g=654&amp;sid=6c494125f3651879278eb48965ace839">il padrino</a></p>
</div>

<br clear="all" /><br /><div id="pagecontent">

	<table width="100%" cellspacing="1"><tr><td align="left" valign="middle" nowrap="nowrap">
		<a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/posting.php?mode=post&amp;f=50&amp;sid=6c494125f3651879278eb48965ace839"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/imageset/en/button_topic_new.gif" alt="Post new topic" title="Post new topic" /></a> <a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/posting.php?mode=reply&amp;f=50&amp;t=15404&amp;sid=6c494125f3651879278eb48965ace839"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/imageset/en/button_topic_reply.gif" alt="Reply to topic" title="Reply to topic" /></a>		</td>
					<td class="nav" valign="middle" nowrap="nowrap"> Page <strong>1</strong> of <strong>2</strong><br /></td>
			<td class="gensmall" nowrap="nowrap"> [ 21 posts ] </td>
			<td class="gensmall" width="100%" align="right" nowrap="nowrap"><b><a href="viewtopic.php?p=140291#" onclick="jumpto(); return false;" title="Click to jump to page…">Go to page</a> <strong>1</strong><span class="page-sep">, </span><a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/viewtopic.php?f=50&amp;t=15404&amp;st=0&amp;sk=t&amp;sd=a&amp;sid=6c494125f3651879278eb48965ace839&amp;start=20">2</a>  <a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/viewtopic.php?f=50&amp;t=15404&amp;st=0&amp;sk=t&amp;sd=a&amp;sid=6c494125f3651879278eb48965ace839&amp;start=20">Next</a></b></td>
			</tr></table><table class="tablebg" width="100%" cellspacing="1"><tr><td class="cat">
			<table width="100%" cellspacing="0"><tr><td class="nav" nowrap="nowrap"> 
								</td>
				<td class="nav" align="right" nowrap="nowrap"><a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/viewtopic.php?f=50&amp;t=15404&amp;view=previous&amp;sid=6c494125f3651879278eb48965ace839">Previous topic</a> | <a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/viewtopic.php?f=50&amp;t=15404&amp;view=next&amp;sid=6c494125f3651879278eb48965ace839">Next topic</a> </td>
			</tr></table></td>
	</tr></table><table class="tablebg" width="100%" cellspacing="1"><tr><th>Author</th>
			<th>Message</th>
		</tr><tr class="row1"><td align="center" valign="middle">
				<a name="p140291" id="p140291"></a>
				<b class="postauthor">Goofos</b>
			</td>
			<td width="100%" height="25">
				<table width="100%" cellspacing="0"><tr><td class="gensmall" width="100%"><div style="float: left;"> <b>Post subject:</b> ASE Importer</div><div style="float: right;"><a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/viewtopic.php?p=140291&amp;sid=6c494125f3651879278eb48965ace839#p140291"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/imageset/icon_post_target.gif" width="12" height="9" alt="Post" title="Post" /></a><b>Posted:</b> Mon Apr 17, 2006 2:00 am </div></td>
				</tr></table></td>
		</tr><tr class="row1"><td valign="top" class="profile">
				<table cellspacing="4" align="center" width="150"><tr><td><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/imageset/en/icon_user_offline.gif" alt="Offline" title="Offline" /></td>
				</tr><tr><td class="postdetails">picked up the chaingun</td>
				</tr><tr><td><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/download/file.php?avatar=12761.gif" width="30" height="22" alt="User avatar" /></td>
				</tr></table><span class="postdetails">
					<br /><b>Joined:</b> Thu Mar 10, 2005 2:05 am<br /><b>Posts:</b> 177<br /><b>Location:</b> black forrest				</span>

			</td>
			<td valign="top">
				<table width="100%" cellspacing="5"><tr><td>
					
						<div class="postbody"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/images/smilies/icon_arrow.gif" alt=":arrow:" title="Arrow" /> Version: 0.13
<br /><br />Supports Mesh Objects with vertex colors, multiple UV, smoothgroups.
<br /><br />A little Note!: you should not try to import very big ase files (&gt;50 MB with 512 MB RAM). With much RAM you might can try this.
<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">#!BPY<br /><br />"""<br />Name: 'ASCII Scene (.ase) v0.13'<br />Blender: 244<br />Group: 'Import'<br />Tooltip: 'Import from ASCII Scene Export file format (.ase)'<br />""" <br />__author__ = "Goofos"<br />__version__ = "0.13"<br /><br /># goofos<br />#<br /># ***** BEGIN GPL LICENSE BLOCK *****<br />#<br /># This program is free software; you can redistribute it and/or<br /># modify it under the terms of the GNU General Public License<br /># as published by the Free Software Foundation; either version 2<br /># of the License, or (at your option) any later version.<br /># <br /># This program is distributed in the hope that it will be useful,<br /># but WITHOUT ANY WARRANTY; without even the implied warranty of<br /># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<br /># GNU General Public License for more details.<br /># <br /># You should have received a copy of the GNU General Public License<br /># along with this program; if not, write to the Free Software Foundation,<br /># Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.<br /># <br /># ***** END GPL LICENCE BLOCK *****<br /><br />import time, sys<br />import Blender<br />from Blender import Scene, Object, Mesh<br /><br />'''<br />Some Options<br />'''<br /># Scale Factor (float)<br />OPT_SCALE = 0.1<br /># Add EdgeSplit Modifier when importing sharp edges (bool)<br />OPT_MOD_EDGESPLIT = True<br /># Enable the fileselector (bool)<br />OPT_FILESELECTOR = True<br /># If the fileselector is disabled, specify a static filename (string)<br />OPT_STATIC_FILENAME = 'E:\ASE Files\garage.ASE'<br /># Enable Progressbar (bool)<br />OPT_PROGRESSBAR = False<br /># File buffer. After testing with big files i think there is no real difference.<br /># -1 = system default, 0 = unbuffered, 1 = line buffered, &gt;1 = buffer size<br />OPT_FILE_BUFFER = -1<br /><br />'''<br />Import Options<br />'''<br /># Import Meshes scaled, defined by the scale factor of OPT_SCALE (bool)<br /># Note: Object location data looses some precision, .. i think!<br />IMP_SCALED = True<br /># Import Vertex Colors (bool)<br />IMP_VCOLOR = True<br /># Import UV Coords and UV layers (bool)<br />IMP_UV = True<br /># Import NGons as Blender FGons (bool)<br /># Note: Include quads, too.<br />IMP_FGONS = False<br /># Try to find possible quads and convert the two tris to a quad (bool)<br /># Note: Very slow!! ablsolutely doesn't work accurate :/<br /># i don't know wether this is a script problem or a blender problem!<br />IMP_QUADS = False<br /># Surround UV islands with seams (bool)<br />IMP_SEAMS = False<br /># Surround smooth groups with sharp edges (bool)<br />IMP_SMOOTHGROUPS = True<br /># Try to find the lowest autosmooth angle in vertex normals (bool)<br /># Note: i dont know if this is correct :&gt;<br />IMP_AUTOSMOOTH = False<br /><br /><br /><br /><br /><br />class Ase_group:<br />   def __init__(self):<br />      self.name = 'Name'<br />      self.ase_type = 'GROUP'<br />      self.ase_helper = None<br />      self.ase_objects = []<br /><br />class Ase_object:<br /><br />   def __init__(self, ase_object_type, name=''):<br />      #if ase_object_type not in ['GEOM','HELPER','SHAPE','LIGHT','CAMERA']: return<br />      if ase_object_type not in ['geom','helper','shape','light','camera']: return<br />      self.name = name<br />      self.ase_type = ase_object_type #GEOM, HELPER, SHAPE, LIGHT, CAMERA<br />      self.row0 = None<br />      self.row1 = None<br />      self.row2 = None<br />      self.row3 = None<br />      self.parent = None<br /><br />      #new_ase_data = None<br />      if ase_object_type == 'geom':<br />         new_ase_data = Ase_mesh(self)<br />      self.ase_data = new_ase_data<br /><br />class Ase_mesh:<br />   def __init__(self, ase_obj=None):<br />      self.name = 'Name'<br />      self.num = {'VERTS':0,'FACES':0,'CVERTEX':0,'CVFACES':0}<br />      self.ase_verts = {}<br />      self.vertseq = []<br />      self.ase_edges = {}<br />      self.ase_faces = {}<br />      self.faceseq = []<br />      self.ase_uv_channels = {}<br />      self.active_uv = None<br />      self.ase_vertcolors = {}<br />      self.ase_cfaces = {}<br />      self.autosmooth = 0<br />      self.hasUV = 0<br />      self.hasVC = 0 <br /><br />   def sort_edgekeys(self,vi0,vi1,vi2):<br />      '''<br />      Returns sorted edge keys of the given triangle vert indicies.<br />      '''<br />      if vi0 &gt; vi1: ed_k0 = vi1,vi0<br />      else: ed_k0 = vi0,vi1<br />      if vi1 &gt; vi2: ed_k1 = vi2,vi1<br />      else: ed_k1 = vi1,vi2<br />      if vi0 &gt; vi2: ed_k2 = vi2,vi0<br />      else: ed_k2 = vi0,vi2<br />      return ed_k0,ed_k1,ed_k2<br /><br />   def append_vert(self, ase_vert_index, x, y, z):<br />      '''<br />      Create a new Vertex for this Mesh.<br />      '''<br />      ase_v = Ase_vert(ase_vert_index, x, y, z)<br />      self.ase_verts[ase_vert_index] = ase_v<br />      #self.vertseq.insert(ase_vert_index, (ase_v.co.x,ase_v.co.y,ase_v.co.z))<br />      self.vertseq.insert(ase_vert_index, ase_v.co)<br />      <br />   def append_face(self, index, vi0, vi1, vi2, AB=1, BC=1, CA=1, smooth_groups=[0], mat_indices=0):<br />      '''<br />      Uhm ... work in progress!<br />      '''<br />      # create a new Ase_face<br />      ase_f = Ase_face(index, vi0, vi1, vi2, smooth_groups, mat_indices)<br />      ed_keys = self.sort_edgekeys(vi0,vi1,vi2)<br />      #ed_keys = [vi0,vi1].sort(),[vi1,vi2].sort(),[vi0,vi2].sort()<br />      ase_f.edge_keys = ed_keys<br />      ase_f.vis_sum = AB+BC+CA<br />      if ase_f.vis_sum == 2:<br />         if not AB: ase_f.tri_edge = ed_keys[0]<br />         elif not BC: ase_f.tri_edge = ed_keys[1]<br />         elif not CA: ase_f.tri_edge = ed_keys[2]<br /><br />      # set visibility (fgon) and sharp for edges<br />      # and look if the two face users might form a quad<br />      # or create a new Ase_edge<br />      for k,vis in zip(ed_keys,[AB,BC,CA]):<br />         # Ase_edge already exist or create a new one<br />         if not self.ase_edges.has_key(k):<br />            ase_ed = Ase_edge(k)<br />            ase_ed.fusers.append(ase_f.index)<br />            ase_ed.visible = vis<br />            self.ase_edges[k] = ase_ed<br />            continue<br />         else:<br />            ase_ed = self.ase_edges[k]<br />            ase_ed.fusers.append(ase_f.index)<br />            if ase_f.vis_sum == 2 and not ase_ed.visible:<br />               ase_f.tri_edge = k<br /><br />         fusers = [i for i in ase_ed.fusers if i != ase_f.index]<br />         if not fusers: continue<br />         for i in fusers:<br />            ase_f2 = self.ase_faces[i]<br />            # if this edge is invisible and both tris only have<br />            # this invisible edge, than the two tris could form a quad<br />            # easy done with a sum of all vis variables of the edges<br />            if k == ase_f.tri_edge:<br />               if ase_f.tri_edge == ase_f2.tri_edge:<br />                  ase_f.quad_team = ase_f2.index<br />                  ase_f2.quad_team = ase_f.index<br /><br />            # look if this edge is sharp<br />            # if not both faces share at least one smoothgroup var<br />            # than this edge is sharp<br />            #if ase_ed.sharp: continue<br />            for sg in smooth_groups:<br />               if sg not in ase_f2.smooth_groups:<br />                  ase_ed.sharp = True<br /><br />      self.ase_faces[ase_f.index] = ase_f<br />      self.faceseq.insert(ase_f.index, (ase_f.v0, ase_f.v1, ase_f.v2))<br /><br />   def append_uv_channel(self, layer_index=1):<br />      ''' <br />      Create a new UV Layer and set it active.<br />      '''<br />      self.ase_uv_channels[layer_index] = Ase_uv_channel(layer_index)<br />      self.active_uv = self.ase_uv_channels[layer_index]<br /><br />   def append_tvert(self, ase_uv_index, u, v, w=0):<br />      '''<br />      Create a new UV Vector in the active! UV Channel.<br />      '''<br />      if not self.active_uv: return<br />      #self.active_uv.ase_tverts[ase_uv_index] = Ase_tvert(ase_uv_index,u,v,w)<br />      self.active_uv.ase_tverts[ase_uv_index] = (u,v)<br /><br />   def append_tface(self, ase_face_index, uvi0, uvi1, uvi2, opt_check_seams=False):<br />      '''<br />      Create a new Face UV with indicies to UV Vectors in the active UV Layer.<br />      Optional check for Seams and store into the UV Channel.<br />      '''<br />      if not self.active_uv: return<br />      self.active_uv.ase_tfaces[ase_face_index] = [uvi0, uvi1, uvi2]<br />      # look if this face has seams<br />      # might useless because it makes no sense to import seams for all UV layers<br />      # that's why those edge keys are separately written to each ase UV layer<br />      if opt_check_seams:<br />         edge_keys = self.ase_faces[ase_face_index].edge_keys<br />         for ed_key,uvs in zip(edge_keys,[[uvi0,uvi1],[uvi1,uvi2],[uvi0,uvi2]]):<br />            uvs.sort()<br />            ase_ed,active_uv = self.ase_edges[ed_key],self.active_uv<br />            if not active_uv.ase_tedges.has_key(ed_key):<br />               active_uv.ase_tedges[ed_key] = uvs<br />               continue<br />            elif active_uv.ase_tedges[ed_key] != uvs:<br />               active_uv.seams.append(ed_key)<br /><br />   def append_vertcol(self, ase_color_index, r, g, b):<br />      #new = Ase_vertcolor(ase_color_index, r, g, b)<br />      #self.ase_vertcolors[ase_color_index] = new<br />      self.ase_vertcolors[ase_color_index] = (r,g,b)<br />      <br />   def append_cface(self, ase_face_index, ci0, ci1, ci2):<br />      ase_f = self.ase_faces[ase_face_index]<br />      #f.c0, f.c1, f.c2 = ci0, ci1, ci2<br />      self.ase_cfaces[ase_face_index] = (ci0, ci1, ci2)<br /><br />   def append_normal(self, ase_face_index, x, y, z):<br />      self.ase_faces[ase_face_index].normal = Blender.Mathutils.Vector(x,y,z)<br /><br />   def append_vnormal(self, ase_face_index, ase_vert_index, x, y, z, opt_check_smooth=False):<br />      ase_f = self.ase_faces[ase_face_index]<br />      self.ase_verts[ase_vert_index].normals[ase_face_index] = Blender.Mathutils.Vector(x,y,z)<br />      if opt_check_smooth and ase_f.smooth_groups:<br />         ase_edges = [self.ase_edges[key] for key in ase_f.edge_keys]<br />         for ed_key,ase_ed in zip(ase_f.edge_keys,ase_edges):<br />            if ase_ed.sharp or len(ase_ed.fusers) &lt; 2: continue<br />            for vi in ed_key:<br />               if not self.ase_verts.has_key(vi): continue<br />               vnormals = self.ase_verts[vi].normals<br />               fi0, fi1 = ase_ed.fusers[0:2]<br />               if vnormals.has_key(fi0) and vnormals.has_key(fi1):<br />                  vnor0, vnor1 = vnormals[fi0],vnormals[fi1]<br />                  if vnor0 == vnor1:<br />                     continue<br />                  else:<br />                     angle = round(Blender.Mathutils.AngleBetweenVecs(vnor0, vnor1))<br />                     if not self.autosmooth: self.autosmooth = angle<br />                     elif angle and self.autosmooth &gt; angle:<br />                        print angle<br />                        self.autosmooth = angle<br /><br /><br />class Ase_vert:<br />   def __init__(self, index, x, y, z):<br />      self.index = index<br />      #self.co = Blender.Mathutils.Vector(x,y,z)<br />      self.co = (x,y,z)<br />      self.normals = {}<br /><br />class Ase_edge:<br />   def __init__(self, key):<br />      self.key = key<br />      self.fusers = []<br />      self.uvs = None<br />      self.visible = 1<br />      self.sharp = False<br /><br />class Ase_face:<br />   def __init__(self, ase_face_index, v0, v1, v2, smooth_groups=0, mat_indices=0):<br />      self.index = ase_face_index<br />      self.v0 = v0<br />      self.v1 = v1<br />      self.v2 = v2<br />      self.edge_keys = None<br />      self.c0 = None<br />      self.c1 = None<br />      self.c2 = None<br />      self.normal = None<br />      #self.vert_normals = {}<br />      self.mat_indices = mat_indices<br />      self.smooth_groups = smooth_groups # 0 = solid face<br />      self.vis_sum = 3<br />      self.quad_team = None<br />      self.tri_edge = None<br /><br />class Ase_uv_channel:<br />   def __init__(self, index=1):<br />      self.index = index<br />      self.num = {'TVERTEX':0,'TVFACES':0}<br />      self.uv_layer_name = 'UVTex#' + str(self.index)<br />      self.ase_tverts = {}<br />      self.ase_tfaces = {}<br />      self.ase_tedges = {}<br />      self.seams = []<br /><br />class Ase_tvert:<br />   def __init__(self,index, u, v, w=0):<br />      self.index = index<br />      #self.vec = Blender.Mathutils.Vector(u,v)<br />      self.vec = (u,v)<br /><br />class Ase_tface:<br />   def __init__(self, index, uvi0, uvi1, uvi2):<br />      self.index = index<br />      self.uv = {0:uvi0, 1:uvi1, 2:uvi2}<br /><br />class Ase_vertcolor:<br />   def __init__(self, index, r, g, b):<br />      self.index = 0 <br />      self.r = round(r*256)<br />      self.g = round(g*256)<br />      self.b = round(b*256)<br />      self.a = 255.0<br /><br /><br />def spawn(ase_objects):<br /><br />   PB_index = 0.0<br />   PB_num = float(len(ase_objects))<br /><br />   print 'Import Objects...'<br />   if OPT_PROGRESSBAR: Blender.Window.DrawProgressBar(0.0, "Importing Objects...")<br /><br />   scene = Blender.Scene.GetCurrent()<br />   for ase_ob in ase_objects: <br />      if OPT_PROGRESSBAR and not (PB_index % PB_num):<br />         Blender.Window.DrawProgressBar(PB_index / PB_num, "Importing Objects...")<br /><br />      if ase_ob.ase_type == 'geom':<br />         spawn_mesh(scene,ase_ob)<br /><br />      PB_index += 1.0<br /><br />def spawn_mesh(scene,ase_ob):<br /><br />   ase_me = ase_ob.ase_data<br />   #normal_flag = 1<br /><br />   row0 = ase_ob.row0<br />   row1 = ase_ob.row1<br />   row2 = ase_ob.row2<br />   row3 = ase_ob.row3<br /><br />   matrix = Blender.Mathutils.Matrix(row0, row1, row2, row3)<br />   matrix.resize4x4()<br /><br />   # create new Blender Object and link to scene<br />   ob = Blender.Object.New('Mesh', ase_ob.name)<br />   ob.setMatrix(matrix)<br />   scene.objects.link(ob)<br /><br />   # get Mesh data from Object<br />   me = ob.getData(0,1)<br />   me.vertexColors = me.faceUV = False<br /><br />   # create Verts and Faces<br />   # seems like extend() is limited to a length of 64000?<br />   # this is a problem when importing big meshes.<br />   div = divmod(ase_me.num['VERTEX'], 64000)<br />   if div[1]: div = div[0]+1<br />   else: div = div[0]<br />   start = 0<br />   for i in range(div):<br />      end = start+64000<br />      me.verts.extend(ase_me.vertseq[start:end])<br />      start = end<br />   div = divmod(ase_me.num['FACES'], 64000)<br />   face_index_list = []<br />   if div[1]: div = div[0]+1<br />   else: div = div[0]<br />   start = 0<br />   for i in range(div):<br />      end = start+64000<br />      me.faces.extend(ase_me.faceseq[start:end])<br />      start = end<br /><br />   # import Vertex Colors, Solid/Smooth to faces<br />   if IMP_VCOLOR:<br />      me.vertexColors = ase_me.hasVC<br />      ase_vcolors = ase_me.ase_vertcolors<br />   for i,ase_f in ase_me.ase_faces.iteritems():<br />      try:f = me.faces[i]<br />      except:<br />         # dont know what's the problem with this<br />         print 'array index out of range:', i<br />         continue<br />      if me.vertexColors:<br />         cface = ase_me.ase_cfaces[i]<br />         c0,c1,c2 = ase_vcolors[cface[0]],ase_vcolors[cface[1]],ase_vcolors[cface[2]]<br />         fc0,fc1,fc2 = f.col[:]<br />         fc0.r,fc0.g,fc0.b = int(c0[0]*255),int(c0[1]*255),int(c0[2]*255)<br />         fc1.r,fc1.g,fc1.b = int(c1[0]*255),int(c1[1]*255),int(c1[2]*255)<br />         fc2.r,fc2.g,fc2.b = int(c2[0]*255),int(c2[1]*255),int(c2[2]*255)<br />      if ase_f.smooth_groups:<br />         f.smooth = 1<br /><br />   # import UV layer's<br />   if IMP_UV and ase_me.hasUV:<br />      for uv_chan in ase_me.ase_uv_channels.itervalues():<br />         me.addUVLayer(uv_chan.uv_layer_name)<br />         me.activeUVLayer = uv_chan.uv_layer_name<br />         tverts = uv_chan.ase_tverts<br />         for fi,uvis in uv_chan.ase_tfaces.iteritems():<br />            try:f = me.faces[fi]<br />            except: continue<br />            uv1,uv2,uv3 = tverts[uvis[0]],tverts[uvis[1]],tverts[uvis[2]]<br />            f.uv = [Blender.Mathutils.Vector(uv1), Blender.Mathutils.Vector(uv2), Blender.Mathutils.Vector(uv3)]<br />      me.activeUVLayer = ase_me.ase_uv_channels[1].uv_layer_name<br /><br />   # EXPERIMENTAL!<br />   # convert tris to quads<br />   # this is currently the easiest way i found without destroying uvs or vcolors<br />   # but don't work like expected...:/<br />   if IMP_QUADS:<br />      #quad_teams = set([i for i,ase_f in ase_me.ase_faces.iteritems() if ase_f.quad_team != None])<br />      quad_teams = []<br />      for i,ase_f in ase_me.ase_faces.iteritems():<br />         if ase_f.quad_team != None:<br />            if ase_f.index &lt; ase_f.quad_team: qt = ase_f.index,ase_f.quad_team<br />            elif ase_f.index &gt; ase_f.quad_team: qt = ase_f.quad_team,ase_f.index<br />            if qt not in quad_teams:<br />               quad_teams.append(qt)<br /><br />      faces = me.faces<br />      # first deselect all faces<br />      for f in faces: f.sel = 0<br />      for t0,t1 in quad_teams:<br />         ase_f0 = ase_me.ase_faces[t0]<br />         ase_f1 = ase_me.ase_faces[t1]<br />         try: f0,f1 = me.faces[ase_f0.index], me.faces[ase_f1.index]<br />         except: continue<br />         f0.sel = 1<br />         f1.sel = 1<br />         me.triangleToQuad()<br />         for i in faces.selected():<br />            faces[i].sel = 0<br /><br />   # apply the matrix to mesh (and optional fit the ob and me to blender)<br />   if IMP_SCALED:<br />      # seems this isn't accurate because of precision of the location vector<br />      scale = Blender.Mathutils.ScaleMatrix(OPT_SCALE,4)<br />      inv_matrix = ob.getMatrix().copy().invert() * scale<br />      ob.setLocation(ob.getMatrix().translationPart() * scale)<br />   else:<br />      inv_matrix = ob.getMatrix().copy().invert()<br />   me.transform(inv_matrix, 1)<br />   me.calcNormals()<br /><br />   # apply sharp, seam and fgon flags to edges.<br />   add_EDGESPLIT = False<br />   if IMP_FGONS or IMP_SEAMS or IMP_SMOOTHGROUPS:<br />      SHARP = Mesh.EdgeFlags.SHARP<br />      SEAM = Mesh.EdgeFlags.SEAM<br />      FGON = Mesh.EdgeFlags.FGON<br />      seam_keys = []<br />      if ase_me.hasUV: seam_keys = ase_me.ase_uv_channels[1].seams<br />      for k,ase_ed in ase_me.ase_edges.iteritems():<br />         if ase_ed.sharp or not ase_ed.visible or k in seam_keys:<br />            edi = me.findEdges(k[0],k[1])<br />            if edi:<br />               ed = me.edges[edi]<br />               if ase_me.hasUV and k in seam_keys and IMP_SEAMS: ed.flag |= SEAM<br />               if not ase_ed.visible and IMP_FGONS: ed.flag |= FGON<br />               if ase_ed.sharp and IMP_SMOOTHGROUPS:<br />                    ed.flag |= SHARP<br />                  add_EDGESPLIT = True<br /><br /><br /><br />   # add EdgeSplit Modiefier when the mesh has sharp edges<br />   # autosmooth is EXPERIMENTAL! because i dont know if this is correct!<br />   if add_EDGESPLIT and OPT_MOD_EDGESPLIT:<br />      mod = ob.modifiers.append(Blender.Modifier.Types.EDGESPLIT)<br />      if not ase_me.autosmooth:<br />         mod[Blender.Modifier.Settings.EDGESPLIT_FROM_ANGLE] = 0<br />      else:<br />         mod[Blender.Modifier.Settings.EDGESPLIT_ANGLE] = ase_me.autosmooth<br />      mod[Blender.Modifier.Settings.EDGESPLIT_FROM_SHARP] = 1<br />      ob.makeDisplayList() # Needed to apply the modifier<br />   elif not add_EDGESPLIT and ase_me.autosmooth:<br />      AUTOSMOOTH = Mesh.Modes.AUTOSMOOTH<br />      me.modes |= AUTOSMOOTH<br />      me.degr = ase_me.autosmooth<br /><br />   me.update()<br />   counts['verts'] += ase_me.num['VERTEX']<br />   counts['tris'] += ase_me.num['FACES']<br />   counts['faces'] += len(me.faces)<br />   print 'Imported Mesh-Object: ', ob.name<br /><br />#def oj_the_object_jockey(file):<br />def read_file(file):<br />   '''<br />   Read an .ase file and return a list of ase_objects<br />   '''<br />   lines= file.readlines()<br /><br />   print 'Read file...'<br />   PB_index = 0.0<br />   PB_num = float(len(lines))<br />   if OPT_PROGRESSBAR: Blender.Window.DrawProgressBar(0.0, "Read File...")<br /><br />   # it is needed to read UV if Seams should be imported even when importing UV is disabled<br />   READ_UV = False<br />   if IMP_UV or IMP_SEAMS: READ_UV = True<br />   #if IMP_AUTOSMOOTH and not IMP_SMOOTHGROUPS: IMP_AUTOSMOOTH = False<br /><br />   ase_objects = []<br />   ase_ob = False<br />   for line in lines:<br />      if OPT_PROGRESSBAR and not (PB_index % 10000):<br />         Blender.Window.DrawProgressBar(PB_index / PB_num, "Read File...")<br />      PB_index += 1<br /><br />      words = line.split()<br />      if not words:<br />         continue<br />      word0 = words[0]<br />      if word0 == '*GEOMOBJECT':<br />         #if ase_ob: ase_objects.append(ase_ob)<br />         ase_ob_type = word0.lower()[1:-6] #get rid of '*' and 'OBJECT'<br />         ase_ob = Ase_object(ase_ob_type)<br />         ase_objects.append(ase_ob)<br />         continue<br />      elif word0 in ['*HELPEROBJECT','*SHAPEOBJECT','*LIGHTOBJECT','*CAMERAOBJECT','*GROUP']:<br />         # Not supported objects!<br />         # because these objects too use a TM_NODE,<br />         # ase_ob should be set back to False to prevent errors.<br />         ase_ob = False<br />         continue<br />      elif word0 == '*NODE_NAME' and ase_ob:<br />         name = words[1][1:-1] #get rid of '"'<br />         if ase_ob and ase_ob.name != '': ase_ob.ase_data.name = name<br />         elif ase_ob: ase_ob.name = name<br />         continue<br />      elif word0 == '*NODE_PARENT' and ase_ob:<br />         ase_ob.parent = words[1][1:-1] #get rid of '"'<br />         continue<br />      elif word0 == '*TM_ROW0' and ase_ob:<br />         ase_ob.row0 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*TM_ROW1' and ase_ob:<br />         ase_ob.row1 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*TM_ROW2' and ase_ob:<br />         ase_ob.row2 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*TM_ROW3' and ase_ob:<br />         ase_ob.row3 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*MESH':<br />         ase_me = ase_ob.ase_data<br />         continue<br />      elif word0 == '*MESH_NUMVERTEX':<br />         ase_me.num['VERTEX'] = int(words[1])<br />         continue<br />      elif word0 == '*MESH_NUMFACES':<br />         ase_me.num['FACES'] = int(words[1])<br />         continue<br />      elif word0 == '*MESH_VERTEX':<br />         #vert_index, x, y, z<br />         ase_me.append_vert(int(words[1]),float(words[2]),float(words[3]),float(words[4]))<br />         continue<br />      elif word0 == '*MESH_FACE':<br />         #ase_face_index, vi0, vi1, vi2, AB, BC, CA, smooth_groups, mat_indicies<br />         #smooth = mat = False<br />         ase_face_index = words[1]<br />         if ase_face_index.endswith(':'):<br />            ase_face_index = ase_face_index[:-1]<br /><br />         smooth_groups = mat_indices = []<br />         for i,w in enumerate(words):<br />            if w == '*MESH_SMOOTHING' and IMP_SMOOTHGROUPS:<br />               try:<br />                  if words[i+1] != '*MESH_MTLID':<br />                     smooth_groups = [int(i) for i in words[i+1].split(',')]<br />               except:<br />                  smooth_groups = 0<br />            elif w == '*MESH_MTLID' and IMP_SMOOTHGROUPS:<br />               try:<br />                  mat_indices = [int(i) for i in words[i+1].split(',')]<br />               except:<br />                  mat_indices = 0<br />         ase_me.append_face(int(ase_face_index),int(words[3]),int(words[5]),int(words[7]),int(words[9]),int(words[11]),int(words[13]),smooth_groups,mat_indices)<br />         continue<br />      elif READ_UV:<br />         if word0 == '*MESH_NUMTVERTEX':<br />            if not ase_me.ase_uv_channels: ase_me.append_uv_channel()<br />            ase_me.active_uv.num['TVERTEX'] = int(words[1])<br />            ase_me.hasUV = True<br />            continue<br />         elif word0 == '*MESH_MAPPINGCHANNEL':<br />            # uv_channel_index<br />            ase_me.append_uv_channel(int(words[1]))<br />            continue<br />         elif word0 == '*MESH_TVERT':<br />            #uv_index, u, v, w<br />            ase_me.append_tvert(int(words[1]),float(words[2]),float(words[3]),float(words[4]))<br />            continue<br />         elif word0 == '*MESH_NUMTVFACES':<br />            ase_me.active_uv.num['TVFACES'] = int(words[1])<br />            continue<br />         elif word0 == '*MESH_TFACE':<br />            #ase_face_index, uv0, uv1, uv2, opt_IMP_SEAMS<br />            ase_face_index = words[1]<br />            if ase_face_index.endswith(':'):<br />               ase_face_index = ase_face_index[:-1]<br />            ase_me.append_tface(int(ase_face_index),int(words[2]),int(words[3]),int(words[4]),IMP_SEAMS)<br />            continue<br />      elif IMP_VCOLOR:<br />         if word0 == '*MESH_NUMCVERTEX':<br />            ase_me.num['CVERTEX'] = int(words[1])<br />            if ase_me.num['CVERTEX']:<br />               ase_me.hasVC = True<br />            continue<br />         elif word0 == '*MESH_VERTCOL':<br />            #color_index, r, g, b<br />            ase_me.append_vertcol(int(words[1]),float(words[2]),float(words[3]),float(words[4]))<br />            continue<br />         elif word0 == '*MESH_NUMCVFACES':<br />            ase_me.num['CVFACES'] = words[1]<br />            continue<br />         elif word0 == '*MESH_CFACE':<br />            #ase_face_index, ci0, ci1, ci2<br />            ase_face_index = words[1]<br />            if ase_face_index.endswith(':'):<br />               ase_face_index = ase_face_index[:-1]<br />            ase_me.append_cface(int(ase_face_index),int(words[2]),int(words[3]),int(words[4]))<br />            continue<br />      #elif word0 == '*MESH_NORMALS':<br />      elif IMP_AUTOSMOOTH:<br />         if word0 == '*MESH_FACENORMAL':<br />            # ase_face_index, x, y, z<br />            ase_face_index = int(words[1])<br />            ase_me.append_normal(ase_face_index,float(words[2]),float(words[3]),float(words[4]))<br />            continue<br />         elif word0 == '*MESH_VERTEXNORMAL':<br />            # ase_face_index, ase_vert_index, x, y, z<br />            ase_me.append_vnormal(ase_face_index,int(words[1]),float(words[2]),float(words[3]),float(words[4]),IMP_AUTOSMOOTH)<br />            continue<br />      else:<br />         continue<br />   return ase_objects<br /><br />def print_boxed(text): #Copy/Paste from meshtools, only to remove the beep :)<br />   lines = text.splitlines()<br />   maxlinelen = max(map(len, lines))<br />   if sys.platform[:3] == "win":<br />      print chr(218)+chr(196) + chr(196)*maxlinelen + chr(196)+chr(191) <br />      for line in lines: <br />         print chr(179) + ' ' + line.ljust(maxlinelen) + ' ' + chr(179) <br />      print chr(192)+chr(196) + chr(196)*maxlinelen + chr(196)+chr(217) <br />   else: <br />      print '+-' + '-'*maxlinelen + '-+' <br />      for line in lines: print '| ' + line.ljust(maxlinelen) + ' |' <br />      print '+-' + '-'*maxlinelen + '-+' <br /><br />def read(filename):<br /><br />   global counts<br />   counts = {'verts':0,'tris':0,'faces':0}<br /><br />   start = time.clock()<br /><br />   print_boxed("----------ASCII Scene Import----------")<br />   print 'Import File: ', filename<br /><br />   mode = Blender.Window.EditMode()     # are we in edit mode?  If so ...<br />   if mode: Blender.Window.EditMode(0) # leave edit mode before getting the mesh<br /><br />   file = open(filename,'r', OPT_FILE_BUFFER)<br />   ase_objects = read_file(file)<br />   file.close()<br />   spawn(ase_objects)<br />   Blender.Redraw()<br />   if OPT_PROGRESSBAR: Blender.Window.DrawProgressBar(1.0, '')  # clear progressbar<br />   # Blender.Window.EditMode(mode)<br /><br />   end = time.clock()<br />   seconds = " in %.2f %s" % (end-start, "seconds") <br />   #totals = "Imported Verts: %i Faces: %i Tris: %i " % (counts['verts'],counts['tris'],counts['faces'])<br />   #print_boxed(totals)<br />   message = "Successfully imported " + Blender.sys.basename(filename) + seconds <br />   print_boxed(message)<br /><br /><br /><br /><br />def read_ui(filename): <br /><br />   global IMPORT_SC, IMPORT_VC, IMP_UV, IMPORT_GO, IMPORT_SE, IMPORT_SM<br />   global IMP_SCALED,IMP_SMOOTHGROUPS,IMP_VCOLOR,IMP_UV,IMP_FGONS,IMP_QUADS,IMP_SEAMS,IMP_SMOOTHGROUPS,IMP_AUTOSMOOTH<br /><br />   IMPORT_SC = Blender.Draw.Create(IMP_SCALED)<br />   IMPORT_VC = Blender.Draw.Create(IMP_VCOLOR)<br />   IMP_UV = Blender.Draw.Create(IMP_UV)<br />   IMPORT_SE = Blender.Draw.Create(IMP_SEAMS)<br />   IMPORT_SM = Blender.Draw.Create(IMP_SMOOTHGROUPS)<br /><br />   # Get USER Options <br />   pup_block = [('Import Options'),('Scale Meshes', IMPORT_SC, 'Scale the Objects so that they better fit into Blender\'s grid size'),('Vertex Colors', IMPORT_VC, 'Import Vertex Colors if existing'),('UV (Layer)', IMP_UV, 'Import UV and UV layer\'s if existing'),('Smoothing', IMPORT_SM, 'Surround Smoothgroups with sharp edges'),('Seams', IMPORT_SE, 'Try to import Seams from UV islands (from the first UV layer!)')]<br /><br />   if not Blender.Draw.PupBlock('Import ASCII Scene...', pup_block):<br />      return<br /><br />   Blender.Window.WaitCursor(1)<br /><br />   IMP_SCALED = IMPORT_SC.val<br />   IMP_VCOLOR = IMPORT_VC.val<br />   IMP_UV = IMP_UV.val<br />   IMP_SEAMS = IMPORT_SE.val<br />   IMP_SMOOTHGROUPS = IMPORT_SM.val<br /><br />   read(filename)<br /><br />   Blender.Window.WaitCursor(0)<br />   Blender.Redraw()<br /><br /><br />if __name__ == '__main__' and OPT_FILESELECTOR:<br />   Blender.Window.FileSelector(read_ui, 'Import ASCII Scene', ('.ase'))<br />elif __name__ == '__main__':<br />   read_ui(OPT_STATIC_FILENAME)</div></div>

												<br /><br /><span class="gensmall">Last edited by <a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/memberlist.php?mode=viewprofile&amp;u=12761&amp;sid=6c494125f3651879278eb48965ace839">Goofos</a> on Sun Jun 17, 2007 7:00 pm, edited 5 times in total.</span>
						<br clear="all" /><br /><table width="100%" cellspacing="0"><tr valign="middle"><td class="gensmall" align="right">
														</td>
						</tr></table></td>
				</tr></table></td>
		</tr><tr class="row1"><td class="profile"><strong><a href="viewtopic.php?p=140291#wrapheader">Top</a></strong></td>
			<td><div class="gensmall" style="float: left;"> <a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/memberlist.php?mode=viewprofile&amp;u=12761&amp;sid=6c494125f3651879278eb48965ace839"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/imageset/en/icon_user_profile.gif" alt="Profile" title="Profile" /></a>  </div> <div class="gensmall" style="float: right;"> </div></td>
		</tr><tr><td class="spacer" colspan="2" height="1"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/images/spacer.gif" alt="" width="1" height="1" /></td>
	</tr></table><table class="tablebg" width="100%" cellspacing="1"><tr class="row2"><td align="center" valign="middle">
				<a name="p140320" id="p140320"></a>
				<b class="postauthor">Bittoman</b>
			</td>
			<td width="100%" height="25">
				<table width="100%" cellspacing="0"><tr><td class="gensmall" width="100%"><div style="float: left;"> <b>Post subject:</b> </div><div style="float: right;"><a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/viewtopic.php?p=140320&amp;sid=6c494125f3651879278eb48965ace839#p140320"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/imageset/icon_post_target.gif" width="12" height="9" alt="Post" title="Post" /></a><b>Posted:</b> Mon Apr 17, 2006 1:12 pm </div></td>
				</tr></table></td>
		</tr><tr class="row2"><td valign="top" class="profile">
				<table cellspacing="4" align="center" width="150"><tr><td><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/imageset/en/icon_user_offline.gif" alt="Offline" title="Offline" /></td>
				</tr><tr><td class="postdetails">True believer</td>
				</tr><tr><td><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/download/file.php?avatar=4625.jpg" width="47" height="64" alt="User avatar" /></td>
				</tr></table><span class="postdetails">
					<br /><b>Joined:</b> Sun Aug 29, 2004 10:39 pm<br /><b>Posts:</b> 1730				</span>

			</td>
			<td valign="top">
				<table width="100%" cellspacing="5"><tr><td>
					
						<div class="postbody">Nice job, thanks Goofos!</div>

					<br clear="all" /><br /><table width="100%" cellspacing="0"><tr valign="middle"><td class="gensmall" align="right">
														</td>
						</tr></table></td>
				</tr></table></td>
		</tr><tr class="row2"><td class="profile"><strong><a href="viewtopic.php?p=140291#wrapheader">Top</a></strong></td>
			<td><div class="gensmall" style="float: left;"> <a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/memberlist.php?mode=viewprofile&amp;u=4625&amp;sid=6c494125f3651879278eb48965ace839"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/imageset/en/icon_user_profile.gif" alt="Profile" title="Profile" /></a>  </div> <div class="gensmall" style="float: right;"> </div></td>
		</tr><tr><td class="spacer" colspan="2" height="1"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/images/spacer.gif" alt="" width="1" height="1" /></td>
	</tr></table><table class="tablebg" width="100%" cellspacing="1"><tr class="row1"><td align="center" valign="middle">
				<a name="p140355" id="p140355"></a>
				<b class="postauthor" style="color: #AA0000">kat</b>
			</td>
			<td width="100%" height="25">
				<table width="100%" cellspacing="0"><tr><td class="gensmall" width="100%"><div style="float: left;"> <b>Post subject:</b> </div><div style="float: right;"><a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/viewtopic.php?p=140355&amp;sid=6c494125f3651879278eb48965ace839#p140355"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/imageset/icon_post_target.gif" width="12" height="9" alt="Post" title="Post" /></a><b>Posted:</b> Mon Apr 17, 2006 10:30 pm </div></td>
				</tr></table></td>
		</tr><tr class="row1"><td valign="top" class="profile">
				<table cellspacing="4" align="center" width="150"><tr><td><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/imageset/en/icon_user_offline.gif" alt="Offline" title="Offline" /></td>
				</tr><tr><td class="postdetails">"...mostly harmless?!"</td>
				</tr><tr><td><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/download/file.php?avatar=8.gif" width="48" height="48" alt="User avatar" /></td>
				</tr></table><span class="postdetails">
					<br /><b>Joined:</b> Thu Nov 08, 2001 11:00 pm<br /><b>Posts:</b> 4940<br /><b>Location:</b> UK, York				</span>

			</td>
			<td valign="top">
				<table width="100%" cellspacing="5"><tr><td>




<!--
     FILE ARCHIVED ON 18:15:16 May 9, 2007 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 0:06:48 Sep 26, 2014.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
--></td></tr></table></td></tr></table></div></div></body>
</html>
]]></body></post><post id="p140291" date="Posted: Mon Apr 17, 2006 2:00 am "><author>Goofos</author><body><![CDATA[<div class="postbody"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/images/smilies/icon_arrow.gif" alt=":arrow:" title="Arrow" /> Version: 0.13
<br /><br />Supports Mesh Objects with vertex colors, multiple UV, smoothgroups.
<br /><br />A little Note!: you should not try to import very big ase files (&gt;50 MB with 512 MB RAM). With much RAM you might can try this.
<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">#!BPY<br /><br />"""<br />Name: 'ASCII Scene (.ase) v0.13'<br />Blender: 244<br />Group: 'Import'<br />Tooltip: 'Import from ASCII Scene Export file format (.ase)'<br />""" <br />__author__ = "Goofos"<br />__version__ = "0.13"<br /><br /># goofos<br />#<br /># ***** BEGIN GPL LICENSE BLOCK *****<br />#<br /># This program is free software; you can redistribute it and/or<br /># modify it under the terms of the GNU General Public License<br /># as published by the Free Software Foundation; either version 2<br /># of the License, or (at your option) any later version.<br /># <br /># This program is distributed in the hope that it will be useful,<br /># but WITHOUT ANY WARRANTY; without even the implied warranty of<br /># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<br /># GNU General Public License for more details.<br /># <br /># You should have received a copy of the GNU General Public License<br /># along with this program; if not, write to the Free Software Foundation,<br /># Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.<br /># <br /># ***** END GPL LICENCE BLOCK *****<br /><br />import time, sys<br />import Blender<br />from Blender import Scene, Object, Mesh<br /><br />'''<br />Some Options<br />'''<br /># Scale Factor (float)<br />OPT_SCALE = 0.1<br /># Add EdgeSplit Modifier when importing sharp edges (bool)<br />OPT_MOD_EDGESPLIT = True<br /># Enable the fileselector (bool)<br />OPT_FILESELECTOR = True<br /># If the fileselector is disabled, specify a static filename (string)<br />OPT_STATIC_FILENAME = 'E:\ASE Files\garage.ASE'<br /># Enable Progressbar (bool)<br />OPT_PROGRESSBAR = False<br /># File buffer. After testing with big files i think there is no real difference.<br /># -1 = system default, 0 = unbuffered, 1 = line buffered, &gt;1 = buffer size<br />OPT_FILE_BUFFER = -1<br /><br />'''<br />Import Options<br />'''<br /># Import Meshes scaled, defined by the scale factor of OPT_SCALE (bool)<br /># Note: Object location data looses some precision, .. i think!<br />IMP_SCALED = True<br /># Import Vertex Colors (bool)<br />IMP_VCOLOR = True<br /># Import UV Coords and UV layers (bool)<br />IMP_UV = True<br /># Import NGons as Blender FGons (bool)<br /># Note: Include quads, too.<br />IMP_FGONS = False<br /># Try to find possible quads and convert the two tris to a quad (bool)<br /># Note: Very slow!! ablsolutely doesn't work accurate :/<br /># i don't know wether this is a script problem or a blender problem!<br />IMP_QUADS = False<br /># Surround UV islands with seams (bool)<br />IMP_SEAMS = False<br /># Surround smooth groups with sharp edges (bool)<br />IMP_SMOOTHGROUPS = True<br /># Try to find the lowest autosmooth angle in vertex normals (bool)<br /># Note: i dont know if this is correct :&gt;<br />IMP_AUTOSMOOTH = False<br /><br /><br /><br /><br /><br />class Ase_group:<br />   def __init__(self):<br />      self.name = 'Name'<br />      self.ase_type = 'GROUP'<br />      self.ase_helper = None<br />      self.ase_objects = []<br /><br />class Ase_object:<br /><br />   def __init__(self, ase_object_type, name=''):<br />      #if ase_object_type not in ['GEOM','HELPER','SHAPE','LIGHT','CAMERA']: return<br />      if ase_object_type not in ['geom','helper','shape','light','camera']: return<br />      self.name = name<br />      self.ase_type = ase_object_type #GEOM, HELPER, SHAPE, LIGHT, CAMERA<br />      self.row0 = None<br />      self.row1 = None<br />      self.row2 = None<br />      self.row3 = None<br />      self.parent = None<br /><br />      #new_ase_data = None<br />      if ase_object_type == 'geom':<br />         new_ase_data = Ase_mesh(self)<br />      self.ase_data = new_ase_data<br /><br />class Ase_mesh:<br />   def __init__(self, ase_obj=None):<br />      self.name = 'Name'<br />      self.num = {'VERTS':0,'FACES':0,'CVERTEX':0,'CVFACES':0}<br />      self.ase_verts = {}<br />      self.vertseq = []<br />      self.ase_edges = {}<br />      self.ase_faces = {}<br />      self.faceseq = []<br />      self.ase_uv_channels = {}<br />      self.active_uv = None<br />      self.ase_vertcolors = {}<br />      self.ase_cfaces = {}<br />      self.autosmooth = 0<br />      self.hasUV = 0<br />      self.hasVC = 0 <br /><br />   def sort_edgekeys(self,vi0,vi1,vi2):<br />      '''<br />      Returns sorted edge keys of the given triangle vert indicies.<br />      '''<br />      if vi0 &gt; vi1: ed_k0 = vi1,vi0<br />      else: ed_k0 = vi0,vi1<br />      if vi1 &gt; vi2: ed_k1 = vi2,vi1<br />      else: ed_k1 = vi1,vi2<br />      if vi0 &gt; vi2: ed_k2 = vi2,vi0<br />      else: ed_k2 = vi0,vi2<br />      return ed_k0,ed_k1,ed_k2<br /><br />   def append_vert(self, ase_vert_index, x, y, z):<br />      '''<br />      Create a new Vertex for this Mesh.<br />      '''<br />      ase_v = Ase_vert(ase_vert_index, x, y, z)<br />      self.ase_verts[ase_vert_index] = ase_v<br />      #self.vertseq.insert(ase_vert_index, (ase_v.co.x,ase_v.co.y,ase_v.co.z))<br />      self.vertseq.insert(ase_vert_index, ase_v.co)<br />      <br />   def append_face(self, index, vi0, vi1, vi2, AB=1, BC=1, CA=1, smooth_groups=[0], mat_indices=0):<br />      '''<br />      Uhm ... work in progress!<br />      '''<br />      # create a new Ase_face<br />      ase_f = Ase_face(index, vi0, vi1, vi2, smooth_groups, mat_indices)<br />      ed_keys = self.sort_edgekeys(vi0,vi1,vi2)<br />      #ed_keys = [vi0,vi1].sort(),[vi1,vi2].sort(),[vi0,vi2].sort()<br />      ase_f.edge_keys = ed_keys<br />      ase_f.vis_sum = AB+BC+CA<br />      if ase_f.vis_sum == 2:<br />         if not AB: ase_f.tri_edge = ed_keys[0]<br />         elif not BC: ase_f.tri_edge = ed_keys[1]<br />         elif not CA: ase_f.tri_edge = ed_keys[2]<br /><br />      # set visibility (fgon) and sharp for edges<br />      # and look if the two face users might form a quad<br />      # or create a new Ase_edge<br />      for k,vis in zip(ed_keys,[AB,BC,CA]):<br />         # Ase_edge already exist or create a new one<br />         if not self.ase_edges.has_key(k):<br />            ase_ed = Ase_edge(k)<br />            ase_ed.fusers.append(ase_f.index)<br />            ase_ed.visible = vis<br />            self.ase_edges[k] = ase_ed<br />            continue<br />         else:<br />            ase_ed = self.ase_edges[k]<br />            ase_ed.fusers.append(ase_f.index)<br />            if ase_f.vis_sum == 2 and not ase_ed.visible:<br />               ase_f.tri_edge = k<br /><br />         fusers = [i for i in ase_ed.fusers if i != ase_f.index]<br />         if not fusers: continue<br />         for i in fusers:<br />            ase_f2 = self.ase_faces[i]<br />            # if this edge is invisible and both tris only have<br />            # this invisible edge, than the two tris could form a quad<br />            # easy done with a sum of all vis variables of the edges<br />            if k == ase_f.tri_edge:<br />               if ase_f.tri_edge == ase_f2.tri_edge:<br />                  ase_f.quad_team = ase_f2.index<br />                  ase_f2.quad_team = ase_f.index<br /><br />            # look if this edge is sharp<br />            # if not both faces share at least one smoothgroup var<br />            # than this edge is sharp<br />            #if ase_ed.sharp: continue<br />            for sg in smooth_groups:<br />               if sg not in ase_f2.smooth_groups:<br />                  ase_ed.sharp = True<br /><br />      self.ase_faces[ase_f.index] = ase_f<br />      self.faceseq.insert(ase_f.index, (ase_f.v0, ase_f.v1, ase_f.v2))<br /><br />   def append_uv_channel(self, layer_index=1):<br />      ''' <br />      Create a new UV Layer and set it active.<br />      '''<br />      self.ase_uv_channels[layer_index] = Ase_uv_channel(layer_index)<br />      self.active_uv = self.ase_uv_channels[layer_index]<br /><br />   def append_tvert(self, ase_uv_index, u, v, w=0):<br />      '''<br />      Create a new UV Vector in the active! UV Channel.<br />      '''<br />      if not self.active_uv: return<br />      #self.active_uv.ase_tverts[ase_uv_index] = Ase_tvert(ase_uv_index,u,v,w)<br />      self.active_uv.ase_tverts[ase_uv_index] = (u,v)<br /><br />   def append_tface(self, ase_face_index, uvi0, uvi1, uvi2, opt_check_seams=False):<br />      '''<br />      Create a new Face UV with indicies to UV Vectors in the active UV Layer.<br />      Optional check for Seams and store into the UV Channel.<br />      '''<br />      if not self.active_uv: return<br />      self.active_uv.ase_tfaces[ase_face_index] = [uvi0, uvi1, uvi2]<br />      # look if this face has seams<br />      # might useless because it makes no sense to import seams for all UV layers<br />      # that's why those edge keys are separately written to each ase UV layer<br />      if opt_check_seams:<br />         edge_keys = self.ase_faces[ase_face_index].edge_keys<br />         for ed_key,uvs in zip(edge_keys,[[uvi0,uvi1],[uvi1,uvi2],[uvi0,uvi2]]):<br />            uvs.sort()<br />            ase_ed,active_uv = self.ase_edges[ed_key],self.active_uv<br />            if not active_uv.ase_tedges.has_key(ed_key):<br />               active_uv.ase_tedges[ed_key] = uvs<br />               continue<br />            elif active_uv.ase_tedges[ed_key] != uvs:<br />               active_uv.seams.append(ed_key)<br /><br />   def append_vertcol(self, ase_color_index, r, g, b):<br />      #new = Ase_vertcolor(ase_color_index, r, g, b)<br />      #self.ase_vertcolors[ase_color_index] = new<br />      self.ase_vertcolors[ase_color_index] = (r,g,b)<br />      <br />   def append_cface(self, ase_face_index, ci0, ci1, ci2):<br />      ase_f = self.ase_faces[ase_face_index]<br />      #f.c0, f.c1, f.c2 = ci0, ci1, ci2<br />      self.ase_cfaces[ase_face_index] = (ci0, ci1, ci2)<br /><br />   def append_normal(self, ase_face_index, x, y, z):<br />      self.ase_faces[ase_face_index].normal = Blender.Mathutils.Vector(x,y,z)<br /><br />   def append_vnormal(self, ase_face_index, ase_vert_index, x, y, z, opt_check_smooth=False):<br />      ase_f = self.ase_faces[ase_face_index]<br />      self.ase_verts[ase_vert_index].normals[ase_face_index] = Blender.Mathutils.Vector(x,y,z)<br />      if opt_check_smooth and ase_f.smooth_groups:<br />         ase_edges = [self.ase_edges[key] for key in ase_f.edge_keys]<br />         for ed_key,ase_ed in zip(ase_f.edge_keys,ase_edges):<br />            if ase_ed.sharp or len(ase_ed.fusers) &lt; 2: continue<br />            for vi in ed_key:<br />               if not self.ase_verts.has_key(vi): continue<br />               vnormals = self.ase_verts[vi].normals<br />               fi0, fi1 = ase_ed.fusers[0:2]<br />               if vnormals.has_key(fi0) and vnormals.has_key(fi1):<br />                  vnor0, vnor1 = vnormals[fi0],vnormals[fi1]<br />                  if vnor0 == vnor1:<br />                     continue<br />                  else:<br />                     angle = round(Blender.Mathutils.AngleBetweenVecs(vnor0, vnor1))<br />                     if not self.autosmooth: self.autosmooth = angle<br />                     elif angle and self.autosmooth &gt; angle:<br />                        print angle<br />                        self.autosmooth = angle<br /><br /><br />class Ase_vert:<br />   def __init__(self, index, x, y, z):<br />      self.index = index<br />      #self.co = Blender.Mathutils.Vector(x,y,z)<br />      self.co = (x,y,z)<br />      self.normals = {}<br /><br />class Ase_edge:<br />   def __init__(self, key):<br />      self.key = key<br />      self.fusers = []<br />      self.uvs = None<br />      self.visible = 1<br />      self.sharp = False<br /><br />class Ase_face:<br />   def __init__(self, ase_face_index, v0, v1, v2, smooth_groups=0, mat_indices=0):<br />      self.index = ase_face_index<br />      self.v0 = v0<br />      self.v1 = v1<br />      self.v2 = v2<br />      self.edge_keys = None<br />      self.c0 = None<br />      self.c1 = None<br />      self.c2 = None<br />      self.normal = None<br />      #self.vert_normals = {}<br />      self.mat_indices = mat_indices<br />      self.smooth_groups = smooth_groups # 0 = solid face<br />      self.vis_sum = 3<br />      self.quad_team = None<br />      self.tri_edge = None<br /><br />class Ase_uv_channel:<br />   def __init__(self, index=1):<br />      self.index = index<br />      self.num = {'TVERTEX':0,'TVFACES':0}<br />      self.uv_layer_name = 'UVTex#' + str(self.index)<br />      self.ase_tverts = {}<br />      self.ase_tfaces = {}<br />      self.ase_tedges = {}<br />      self.seams = []<br /><br />class Ase_tvert:<br />   def __init__(self,index, u, v, w=0):<br />      self.index = index<br />      #self.vec = Blender.Mathutils.Vector(u,v)<br />      self.vec = (u,v)<br /><br />class Ase_tface:<br />   def __init__(self, index, uvi0, uvi1, uvi2):<br />      self.index = index<br />      self.uv = {0:uvi0, 1:uvi1, 2:uvi2}<br /><br />class Ase_vertcolor:<br />   def __init__(self, index, r, g, b):<br />      self.index = 0 <br />      self.r = round(r*256)<br />      self.g = round(g*256)<br />      self.b = round(b*256)<br />      self.a = 255.0<br /><br /><br />def spawn(ase_objects):<br /><br />   PB_index = 0.0<br />   PB_num = float(len(ase_objects))<br /><br />   print 'Import Objects...'<br />   if OPT_PROGRESSBAR: Blender.Window.DrawProgressBar(0.0, "Importing Objects...")<br /><br />   scene = Blender.Scene.GetCurrent()<br />   for ase_ob in ase_objects: <br />      if OPT_PROGRESSBAR and not (PB_index % PB_num):<br />         Blender.Window.DrawProgressBar(PB_index / PB_num, "Importing Objects...")<br /><br />      if ase_ob.ase_type == 'geom':<br />         spawn_mesh(scene,ase_ob)<br /><br />      PB_index += 1.0<br /><br />def spawn_mesh(scene,ase_ob):<br /><br />   ase_me = ase_ob.ase_data<br />   #normal_flag = 1<br /><br />   row0 = ase_ob.row0<br />   row1 = ase_ob.row1<br />   row2 = ase_ob.row2<br />   row3 = ase_ob.row3<br /><br />   matrix = Blender.Mathutils.Matrix(row0, row1, row2, row3)<br />   matrix.resize4x4()<br /><br />   # create new Blender Object and link to scene<br />   ob = Blender.Object.New('Mesh', ase_ob.name)<br />   ob.setMatrix(matrix)<br />   scene.objects.link(ob)<br /><br />   # get Mesh data from Object<br />   me = ob.getData(0,1)<br />   me.vertexColors = me.faceUV = False<br /><br />   # create Verts and Faces<br />   # seems like extend() is limited to a length of 64000?<br />   # this is a problem when importing big meshes.<br />   div = divmod(ase_me.num['VERTEX'], 64000)<br />   if div[1]: div = div[0]+1<br />   else: div = div[0]<br />   start = 0<br />   for i in range(div):<br />      end = start+64000<br />      me.verts.extend(ase_me.vertseq[start:end])<br />      start = end<br />   div = divmod(ase_me.num['FACES'], 64000)<br />   face_index_list = []<br />   if div[1]: div = div[0]+1<br />   else: div = div[0]<br />   start = 0<br />   for i in range(div):<br />      end = start+64000<br />      me.faces.extend(ase_me.faceseq[start:end])<br />      start = end<br /><br />   # import Vertex Colors, Solid/Smooth to faces<br />   if IMP_VCOLOR:<br />      me.vertexColors = ase_me.hasVC<br />      ase_vcolors = ase_me.ase_vertcolors<br />   for i,ase_f in ase_me.ase_faces.iteritems():<br />      try:f = me.faces[i]<br />      except:<br />         # dont know what's the problem with this<br />         print 'array index out of range:', i<br />         continue<br />      if me.vertexColors:<br />         cface = ase_me.ase_cfaces[i]<br />         c0,c1,c2 = ase_vcolors[cface[0]],ase_vcolors[cface[1]],ase_vcolors[cface[2]]<br />         fc0,fc1,fc2 = f.col[:]<br />         fc0.r,fc0.g,fc0.b = int(c0[0]*255),int(c0[1]*255),int(c0[2]*255)<br />         fc1.r,fc1.g,fc1.b = int(c1[0]*255),int(c1[1]*255),int(c1[2]*255)<br />         fc2.r,fc2.g,fc2.b = int(c2[0]*255),int(c2[1]*255),int(c2[2]*255)<br />      if ase_f.smooth_groups:<br />         f.smooth = 1<br /><br />   # import UV layer's<br />   if IMP_UV and ase_me.hasUV:<br />      for uv_chan in ase_me.ase_uv_channels.itervalues():<br />         me.addUVLayer(uv_chan.uv_layer_name)<br />         me.activeUVLayer = uv_chan.uv_layer_name<br />         tverts = uv_chan.ase_tverts<br />         for fi,uvis in uv_chan.ase_tfaces.iteritems():<br />            try:f = me.faces[fi]<br />            except: continue<br />            uv1,uv2,uv3 = tverts[uvis[0]],tverts[uvis[1]],tverts[uvis[2]]<br />            f.uv = [Blender.Mathutils.Vector(uv1), Blender.Mathutils.Vector(uv2), Blender.Mathutils.Vector(uv3)]<br />      me.activeUVLayer = ase_me.ase_uv_channels[1].uv_layer_name<br /><br />   # EXPERIMENTAL!<br />   # convert tris to quads<br />   # this is currently the easiest way i found without destroying uvs or vcolors<br />   # but don't work like expected...:/<br />   if IMP_QUADS:<br />      #quad_teams = set([i for i,ase_f in ase_me.ase_faces.iteritems() if ase_f.quad_team != None])<br />      quad_teams = []<br />      for i,ase_f in ase_me.ase_faces.iteritems():<br />         if ase_f.quad_team != None:<br />            if ase_f.index &lt; ase_f.quad_team: qt = ase_f.index,ase_f.quad_team<br />            elif ase_f.index &gt; ase_f.quad_team: qt = ase_f.quad_team,ase_f.index<br />            if qt not in quad_teams:<br />               quad_teams.append(qt)<br /><br />      faces = me.faces<br />      # first deselect all faces<br />      for f in faces: f.sel = 0<br />      for t0,t1 in quad_teams:<br />         ase_f0 = ase_me.ase_faces[t0]<br />         ase_f1 = ase_me.ase_faces[t1]<br />         try: f0,f1 = me.faces[ase_f0.index], me.faces[ase_f1.index]<br />         except: continue<br />         f0.sel = 1<br />         f1.sel = 1<br />         me.triangleToQuad()<br />         for i in faces.selected():<br />            faces[i].sel = 0<br /><br />   # apply the matrix to mesh (and optional fit the ob and me to blender)<br />   if IMP_SCALED:<br />      # seems this isn't accurate because of precision of the location vector<br />      scale = Blender.Mathutils.ScaleMatrix(OPT_SCALE,4)<br />      inv_matrix = ob.getMatrix().copy().invert() * scale<br />      ob.setLocation(ob.getMatrix().translationPart() * scale)<br />   else:<br />      inv_matrix = ob.getMatrix().copy().invert()<br />   me.transform(inv_matrix, 1)<br />   me.calcNormals()<br /><br />   # apply sharp, seam and fgon flags to edges.<br />   add_EDGESPLIT = False<br />   if IMP_FGONS or IMP_SEAMS or IMP_SMOOTHGROUPS:<br />      SHARP = Mesh.EdgeFlags.SHARP<br />      SEAM = Mesh.EdgeFlags.SEAM<br />      FGON = Mesh.EdgeFlags.FGON<br />      seam_keys = []<br />      if ase_me.hasUV: seam_keys = ase_me.ase_uv_channels[1].seams<br />      for k,ase_ed in ase_me.ase_edges.iteritems():<br />         if ase_ed.sharp or not ase_ed.visible or k in seam_keys:<br />            edi = me.findEdges(k[0],k[1])<br />            if edi:<br />               ed = me.edges[edi]<br />               if ase_me.hasUV and k in seam_keys and IMP_SEAMS: ed.flag |= SEAM<br />               if not ase_ed.visible and IMP_FGONS: ed.flag |= FGON<br />               if ase_ed.sharp and IMP_SMOOTHGROUPS:<br />                    ed.flag |= SHARP<br />                  add_EDGESPLIT = True<br /><br /><br /><br />   # add EdgeSplit Modiefier when the mesh has sharp edges<br />   # autosmooth is EXPERIMENTAL! because i dont know if this is correct!<br />   if add_EDGESPLIT and OPT_MOD_EDGESPLIT:<br />      mod = ob.modifiers.append(Blender.Modifier.Types.EDGESPLIT)<br />      if not ase_me.autosmooth:<br />         mod[Blender.Modifier.Settings.EDGESPLIT_FROM_ANGLE] = 0<br />      else:<br />         mod[Blender.Modifier.Settings.EDGESPLIT_ANGLE] = ase_me.autosmooth<br />      mod[Blender.Modifier.Settings.EDGESPLIT_FROM_SHARP] = 1<br />      ob.makeDisplayList() # Needed to apply the modifier<br />   elif not add_EDGESPLIT and ase_me.autosmooth:<br />      AUTOSMOOTH = Mesh.Modes.AUTOSMOOTH<br />      me.modes |= AUTOSMOOTH<br />      me.degr = ase_me.autosmooth<br /><br />   me.update()<br />   counts['verts'] += ase_me.num['VERTEX']<br />   counts['tris'] += ase_me.num['FACES']<br />   counts['faces'] += len(me.faces)<br />   print 'Imported Mesh-Object: ', ob.name<br /><br />#def oj_the_object_jockey(file):<br />def read_file(file):<br />   '''<br />   Read an .ase file and return a list of ase_objects<br />   '''<br />   lines= file.readlines()<br /><br />   print 'Read file...'<br />   PB_index = 0.0<br />   PB_num = float(len(lines))<br />   if OPT_PROGRESSBAR: Blender.Window.DrawProgressBar(0.0, "Read File...")<br /><br />   # it is needed to read UV if Seams should be imported even when importing UV is disabled<br />   READ_UV = False<br />   if IMP_UV or IMP_SEAMS: READ_UV = True<br />   #if IMP_AUTOSMOOTH and not IMP_SMOOTHGROUPS: IMP_AUTOSMOOTH = False<br /><br />   ase_objects = []<br />   ase_ob = False<br />   for line in lines:<br />      if OPT_PROGRESSBAR and not (PB_index % 10000):<br />         Blender.Window.DrawProgressBar(PB_index / PB_num, "Read File...")<br />      PB_index += 1<br /><br />      words = line.split()<br />      if not words:<br />         continue<br />      word0 = words[0]<br />      if word0 == '*GEOMOBJECT':<br />         #if ase_ob: ase_objects.append(ase_ob)<br />         ase_ob_type = word0.lower()[1:-6] #get rid of '*' and 'OBJECT'<br />         ase_ob = Ase_object(ase_ob_type)<br />         ase_objects.append(ase_ob)<br />         continue<br />      elif word0 in ['*HELPEROBJECT','*SHAPEOBJECT','*LIGHTOBJECT','*CAMERAOBJECT','*GROUP']:<br />         # Not supported objects!<br />         # because these objects too use a TM_NODE,<br />         # ase_ob should be set back to False to prevent errors.<br />         ase_ob = False<br />         continue<br />      elif word0 == '*NODE_NAME' and ase_ob:<br />         name = words[1][1:-1] #get rid of '"'<br />         if ase_ob and ase_ob.name != '': ase_ob.ase_data.name = name<br />         elif ase_ob: ase_ob.name = name<br />         continue<br />      elif word0 == '*NODE_PARENT' and ase_ob:<br />         ase_ob.parent = words[1][1:-1] #get rid of '"'<br />         continue<br />      elif word0 == '*TM_ROW0' and ase_ob:<br />         ase_ob.row0 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*TM_ROW1' and ase_ob:<br />         ase_ob.row1 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*TM_ROW2' and ase_ob:<br />         ase_ob.row2 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*TM_ROW3' and ase_ob:<br />         ase_ob.row3 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*MESH':<br />         ase_me = ase_ob.ase_data<br />         continue<br />      elif word0 == '*MESH_NUMVERTEX':<br />         ase_me.num['VERTEX'] = int(words[1])<br />         continue<br />      elif word0 == '*MESH_NUMFACES':<br />         ase_me.num['FACES'] = int(words[1])<br />         continue<br />      elif word0 == '*MESH_VERTEX':<br />         #vert_index, x, y, z<br />         ase_me.append_vert(int(words[1]),float(words[2]),float(words[3]),float(words[4]))<br />         continue<br />      elif word0 == '*MESH_FACE':<br />         #ase_face_index, vi0, vi1, vi2, AB, BC, CA, smooth_groups, mat_indicies<br />         #smooth = mat = False<br />         ase_face_index = words[1]<br />         if ase_face_index.endswith(':'):<br />            ase_face_index = ase_face_index[:-1]<br /><br />         smooth_groups = mat_indices = []<br />         for i,w in enumerate(words):<br />            if w == '*MESH_SMOOTHING' and IMP_SMOOTHGROUPS:<br />               try:<br />                  if words[i+1] != '*MESH_MTLID':<br />                     smooth_groups = [int(i) for i in words[i+1].split(',')]<br />               except:<br />                  smooth_groups = 0<br />            elif w == '*MESH_MTLID' and IMP_SMOOTHGROUPS:<br />               try:<br />                  mat_indices = [int(i) for i in words[i+1].split(',')]<br />               except:<br />                  mat_indices = 0<br />         ase_me.append_face(int(ase_face_index),int(words[3]),int(words[5]),int(words[7]),int(words[9]),int(words[11]),int(words[13]),smooth_groups,mat_indices)<br />         continue<br />      elif READ_UV:<br />         if word0 == '*MESH_NUMTVERTEX':<br />            if not ase_me.ase_uv_channels: ase_me.append_uv_channel()<br />            ase_me.active_uv.num['TVERTEX'] = int(words[1])<br />            ase_me.hasUV = True<br />            continue<br />         elif word0 == '*MESH_MAPPINGCHANNEL':<br />            # uv_channel_index<br />            ase_me.append_uv_channel(int(words[1]))<br />            continue<br />         elif word0 == '*MESH_TVERT':<br />            #uv_index, u, v, w<br />            ase_me.append_tvert(int(words[1]),float(words[2]),float(words[3]),float(words[4]))<br />            continue<br />         elif word0 == '*MESH_NUMTVFACES':<br />            ase_me.active_uv.num['TVFACES'] = int(words[1])<br />            continue<br />         elif word0 == '*MESH_TFACE':<br />            #ase_face_index, uv0, uv1, uv2, opt_IMP_SEAMS<br />            ase_face_index = words[1]<br />            if ase_face_index.endswith(':'):<br />               ase_face_index = ase_face_index[:-1]<br />            ase_me.append_tface(int(ase_face_index),int(words[2]),int(words[3]),int(words[4]),IMP_SEAMS)<br />            continue<br />      elif IMP_VCOLOR:<br />         if word0 == '*MESH_NUMCVERTEX':<br />            ase_me.num['CVERTEX'] = int(words[1])<br />            if ase_me.num['CVERTEX']:<br />               ase_me.hasVC = True<br />            continue<br />         elif word0 == '*MESH_VERTCOL':<br />            #color_index, r, g, b<br />            ase_me.append_vertcol(int(words[1]),float(words[2]),float(words[3]),float(words[4]))<br />            continue<br />         elif word0 == '*MESH_NUMCVFACES':<br />            ase_me.num['CVFACES'] = words[1]<br />            continue<br />         elif word0 == '*MESH_CFACE':<br />            #ase_face_index, ci0, ci1, ci2<br />            ase_face_index = words[1]<br />            if ase_face_index.endswith(':'):<br />               ase_face_index = ase_face_index[:-1]<br />            ase_me.append_cface(int(ase_face_index),int(words[2]),int(words[3]),int(words[4]))<br />            continue<br />      #elif word0 == '*MESH_NORMALS':<br />      elif IMP_AUTOSMOOTH:<br />         if word0 == '*MESH_FACENORMAL':<br />            # ase_face_index, x, y, z<br />            ase_face_index = int(words[1])<br />            ase_me.append_normal(ase_face_index,float(words[2]),float(words[3]),float(words[4]))<br />            continue<br />         elif word0 == '*MESH_VERTEXNORMAL':<br />            # ase_face_index, ase_vert_index, x, y, z<br />            ase_me.append_vnormal(ase_face_index,int(words[1]),float(words[2]),float(words[3]),float(words[4]),IMP_AUTOSMOOTH)<br />            continue<br />      else:<br />         continue<br />   return ase_objects<br /><br />def print_boxed(text): #Copy/Paste from meshtools, only to remove the beep :)<br />   lines = text.splitlines()<br />   maxlinelen = max(map(len, lines))<br />   if sys.platform[:3] == "win":<br />      print chr(218)+chr(196) + chr(196)*maxlinelen + chr(196)+chr(191) <br />      for line in lines: <br />         print chr(179) + ' ' + line.ljust(maxlinelen) + ' ' + chr(179) <br />      print chr(192)+chr(196) + chr(196)*maxlinelen + chr(196)+chr(217) <br />   else: <br />      print '+-' + '-'*maxlinelen + '-+' <br />      for line in lines: print '| ' + line.ljust(maxlinelen) + ' |' <br />      print '+-' + '-'*maxlinelen + '-+' <br /><br />def read(filename):<br /><br />   global counts<br />   counts = {'verts':0,'tris':0,'faces':0}<br /><br />   start = time.clock()<br /><br />   print_boxed("----------ASCII Scene Import----------")<br />   print 'Import File: ', filename<br /><br />   mode = Blender.Window.EditMode()     # are we in edit mode?  If so ...<br />   if mode: Blender.Window.EditMode(0) # leave edit mode before getting the mesh<br /><br />   file = open(filename,'r', OPT_FILE_BUFFER)<br />   ase_objects = read_file(file)<br />   file.close()<br />   spawn(ase_objects)<br />   Blender.Redraw()<br />   if OPT_PROGRESSBAR: Blender.Window.DrawProgressBar(1.0, '')  # clear progressbar<br />   # Blender.Window.EditMode(mode)<br /><br />   end = time.clock()<br />   seconds = " in %.2f %s" % (end-start, "seconds") <br />   #totals = "Imported Verts: %i Faces: %i Tris: %i " % (counts['verts'],counts['tris'],counts['faces'])<br />   #print_boxed(totals)<br />   message = "Successfully imported " + Blender.sys.basename(filename) + seconds <br />   print_boxed(message)<br /><br /><br /><br /><br />def read_ui(filename): <br /><br />   global IMPORT_SC, IMPORT_VC, IMP_UV, IMPORT_GO, IMPORT_SE, IMPORT_SM<br />   global IMP_SCALED,IMP_SMOOTHGROUPS,IMP_VCOLOR,IMP_UV,IMP_FGONS,IMP_QUADS,IMP_SEAMS,IMP_SMOOTHGROUPS,IMP_AUTOSMOOTH<br /><br />   IMPORT_SC = Blender.Draw.Create(IMP_SCALED)<br />   IMPORT_VC = Blender.Draw.Create(IMP_VCOLOR)<br />   IMP_UV = Blender.Draw.Create(IMP_UV)<br />   IMPORT_SE = Blender.Draw.Create(IMP_SEAMS)<br />   IMPORT_SM = Blender.Draw.Create(IMP_SMOOTHGROUPS)<br /><br />   # Get USER Options <br />   pup_block = [('Import Options'),('Scale Meshes', IMPORT_SC, 'Scale the Objects so that they better fit into Blender\'s grid size'),('Vertex Colors', IMPORT_VC, 'Import Vertex Colors if existing'),('UV (Layer)', IMP_UV, 'Import UV and UV layer\'s if existing'),('Smoothing', IMPORT_SM, 'Surround Smoothgroups with sharp edges'),('Seams', IMPORT_SE, 'Try to import Seams from UV islands (from the first UV layer!)')]<br /><br />   if not Blender.Draw.PupBlock('Import ASCII Scene...', pup_block):<br />      return<br /><br />   Blender.Window.WaitCursor(1)<br /><br />   IMP_SCALED = IMPORT_SC.val<br />   IMP_VCOLOR = IMPORT_VC.val<br />   IMP_UV = IMP_UV.val<br />   IMP_SEAMS = IMPORT_SE.val<br />   IMP_SMOOTHGROUPS = IMPORT_SM.val<br /><br />   read(filename)<br /><br />   Blender.Window.WaitCursor(0)<br />   Blender.Redraw()<br /><br /><br />if __name__ == '__main__' and OPT_FILESELECTOR:<br />   Blender.Window.FileSelector(read_ui, 'Import ASCII Scene', ('.ase'))<br />elif __name__ == '__main__':<br />   read_ui(OPT_STATIC_FILENAME)</div></div>]]></body></post><post id="p140320" date="Posted: Mon Apr 17, 2006 1:12 pm "><author>Bittoman</author><body><![CDATA[<div class="postbody">Nice job, thanks Goofos!</div>]]></body></post><post id="p140355" date="Posted: Mon Apr 17, 2006 10:30 pm "><author>kat</author><body><![CDATA[<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en-gb" xml:lang="en-gb" xml:lang="en-gb">
  <head>
    <script type="text/javascript" src="https://web.archive.org/static/js/analytics.js"></script>
    <link type="text/css" rel="stylesheet" href="https://web.archive.org/static/css/banner-styles.css" />
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta http-equiv="content-language" content="en-gb" />
    <meta http-equiv="content-style-type" content="text/css" />
    <meta http-equiv="imagetoolbar" content="no" />
    <meta name="resource-type" content="document" />
    <meta name="distribution" content="global" />
    <meta name="copyright" content="2002-2006 phpBB Group" />
    <meta name="keywords" content="" />
    <meta name="description" content="" />
    <title>Doom3world • View topic - ASE Importer</title>
    <link rel="stylesheet" href="https://web.archive.org/web/20070509181516cs_/http://doom3world.org/phpbb2/styles/subsilver2/theme/stylesheet.css" type="text/css" />
    <script type="text/javascript">
<![CDATA[
// <![CDATA[

function popup(url, width, height, name)
{
	if (!name)
	{
		name = '_popup';
	}

	window.open(url.replace(/&amp;/g, '&'), name, 'height=' + height + ',resizable=yes,scrollbars=yes,width=' + width);
	return false;
}

function jumpto()
{
	var page = prompt('Enter the page number you wish to go to.:', '1');
	var perpage = '20';
	var base_url = './viewtopic.php?f=50&amp;t=15404&amp;st=0&amp;sk=t&amp;sd=a&amp;sid=4cb509476415554019fb7be197498b2a';

	if (page !== null && !isNaN(page) && page > 0)
	{
		document.location.href = base_url.replace(/&amp;/g, '&') + '&start=' + ((page - 1) * perpage);
	}
}

/**
* Find a member
*/
function find_username(url)
{
	popup(url, 760, 570, '_usersearch');
	return false;
}

/**
* Mark/unmark checklist
* id = ID of parent container, name = name prefix, state = state [true/false]
*/
function marklist(id, name, state)
{
	var parent = document.getElementById(id);
	if (!parent)
	{
		eval('parent = document.' + id);
	}

	if (!parent)
	{
		return;
	}

	var rb = parent.getElementsByTagName('input');
	
	for (var r = 0; r < rb.length; r++)
	{
		if (rb[r].name.substr(0, name.length) == name)
		{
			rb[r].checked = state;
		}
	}
}


// ]]]] ><![CDATA[>
]] >
    </script>
  </head>
  <body class="ltr">
<!-- BEGIN WAYBACK TOOLBAR INSERT -->
<script><![CDATA[ if (window.archive_analytics) { window.archive_analytics.values['server_name']="wwwb-app14.us.archive.org";}; ]] ></script><script type="text/javascript" src="https://web.archive.org/static/js/disclaim-element.js"></script><script type="text/javascript" src="https://web.archive.org/static/js/graph-calc.js"></script><script type="text/javascript" src="https://web.archive.org/static/jflot/jquery.min.js"></script><script type="text/javascript"><![CDATA[
//<![CDATA[
var firstDate = 820454400000;
var lastDate = 1420070399999;
var wbPrefix = "/web/";
var wbCurrentUrl = "http:\/\/doom3world.org\/phpbb2\/viewtopic.php?p=140320";

var curYear = -1;
var curMonth = -1;
var yearCount = 18;
var firstYear = 1996;
var imgWidth = 475;
var yearImgWidth = 25;
var monthImgWidth = 2;
var trackerVal = "none";
var displayDay = "9";
var displayMonth = "May";
var displayYear = "2007";
var prettyMonths = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];

function showTrackers(val) {
	if(val == trackerVal) {
		return;
	}
	if(val == "inline") {
		document.getElementById("displayYearEl").style.color = "#ec008c";
		document.getElementById("displayMonthEl").style.color = "#ec008c";
		document.getElementById("displayDayEl").style.color = "#ec008c";		
	} else {
		document.getElementById("displayYearEl").innerHTML = displayYear;
		document.getElementById("displayYearEl").style.color = "#ff0";
		document.getElementById("displayMonthEl").innerHTML = displayMonth;
		document.getElementById("displayMonthEl").style.color = "#ff0";
		document.getElementById("displayDayEl").innerHTML = displayDay;
		document.getElementById("displayDayEl").style.color = "#ff0";
	}
   document.getElementById("wbMouseTrackYearImg").style.display = val;
   document.getElementById("wbMouseTrackMonthImg").style.display = val;
   trackerVal = val;
}
function getElementX2(obj) {
	var thing = jQuery(obj);
	if((thing == undefined) 
			|| (typeof thing == "undefined") 
			|| (typeof thing.offset == "undefined")) {
		return getElementX(obj);
	}
	return Math.round(thing.offset().left);
}
function trackMouseMove(event,element) {

   var eventX = getEventX(event);
   var elementX = getElementX2(element);
   var xOff = eventX - elementX;
	if(xOff < 0) {
		xOff = 0;
	} else if(xOff > imgWidth) {
		xOff = imgWidth;
	}
   var monthOff = xOff % yearImgWidth;

   var year = Math.floor(xOff / yearImgWidth);
	var yearStart = year * yearImgWidth;
   var monthOfYear = Math.floor(monthOff / monthImgWidth);
   if(monthOfYear > 11) {
       monthOfYear = 11;
   }
   // 1 extra border pixel at the left edge of the year:
   var month = (year * 12) + monthOfYear;
   var day = 1;
	if(monthOff % 2 == 1) {
		day = 15;
	}
	var dateString = 
		zeroPad(year + firstYear) + 
		zeroPad(monthOfYear+1,2) +
		zeroPad(day,2) + "000000";

	var monthString = prettyMonths[monthOfYear];
	document.getElementById("displayYearEl").innerHTML = year + 1996;
	document.getElementById("displayMonthEl").innerHTML = monthString;
	// looks too jarring when it changes..
	//document.getElementById("displayDayEl").innerHTML = zeroPad(day,2);

	var url = wbPrefix + dateString + '/' +  wbCurrentUrl;
	document.getElementById('wm-graph-anchor').href = url;

   //document.getElementById("wmtbURL").value="evX("+eventX+") elX("+elementX+") xO("+xOff+") y("+year+") m("+month+") monthOff("+monthOff+") DS("+dateString+") Moy("+monthOfYear+") ms("+monthString+")";
   if(curYear != year) {
       var yrOff = year * yearImgWidth;
       document.getElementById("wbMouseTrackYearImg").style.left = yrOff + "px";
       curYear = year;
   }
   if(curMonth != month) {
       var mtOff = year + (month * monthImgWidth) + 1;
       document.getElementById("wbMouseTrackMonthImg").style.left = mtOff + "px";
       curMonth = month;
   }
}
//]]]] ><![CDATA[>
]] ></script><style type="text/css"><![CDATA[body{margin-top:0!important;padding-top:0!important;min-width:800px!important;}#wm-ipp a:hover{text-decoration:underline!important;}]] ></style><div id="wm-ipp" lang="en" class="__wb_banner_div" style="display:none; position:relative;padding:0 5px;min-height:70px;min-width:800px" xml:lang="en">


<div id="wm-ipp-inside" class="__wb_banner_div" style="position:fixed;padding:0!important;margin:0!important;width:97%;min-width:780px;border:5px solid #000;border-top:none;background-image:url(https://web.archive.org/static/images/toolbar/wm_tb_bk_trns.png);text-align:center;-moz-box-shadow:1px 1px 3px #333;-webkit-box-shadow:1px 1px 3px #333;box-shadow:1px 1px 3px #333;font-size:11px!important;font-family:'Lucida Grande','Arial',sans-serif!important;">
   <table style="border-collapse:collapse;margin:0;padding:0;width:100%;"><tbody><tr><td style="padding:10px;vertical-align:top;min-width:110px;">
   <a href="https://web.archive.org/web/" title="Wayback Machine home page" style="background-color:transparent;border:none;"><img src="https://web.archive.org/static/images/toolbar/wayback-toolbar-logo.png" alt="Wayback Machine" width="110" height="39" border="0" /></a>
   </td>
   <td style="padding:0!important;text-align:center;vertical-align:top;width:100%;">

       <table style="border-collapse:collapse;margin:0 auto;padding:0;width:570px;"><tbody><tr><td style="padding:3px 0;" colspan="2">
       <form target="_top" method="get" action="https://web.archive.org/web/form-submit.jsp" name="wmtb" id="wmtb" style="margin:0!important;padding:0!important;"><input type="text" name="url" id="wmtbURL" value="http://doom3world.org/phpbb2/viewtopic.php?p=140320" style="width:400px;font-size:11px;font-family:'Lucida Grande','Arial',sans-serif;" onfocus="javascript:this.focus();this.select();" /><input type="hidden" name="type" value="replay" /><input type="hidden" name="date" value="20070509181516" /><input type="submit" value="Go" style="font-size:11px;font-family:'Lucida Grande','Arial',sans-serif;margin-left:5px;width: inherit !important" /><span id="wm_tb_options" style="display:block;"></span></form>
       </td>
       <td style="vertical-align:bottom;padding:5px 0 0 0!important;" rowspan="2">
           <table style="border-collapse:collapse;width:110px;color:#99a;font-family:'Helvetica','Lucida Grande','Arial',sans-serif;"><tbody><!-- NEXT/PREV MONTH NAV AND MONTH INDICATOR --><tr style="width:110px;height:16px;font-size:10px!important;"><td style="padding-right:9px;font-size:11px!important;font-weight:bold;text-transform:uppercase;text-align:right;white-space:nowrap;overflow:visible;" nowrap="nowrap">
               
		                <a href="https://web.archive.org/web/20061012234505/http://doom3world.org/phpbb2/viewtopic.php?p=140320" style="text-decoration:none;color:#33f;font-weight:bold;background-color:transparent;border:none;" title="12 Oct 2006"><strong>OCT</strong></a>
		                
               </td>
               <td id="displayMonthEl" style="background:#000;color:#ff0;font-size:11px!important;font-weight:bold;text-transform:uppercase;width:34px;height:15px;padding-top:1px;text-align:center;" title="You are here: 18:15:16 May 9, 2007">MAY</td>
				<td style="padding-left:9px;font-size:11px!important;font-weight:bold;text-transform:uppercase;white-space:nowrap;overflow:visible;" nowrap="nowrap">
               
                       Jun
                       
               </td>
           </tr><!-- NEXT/PREV CAPTURE NAV AND DAY OF MONTH INDICATOR --><tr><td style="padding-right:9px;white-space:nowrap;overflow:visible;text-align:right!important;vertical-align:middle!important;" nowrap="nowrap">
               
		                <a href="https://web.archive.org/web/20061012234505/http://doom3world.org/phpbb2/viewtopic.php?p=140320" title="23:45:05 Oct 12, 2006" style="background-color:transparent;border:none;"><img src="https://web.archive.org/static/images/toolbar/wm_tb_prv_on.png" alt="Previous capture" width="14" height="16" border="0" /></a>
		                
               </td>
               <td id="displayDayEl" style="background:#000;color:#ff0;width:34px;height:24px;padding:2px 0 0 0;text-align:center;font-size:24px;font-weight: bold;" title="You are here: 18:15:16 May 9, 2007">9</td>
				<td style="padding-left:9px;white-space:nowrap;overflow:visible;text-align:left!important;vertical-align:middle!important;" nowrap="nowrap">
               
                       <img src="https://web.archive.org/static/images/toolbar/wm_tb_nxt_off.png" alt="Next capture" width="14" height="16" border="0" /></td>
           </tr><!-- NEXT/PREV YEAR NAV AND YEAR INDICATOR --><tr style="width:110px;height:13px;font-size:9px!important;"><td style="padding-right:9px;font-size:11px!important;font-weight: bold;text-align:right;white-space:nowrap;overflow:visible;" nowrap="nowrap">
               
                       2006
                       
               </td>
               <td id="displayYearEl" style="background:#000;color:#ff0;font-size:11px!important;font-weight: bold;padding-top:1px;width:34px;height:13px;text-align:center;" title="You are here: 18:15:16 May 9, 2007">2007</td>
				<td style="padding-left:9px;font-size:11px!important;font-weight: bold;white-space:nowrap;overflow:visible;" nowrap="nowrap">
               
                       2008
                       
				</td>
           </tr></tbody></table></td>

       </tr><tr><td style="vertical-align:middle;padding:0!important;">
           <a href="https://web.archive.org/web/20070509181516*/http://doom3world.org/phpbb2/viewtopic.php?p=140320" style="color:#33f;font-size:11px;font-weight:bold;background-color:transparent;border:none;" title="See a list of every capture for this URL"><strong>2 captures</strong></a>
           <div class="__wb_banner_div" style="margin:0!important;padding:0!important;color:#666;font-size:9px;padding-top:2px!important;white-space:nowrap;" title="Timespan for captures of this URL">12 Oct 06 - 9 May 07</div>
       </td>
       <td style="padding:0!important;">
       <a style="position:relative; white-space:nowrap; width:475px;height:27px;" href="viewtopic.php?p=140320" id="wm-graph-anchor">
       <div class="__wb_banner_div" id="wm-ipp-sparkline" style="position:relative; white-space:nowrap; width:475px;height:27px;background-color:#fff;cursor:pointer;border-right:1px solid #ccc;" title="Explore captures for this URL">
			<img id="sparklineImgId" style="position:absolute; z-index:9012; top:0px; left:0px;" onmouseover="showTrackers('inline');" onmouseout="showTrackers('none');" onmousemove="trackMouseMove(event,this)" alt="sparklines" width="475" height="27" border="0" src="https://web.archive.org/web/jsp/graph.jsp?graphdata=475_27_1996:-1:000000000000_1997:-1:000000000000_1998:-1:000000000000_1999:-1:000000000000_2000:-1:000000000000_2001:-1:000000000000_2002:-1:000000000000_2003:-1:000000000000_2004:-1:000000000000_2005:-1:000000000000_2006:-1:000000000100_2007:4:000010000000_2008:-1:000000000000_2009:-1:000000000000_2010:-1:000000000000_2011:-1:000000000000_2012:-1:000000000000_2013:-1:000000000000_2014:-1:000000000000" /><img id="wbMouseTrackYearImg" style="display:none; position:absolute; z-index:9010;" width="25" height="27" border="0" src="https://web.archive.org/static/images/toolbar/transp-yellow-pixel.png" /><img id="wbMouseTrackMonthImg" style="display:none; position:absolute; z-index:9011; " width="2" height="27" border="0" src="https://web.archive.org/static/images/toolbar/transp-red-pixel.png" /></div>
		</a>

       </td>
       </tr></tbody></table></td>
   <td style="text-align:right;padding:5px;width:65px;font-size:11px!important;">
       <a href="javascript:;" onclick="document.getElementById('wm-ipp').style.display='none';" style="display:block;padding-right:18px;background:url(https://web.archive.org/static/images/toolbar/wm_tb_close.png) no-repeat 100% 0;color:#33f;font-family:'Lucida Grande','Arial',sans-serif;margin-bottom:23px;background-color:transparent;border:none;" title="Close the toolbar">Close</a>
       <a href="http://faq.web.archive.org/" style="display:block;padding-right:18px;background:url(https://web.archive.org/static/images/toolbar/wm_tb_help.png) no-repeat 100% 0;color:#33f;font-family:'Lucida Grande','Arial',sans-serif;background-color:transparent;border:none;" title="Get some help using the Wayback Machine">Help</a>
   </td>
   </tr></tbody></table></div>
</div>
<script type="text/javascript"><![CDATA[
 var wmDisclaimBanner = document.getElementById("wm-ipp");
 if(wmDisclaimBanner != null) {
   disclaimElement(wmDisclaimBanner);
 }
]] ></script><!-- END WAYBACK TOOLBAR INSERT --><a name="top" id="top"></a>

<div id="wrapheader">

	<div id="logodesc">
		<table width="100%" cellspacing="0"><tr><td><a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/index.php?sid=4cb509476415554019fb7be197498b2a"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/imageset/site_logo.gif" width="300" height="71" alt="" title="" /></a></td>
			<td width="100%" align="center"><h1>Doom3world</h1><span class="gen">The world is yours! Doom 3 - Quake 4 - ET:QW - Prey - Rage</span>
      
      <br /><script type="text/javascript"><![CDATA[<!--
      google_ad_client = "pub-9445709839432880";
      google_ad_width = 468;
      google_ad_height = 60;
      google_ad_format = "468x60_as";
      google_ad_type = "text_image";
      //2007-11-04: D3WForums_banner_header
      google_ad_channel = "6206397355";
      google_color_border = "DCE1E5";
      google_color_bg = "DCE1E5";
      google_color_link = "006699";
      google_color_text = "000000";
      google_color_url = "006699";
      google_ui_features = "rc:0";
      //-->
      ]] ></script><script type="text/javascript" src="https://web.archive.org/web/20070509181516js_/http://pagead2.googlesyndication.com/pagead/show_ads.js"><![CDATA[
  ]] ></script></td>
		</tr></table></div>

	<div id="menubar">
		<table width="100%" cellspacing="0"><tr><td class="genmed">
				<a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/ucp.php?mode=login&amp;sid=4cb509476415554019fb7be197498b2a"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/theme/images/icon_mini_login.gif" width="12" height="13" alt="*" /> Login</a>   <a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/ucp.php?mode=register&amp;sid=4cb509476415554019fb7be197498b2a"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/theme/images/icon_mini_register.gif" width="12" height="13" alt="*" /> Register</a>
								</td>
			<td class="genmed" align="right">
				<a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/faq.php?sid=4cb509476415554019fb7be197498b2a"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/theme/images/icon_mini_faq.gif" width="12" height="13" alt="*" /> FAQ</a>
				   <a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/search.php?sid=4cb509476415554019fb7be197498b2a"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/theme/images/icon_mini_search.gif" width="12" height="13" alt="*" /> Search</a>			</td>
		</tr></table></div>

	<div id="datebar">
		<table width="100%" cellspacing="0"><tr><td class="gensmall"></td>
			<td class="gensmall" align="right">It is currently Sun Dec 23, 2007 10:02 pm<br /></td>
		</tr></table></div>

</div>

<div id="wrapcentre">

		<p class="searchbar">
		<span style="float: left;"><a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/search.php?search_id=unanswered&amp;sid=4cb509476415554019fb7be197498b2a">View unanswered posts</a> | <a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/search.php?search_id=active_topics&amp;sid=4cb509476415554019fb7be197498b2a">View active topics</a></span>
			</p>
	
	<br style="clear: both;" /><table class="tablebg" width="100%" cellspacing="1" cellpadding="0" style="margin-top: 5px;"><tr><td class="row1">
			<p class="breadcrumbs"><a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/index.php?sid=4cb509476415554019fb7be197498b2a">Board index</a> 
   » <a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/viewforum.php?f=71&amp;sid=4cb509476415554019fb7be197498b2a">General Discussion</a> » <a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/viewforum.php?f=72&amp;sid=4cb509476415554019fb7be197498b2a">3D editing and offline rendering</a> » <a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/viewforum.php?f=50&amp;sid=4cb509476415554019fb7be197498b2a">Blender</a>      
  

  
  </p>
			<p class="datetime">All times are UTC </p>
		</td>
	</tr></table><center>
  <script type="text/javascript"><![CDATA[<!--
      google_ad_client = "pub-9445709839432880";
      google_ad_width = 728;
      google_ad_height = 15;
      google_ad_format = "728x15_0ads_al_s";
      //2007-11-03: D3WForums_linkblock
      google_ad_channel = "1963952183";
      google_color_border = "FFFFFF";
      google_color_bg = "FFFFFF";
      google_color_link = "006699";
      google_color_text = "006699";
      google_color_url = "006699";
      //-->
      ]] ></script><script type="text/javascript" src="https://web.archive.org/web/20070509181516js_/http://pagead2.googlesyndication.com/pagead/show_ads.js"><![CDATA[
  ]] ></script></center>
	<br /><div id="pageheader">
	<h2><a class="titles" href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/viewtopic.php?f=50&amp;t=15404&amp;start=0&amp;st=0&amp;sk=t&amp;sd=a&amp;sid=4cb509476415554019fb7be197498b2a">ASE Importer</a></h2>

	<p class="moderators">Moderator: <a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/memberlist.php?mode=group&amp;g=654&amp;sid=4cb509476415554019fb7be197498b2a">il padrino</a></p>
</div>

<br clear="all" /><br /><div id="pagecontent">

	<table width="100%" cellspacing="1"><tr><td align="left" valign="middle" nowrap="nowrap">
		<a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/posting.php?mode=post&amp;f=50&amp;sid=4cb509476415554019fb7be197498b2a"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/imageset/en/button_topic_new.gif" alt="Post new topic" title="Post new topic" /></a> <a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/posting.php?mode=reply&amp;f=50&amp;t=15404&amp;sid=4cb509476415554019fb7be197498b2a"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/imageset/en/button_topic_reply.gif" alt="Reply to topic" title="Reply to topic" /></a>		</td>
					<td class="nav" valign="middle" nowrap="nowrap"> Page <strong>1</strong> of <strong>2</strong><br /></td>
			<td class="gensmall" nowrap="nowrap"> [ 21 posts ] </td>
			<td class="gensmall" width="100%" align="right" nowrap="nowrap"><b><a href="viewtopic.php?p=140320#" onclick="jumpto(); return false;" title="Click to jump to page…">Go to page</a> <strong>1</strong><span class="page-sep">, </span><a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/viewtopic.php?f=50&amp;t=15404&amp;st=0&amp;sk=t&amp;sd=a&amp;sid=4cb509476415554019fb7be197498b2a&amp;start=20">2</a>  <a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/viewtopic.php?f=50&amp;t=15404&amp;st=0&amp;sk=t&amp;sd=a&amp;sid=4cb509476415554019fb7be197498b2a&amp;start=20">Next</a></b></td>
			</tr></table><table class="tablebg" width="100%" cellspacing="1"><tr><td class="cat">
			<table width="100%" cellspacing="0"><tr><td class="nav" nowrap="nowrap"> 
								</td>
				<td class="nav" align="right" nowrap="nowrap"><a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/viewtopic.php?f=50&amp;t=15404&amp;view=previous&amp;sid=4cb509476415554019fb7be197498b2a">Previous topic</a> | <a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/viewtopic.php?f=50&amp;t=15404&amp;view=next&amp;sid=4cb509476415554019fb7be197498b2a">Next topic</a> </td>
			</tr></table></td>
	</tr></table><table class="tablebg" width="100%" cellspacing="1"><tr><th>Author</th>
			<th>Message</th>
		</tr><tr class="row1"><td align="center" valign="middle">
				<a name="p140291" id="p140291"></a>
				<b class="postauthor">Goofos</b>
			</td>
			<td width="100%" height="25">
				<table width="100%" cellspacing="0"><tr><td class="gensmall" width="100%"><div style="float: left;"> <b>Post subject:</b> ASE Importer</div><div style="float: right;"><a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/viewtopic.php?p=140291&amp;sid=4cb509476415554019fb7be197498b2a#p140291"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/imageset/icon_post_target.gif" width="12" height="9" alt="Post" title="Post" /></a><b>Posted:</b> Mon Apr 17, 2006 2:00 am </div></td>
				</tr></table></td>
		</tr><tr class="row1"><td valign="top" class="profile">
				<table cellspacing="4" align="center" width="150"><tr><td><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/imageset/en/icon_user_offline.gif" alt="Offline" title="Offline" /></td>
				</tr><tr><td class="postdetails">picked up the chaingun</td>
				</tr><tr><td><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/download/file.php?avatar=12761.gif" width="30" height="22" alt="User avatar" /></td>
				</tr></table><span class="postdetails">
					<br /><b>Joined:</b> Thu Mar 10, 2005 2:05 am<br /><b>Posts:</b> 177<br /><b>Location:</b> black forrest				</span>

			</td>
			<td valign="top">
				<table width="100%" cellspacing="5"><tr><td>
					
						<div class="postbody"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/images/smilies/icon_arrow.gif" alt=":arrow:" title="Arrow" /> Version: 0.13
<br /><br />Supports Mesh Objects with vertex colors, multiple UV, smoothgroups.
<br /><br />A little Note!: you should not try to import very big ase files (&gt;50 MB with 512 MB RAM). With much RAM you might can try this.
<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">#!BPY<br /><br />"""<br />Name: 'ASCII Scene (.ase) v0.13'<br />Blender: 244<br />Group: 'Import'<br />Tooltip: 'Import from ASCII Scene Export file format (.ase)'<br />""" <br />__author__ = "Goofos"<br />__version__ = "0.13"<br /><br /># goofos<br />#<br /># ***** BEGIN GPL LICENSE BLOCK *****<br />#<br /># This program is free software; you can redistribute it and/or<br /># modify it under the terms of the GNU General Public License<br /># as published by the Free Software Foundation; either version 2<br /># of the License, or (at your option) any later version.<br /># <br /># This program is distributed in the hope that it will be useful,<br /># but WITHOUT ANY WARRANTY; without even the implied warranty of<br /># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<br /># GNU General Public License for more details.<br /># <br /># You should have received a copy of the GNU General Public License<br /># along with this program; if not, write to the Free Software Foundation,<br /># Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.<br /># <br /># ***** END GPL LICENCE BLOCK *****<br /><br />import time, sys<br />import Blender<br />from Blender import Scene, Object, Mesh<br /><br />'''<br />Some Options<br />'''<br /># Scale Factor (float)<br />OPT_SCALE = 0.1<br /># Add EdgeSplit Modifier when importing sharp edges (bool)<br />OPT_MOD_EDGESPLIT = True<br /># Enable the fileselector (bool)<br />OPT_FILESELECTOR = True<br /># If the fileselector is disabled, specify a static filename (string)<br />OPT_STATIC_FILENAME = 'E:\ASE Files\garage.ASE'<br /># Enable Progressbar (bool)<br />OPT_PROGRESSBAR = False<br /># File buffer. After testing with big files i think there is no real difference.<br /># -1 = system default, 0 = unbuffered, 1 = line buffered, &gt;1 = buffer size<br />OPT_FILE_BUFFER = -1<br /><br />'''<br />Import Options<br />'''<br /># Import Meshes scaled, defined by the scale factor of OPT_SCALE (bool)<br /># Note: Object location data looses some precision, .. i think!<br />IMP_SCALED = True<br /># Import Vertex Colors (bool)<br />IMP_VCOLOR = True<br /># Import UV Coords and UV layers (bool)<br />IMP_UV = True<br /># Import NGons as Blender FGons (bool)<br /># Note: Include quads, too.<br />IMP_FGONS = False<br /># Try to find possible quads and convert the two tris to a quad (bool)<br /># Note: Very slow!! ablsolutely doesn't work accurate :/<br /># i don't know wether this is a script problem or a blender problem!<br />IMP_QUADS = False<br /># Surround UV islands with seams (bool)<br />IMP_SEAMS = False<br /># Surround smooth groups with sharp edges (bool)<br />IMP_SMOOTHGROUPS = True<br /># Try to find the lowest autosmooth angle in vertex normals (bool)<br /># Note: i dont know if this is correct :&gt;<br />IMP_AUTOSMOOTH = False<br /><br /><br /><br /><br /><br />class Ase_group:<br />   def __init__(self):<br />      self.name = 'Name'<br />      self.ase_type = 'GROUP'<br />      self.ase_helper = None<br />      self.ase_objects = []<br /><br />class Ase_object:<br /><br />   def __init__(self, ase_object_type, name=''):<br />      #if ase_object_type not in ['GEOM','HELPER','SHAPE','LIGHT','CAMERA']: return<br />      if ase_object_type not in ['geom','helper','shape','light','camera']: return<br />      self.name = name<br />      self.ase_type = ase_object_type #GEOM, HELPER, SHAPE, LIGHT, CAMERA<br />      self.row0 = None<br />      self.row1 = None<br />      self.row2 = None<br />      self.row3 = None<br />      self.parent = None<br /><br />      #new_ase_data = None<br />      if ase_object_type == 'geom':<br />         new_ase_data = Ase_mesh(self)<br />      self.ase_data = new_ase_data<br /><br />class Ase_mesh:<br />   def __init__(self, ase_obj=None):<br />      self.name = 'Name'<br />      self.num = {'VERTS':0,'FACES':0,'CVERTEX':0,'CVFACES':0}<br />      self.ase_verts = {}<br />      self.vertseq = []<br />      self.ase_edges = {}<br />      self.ase_faces = {}<br />      self.faceseq = []<br />      self.ase_uv_channels = {}<br />      self.active_uv = None<br />      self.ase_vertcolors = {}<br />      self.ase_cfaces = {}<br />      self.autosmooth = 0<br />      self.hasUV = 0<br />      self.hasVC = 0 <br /><br />   def sort_edgekeys(self,vi0,vi1,vi2):<br />      '''<br />      Returns sorted edge keys of the given triangle vert indicies.<br />      '''<br />      if vi0 &gt; vi1: ed_k0 = vi1,vi0<br />      else: ed_k0 = vi0,vi1<br />      if vi1 &gt; vi2: ed_k1 = vi2,vi1<br />      else: ed_k1 = vi1,vi2<br />      if vi0 &gt; vi2: ed_k2 = vi2,vi0<br />      else: ed_k2 = vi0,vi2<br />      return ed_k0,ed_k1,ed_k2<br /><br />   def append_vert(self, ase_vert_index, x, y, z):<br />      '''<br />      Create a new Vertex for this Mesh.<br />      '''<br />      ase_v = Ase_vert(ase_vert_index, x, y, z)<br />      self.ase_verts[ase_vert_index] = ase_v<br />      #self.vertseq.insert(ase_vert_index, (ase_v.co.x,ase_v.co.y,ase_v.co.z))<br />      self.vertseq.insert(ase_vert_index, ase_v.co)<br />      <br />   def append_face(self, index, vi0, vi1, vi2, AB=1, BC=1, CA=1, smooth_groups=[0], mat_indices=0):<br />      '''<br />      Uhm ... work in progress!<br />      '''<br />      # create a new Ase_face<br />      ase_f = Ase_face(index, vi0, vi1, vi2, smooth_groups, mat_indices)<br />      ed_keys = self.sort_edgekeys(vi0,vi1,vi2)<br />      #ed_keys = [vi0,vi1].sort(),[vi1,vi2].sort(),[vi0,vi2].sort()<br />      ase_f.edge_keys = ed_keys<br />      ase_f.vis_sum = AB+BC+CA<br />      if ase_f.vis_sum == 2:<br />         if not AB: ase_f.tri_edge = ed_keys[0]<br />         elif not BC: ase_f.tri_edge = ed_keys[1]<br />         elif not CA: ase_f.tri_edge = ed_keys[2]<br /><br />      # set visibility (fgon) and sharp for edges<br />      # and look if the two face users might form a quad<br />      # or create a new Ase_edge<br />      for k,vis in zip(ed_keys,[AB,BC,CA]):<br />         # Ase_edge already exist or create a new one<br />         if not self.ase_edges.has_key(k):<br />            ase_ed = Ase_edge(k)<br />            ase_ed.fusers.append(ase_f.index)<br />            ase_ed.visible = vis<br />            self.ase_edges[k] = ase_ed<br />            continue<br />         else:<br />            ase_ed = self.ase_edges[k]<br />            ase_ed.fusers.append(ase_f.index)<br />            if ase_f.vis_sum == 2 and not ase_ed.visible:<br />               ase_f.tri_edge = k<br /><br />         fusers = [i for i in ase_ed.fusers if i != ase_f.index]<br />         if not fusers: continue<br />         for i in fusers:<br />            ase_f2 = self.ase_faces[i]<br />            # if this edge is invisible and both tris only have<br />            # this invisible edge, than the two tris could form a quad<br />            # easy done with a sum of all vis variables of the edges<br />            if k == ase_f.tri_edge:<br />               if ase_f.tri_edge == ase_f2.tri_edge:<br />                  ase_f.quad_team = ase_f2.index<br />                  ase_f2.quad_team = ase_f.index<br /><br />            # look if this edge is sharp<br />            # if not both faces share at least one smoothgroup var<br />            # than this edge is sharp<br />            #if ase_ed.sharp: continue<br />            for sg in smooth_groups:<br />               if sg not in ase_f2.smooth_groups:<br />                  ase_ed.sharp = True<br /><br />      self.ase_faces[ase_f.index] = ase_f<br />      self.faceseq.insert(ase_f.index, (ase_f.v0, ase_f.v1, ase_f.v2))<br /><br />   def append_uv_channel(self, layer_index=1):<br />      ''' <br />      Create a new UV Layer and set it active.<br />      '''<br />      self.ase_uv_channels[layer_index] = Ase_uv_channel(layer_index)<br />      self.active_uv = self.ase_uv_channels[layer_index]<br /><br />   def append_tvert(self, ase_uv_index, u, v, w=0):<br />      '''<br />      Create a new UV Vector in the active! UV Channel.<br />      '''<br />      if not self.active_uv: return<br />      #self.active_uv.ase_tverts[ase_uv_index] = Ase_tvert(ase_uv_index,u,v,w)<br />      self.active_uv.ase_tverts[ase_uv_index] = (u,v)<br /><br />   def append_tface(self, ase_face_index, uvi0, uvi1, uvi2, opt_check_seams=False):<br />      '''<br />      Create a new Face UV with indicies to UV Vectors in the active UV Layer.<br />      Optional check for Seams and store into the UV Channel.<br />      '''<br />      if not self.active_uv: return<br />      self.active_uv.ase_tfaces[ase_face_index] = [uvi0, uvi1, uvi2]<br />      # look if this face has seams<br />      # might useless because it makes no sense to import seams for all UV layers<br />      # that's why those edge keys are separately written to each ase UV layer<br />      if opt_check_seams:<br />         edge_keys = self.ase_faces[ase_face_index].edge_keys<br />         for ed_key,uvs in zip(edge_keys,[[uvi0,uvi1],[uvi1,uvi2],[uvi0,uvi2]]):<br />            uvs.sort()<br />            ase_ed,active_uv = self.ase_edges[ed_key],self.active_uv<br />            if not active_uv.ase_tedges.has_key(ed_key):<br />               active_uv.ase_tedges[ed_key] = uvs<br />               continue<br />            elif active_uv.ase_tedges[ed_key] != uvs:<br />               active_uv.seams.append(ed_key)<br /><br />   def append_vertcol(self, ase_color_index, r, g, b):<br />      #new = Ase_vertcolor(ase_color_index, r, g, b)<br />      #self.ase_vertcolors[ase_color_index] = new<br />      self.ase_vertcolors[ase_color_index] = (r,g,b)<br />      <br />   def append_cface(self, ase_face_index, ci0, ci1, ci2):<br />      ase_f = self.ase_faces[ase_face_index]<br />      #f.c0, f.c1, f.c2 = ci0, ci1, ci2<br />      self.ase_cfaces[ase_face_index] = (ci0, ci1, ci2)<br /><br />   def append_normal(self, ase_face_index, x, y, z):<br />      self.ase_faces[ase_face_index].normal = Blender.Mathutils.Vector(x,y,z)<br /><br />   def append_vnormal(self, ase_face_index, ase_vert_index, x, y, z, opt_check_smooth=False):<br />      ase_f = self.ase_faces[ase_face_index]<br />      self.ase_verts[ase_vert_index].normals[ase_face_index] = Blender.Mathutils.Vector(x,y,z)<br />      if opt_check_smooth and ase_f.smooth_groups:<br />         ase_edges = [self.ase_edges[key] for key in ase_f.edge_keys]<br />         for ed_key,ase_ed in zip(ase_f.edge_keys,ase_edges):<br />            if ase_ed.sharp or len(ase_ed.fusers) &lt; 2: continue<br />            for vi in ed_key:<br />               if not self.ase_verts.has_key(vi): continue<br />               vnormals = self.ase_verts[vi].normals<br />               fi0, fi1 = ase_ed.fusers[0:2]<br />               if vnormals.has_key(fi0) and vnormals.has_key(fi1):<br />                  vnor0, vnor1 = vnormals[fi0],vnormals[fi1]<br />                  if vnor0 == vnor1:<br />                     continue<br />                  else:<br />                     angle = round(Blender.Mathutils.AngleBetweenVecs(vnor0, vnor1))<br />                     if not self.autosmooth: self.autosmooth = angle<br />                     elif angle and self.autosmooth &gt; angle:<br />                        print angle<br />                        self.autosmooth = angle<br /><br /><br />class Ase_vert:<br />   def __init__(self, index, x, y, z):<br />      self.index = index<br />      #self.co = Blender.Mathutils.Vector(x,y,z)<br />      self.co = (x,y,z)<br />      self.normals = {}<br /><br />class Ase_edge:<br />   def __init__(self, key):<br />      self.key = key<br />      self.fusers = []<br />      self.uvs = None<br />      self.visible = 1<br />      self.sharp = False<br /><br />class Ase_face:<br />   def __init__(self, ase_face_index, v0, v1, v2, smooth_groups=0, mat_indices=0):<br />      self.index = ase_face_index<br />      self.v0 = v0<br />      self.v1 = v1<br />      self.v2 = v2<br />      self.edge_keys = None<br />      self.c0 = None<br />      self.c1 = None<br />      self.c2 = None<br />      self.normal = None<br />      #self.vert_normals = {}<br />      self.mat_indices = mat_indices<br />      self.smooth_groups = smooth_groups # 0 = solid face<br />      self.vis_sum = 3<br />      self.quad_team = None<br />      self.tri_edge = None<br /><br />class Ase_uv_channel:<br />   def __init__(self, index=1):<br />      self.index = index<br />      self.num = {'TVERTEX':0,'TVFACES':0}<br />      self.uv_layer_name = 'UVTex#' + str(self.index)<br />      self.ase_tverts = {}<br />      self.ase_tfaces = {}<br />      self.ase_tedges = {}<br />      self.seams = []<br /><br />class Ase_tvert:<br />   def __init__(self,index, u, v, w=0):<br />      self.index = index<br />      #self.vec = Blender.Mathutils.Vector(u,v)<br />      self.vec = (u,v)<br /><br />class Ase_tface:<br />   def __init__(self, index, uvi0, uvi1, uvi2):<br />      self.index = index<br />      self.uv = {0:uvi0, 1:uvi1, 2:uvi2}<br /><br />class Ase_vertcolor:<br />   def __init__(self, index, r, g, b):<br />      self.index = 0 <br />      self.r = round(r*256)<br />      self.g = round(g*256)<br />      self.b = round(b*256)<br />      self.a = 255.0<br /><br /><br />def spawn(ase_objects):<br /><br />   PB_index = 0.0<br />   PB_num = float(len(ase_objects))<br /><br />   print 'Import Objects...'<br />   if OPT_PROGRESSBAR: Blender.Window.DrawProgressBar(0.0, "Importing Objects...")<br /><br />   scene = Blender.Scene.GetCurrent()<br />   for ase_ob in ase_objects: <br />      if OPT_PROGRESSBAR and not (PB_index % PB_num):<br />         Blender.Window.DrawProgressBar(PB_index / PB_num, "Importing Objects...")<br /><br />      if ase_ob.ase_type == 'geom':<br />         spawn_mesh(scene,ase_ob)<br /><br />      PB_index += 1.0<br /><br />def spawn_mesh(scene,ase_ob):<br /><br />   ase_me = ase_ob.ase_data<br />   #normal_flag = 1<br /><br />   row0 = ase_ob.row0<br />   row1 = ase_ob.row1<br />   row2 = ase_ob.row2<br />   row3 = ase_ob.row3<br /><br />   matrix = Blender.Mathutils.Matrix(row0, row1, row2, row3)<br />   matrix.resize4x4()<br /><br />   # create new Blender Object and link to scene<br />   ob = Blender.Object.New('Mesh', ase_ob.name)<br />   ob.setMatrix(matrix)<br />   scene.objects.link(ob)<br /><br />   # get Mesh data from Object<br />   me = ob.getData(0,1)<br />   me.vertexColors = me.faceUV = False<br /><br />   # create Verts and Faces<br />   # seems like extend() is limited to a length of 64000?<br />   # this is a problem when importing big meshes.<br />   div = divmod(ase_me.num['VERTEX'], 64000)<br />   if div[1]: div = div[0]+1<br />   else: div = div[0]<br />   start = 0<br />   for i in range(div):<br />      end = start+64000<br />      me.verts.extend(ase_me.vertseq[start:end])<br />      start = end<br />   div = divmod(ase_me.num['FACES'], 64000)<br />   face_index_list = []<br />   if div[1]: div = div[0]+1<br />   else: div = div[0]<br />   start = 0<br />   for i in range(div):<br />      end = start+64000<br />      me.faces.extend(ase_me.faceseq[start:end])<br />      start = end<br /><br />   # import Vertex Colors, Solid/Smooth to faces<br />   if IMP_VCOLOR:<br />      me.vertexColors = ase_me.hasVC<br />      ase_vcolors = ase_me.ase_vertcolors<br />   for i,ase_f in ase_me.ase_faces.iteritems():<br />      try:f = me.faces[i]<br />      except:<br />         # dont know what's the problem with this<br />         print 'array index out of range:', i<br />         continue<br />      if me.vertexColors:<br />         cface = ase_me.ase_cfaces[i]<br />         c0,c1,c2 = ase_vcolors[cface[0]],ase_vcolors[cface[1]],ase_vcolors[cface[2]]<br />         fc0,fc1,fc2 = f.col[:]<br />         fc0.r,fc0.g,fc0.b = int(c0[0]*255),int(c0[1]*255),int(c0[2]*255)<br />         fc1.r,fc1.g,fc1.b = int(c1[0]*255),int(c1[1]*255),int(c1[2]*255)<br />         fc2.r,fc2.g,fc2.b = int(c2[0]*255),int(c2[1]*255),int(c2[2]*255)<br />      if ase_f.smooth_groups:<br />         f.smooth = 1<br /><br />   # import UV layer's<br />   if IMP_UV and ase_me.hasUV:<br />      for uv_chan in ase_me.ase_uv_channels.itervalues():<br />         me.addUVLayer(uv_chan.uv_layer_name)<br />         me.activeUVLayer = uv_chan.uv_layer_name<br />         tverts = uv_chan.ase_tverts<br />         for fi,uvis in uv_chan.ase_tfaces.iteritems():<br />            try:f = me.faces[fi]<br />            except: continue<br />            uv1,uv2,uv3 = tverts[uvis[0]],tverts[uvis[1]],tverts[uvis[2]]<br />            f.uv = [Blender.Mathutils.Vector(uv1), Blender.Mathutils.Vector(uv2), Blender.Mathutils.Vector(uv3)]<br />      me.activeUVLayer = ase_me.ase_uv_channels[1].uv_layer_name<br /><br />   # EXPERIMENTAL!<br />   # convert tris to quads<br />   # this is currently the easiest way i found without destroying uvs or vcolors<br />   # but don't work like expected...:/<br />   if IMP_QUADS:<br />      #quad_teams = set([i for i,ase_f in ase_me.ase_faces.iteritems() if ase_f.quad_team != None])<br />      quad_teams = []<br />      for i,ase_f in ase_me.ase_faces.iteritems():<br />         if ase_f.quad_team != None:<br />            if ase_f.index &lt; ase_f.quad_team: qt = ase_f.index,ase_f.quad_team<br />            elif ase_f.index &gt; ase_f.quad_team: qt = ase_f.quad_team,ase_f.index<br />            if qt not in quad_teams:<br />               quad_teams.append(qt)<br /><br />      faces = me.faces<br />      # first deselect all faces<br />      for f in faces: f.sel = 0<br />      for t0,t1 in quad_teams:<br />         ase_f0 = ase_me.ase_faces[t0]<br />         ase_f1 = ase_me.ase_faces[t1]<br />         try: f0,f1 = me.faces[ase_f0.index], me.faces[ase_f1.index]<br />         except: continue<br />         f0.sel = 1<br />         f1.sel = 1<br />         me.triangleToQuad()<br />         for i in faces.selected():<br />            faces[i].sel = 0<br /><br />   # apply the matrix to mesh (and optional fit the ob and me to blender)<br />   if IMP_SCALED:<br />      # seems this isn't accurate because of precision of the location vector<br />      scale = Blender.Mathutils.ScaleMatrix(OPT_SCALE,4)<br />      inv_matrix = ob.getMatrix().copy().invert() * scale<br />      ob.setLocation(ob.getMatrix().translationPart() * scale)<br />   else:<br />      inv_matrix = ob.getMatrix().copy().invert()<br />   me.transform(inv_matrix, 1)<br />   me.calcNormals()<br /><br />   # apply sharp, seam and fgon flags to edges.<br />   add_EDGESPLIT = False<br />   if IMP_FGONS or IMP_SEAMS or IMP_SMOOTHGROUPS:<br />      SHARP = Mesh.EdgeFlags.SHARP<br />      SEAM = Mesh.EdgeFlags.SEAM<br />      FGON = Mesh.EdgeFlags.FGON<br />      seam_keys = []<br />      if ase_me.hasUV: seam_keys = ase_me.ase_uv_channels[1].seams<br />      for k,ase_ed in ase_me.ase_edges.iteritems():<br />         if ase_ed.sharp or not ase_ed.visible or k in seam_keys:<br />            edi = me.findEdges(k[0],k[1])<br />            if edi:<br />               ed = me.edges[edi]<br />               if ase_me.hasUV and k in seam_keys and IMP_SEAMS: ed.flag |= SEAM<br />               if not ase_ed.visible and IMP_FGONS: ed.flag |= FGON<br />               if ase_ed.sharp and IMP_SMOOTHGROUPS:<br />                    ed.flag |= SHARP<br />                  add_EDGESPLIT = True<br /><br /><br /><br />   # add EdgeSplit Modiefier when the mesh has sharp edges<br />   # autosmooth is EXPERIMENTAL! because i dont know if this is correct!<br />   if add_EDGESPLIT and OPT_MOD_EDGESPLIT:<br />      mod = ob.modifiers.append(Blender.Modifier.Types.EDGESPLIT)<br />      if not ase_me.autosmooth:<br />         mod[Blender.Modifier.Settings.EDGESPLIT_FROM_ANGLE] = 0<br />      else:<br />         mod[Blender.Modifier.Settings.EDGESPLIT_ANGLE] = ase_me.autosmooth<br />      mod[Blender.Modifier.Settings.EDGESPLIT_FROM_SHARP] = 1<br />      ob.makeDisplayList() # Needed to apply the modifier<br />   elif not add_EDGESPLIT and ase_me.autosmooth:<br />      AUTOSMOOTH = Mesh.Modes.AUTOSMOOTH<br />      me.modes |= AUTOSMOOTH<br />      me.degr = ase_me.autosmooth<br /><br />   me.update()<br />   counts['verts'] += ase_me.num['VERTEX']<br />   counts['tris'] += ase_me.num['FACES']<br />   counts['faces'] += len(me.faces)<br />   print 'Imported Mesh-Object: ', ob.name<br /><br />#def oj_the_object_jockey(file):<br />def read_file(file):<br />   '''<br />   Read an .ase file and return a list of ase_objects<br />   '''<br />   lines= file.readlines()<br /><br />   print 'Read file...'<br />   PB_index = 0.0<br />   PB_num = float(len(lines))<br />   if OPT_PROGRESSBAR: Blender.Window.DrawProgressBar(0.0, "Read File...")<br /><br />   # it is needed to read UV if Seams should be imported even when importing UV is disabled<br />   READ_UV = False<br />   if IMP_UV or IMP_SEAMS: READ_UV = True<br />   #if IMP_AUTOSMOOTH and not IMP_SMOOTHGROUPS: IMP_AUTOSMOOTH = False<br /><br />   ase_objects = []<br />   ase_ob = False<br />   for line in lines:<br />      if OPT_PROGRESSBAR and not (PB_index % 10000):<br />         Blender.Window.DrawProgressBar(PB_index / PB_num, "Read File...")<br />      PB_index += 1<br /><br />      words = line.split()<br />      if not words:<br />         continue<br />      word0 = words[0]<br />      if word0 == '*GEOMOBJECT':<br />         #if ase_ob: ase_objects.append(ase_ob)<br />         ase_ob_type = word0.lower()[1:-6] #get rid of '*' and 'OBJECT'<br />         ase_ob = Ase_object(ase_ob_type)<br />         ase_objects.append(ase_ob)<br />         continue<br />      elif word0 in ['*HELPEROBJECT','*SHAPEOBJECT','*LIGHTOBJECT','*CAMERAOBJECT','*GROUP']:<br />         # Not supported objects!<br />         # because these objects too use a TM_NODE,<br />         # ase_ob should be set back to False to prevent errors.<br />         ase_ob = False<br />         continue<br />      elif word0 == '*NODE_NAME' and ase_ob:<br />         name = words[1][1:-1] #get rid of '"'<br />         if ase_ob and ase_ob.name != '': ase_ob.ase_data.name = name<br />         elif ase_ob: ase_ob.name = name<br />         continue<br />      elif word0 == '*NODE_PARENT' and ase_ob:<br />         ase_ob.parent = words[1][1:-1] #get rid of '"'<br />         continue<br />      elif word0 == '*TM_ROW0' and ase_ob:<br />         ase_ob.row0 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*TM_ROW1' and ase_ob:<br />         ase_ob.row1 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*TM_ROW2' and ase_ob:<br />         ase_ob.row2 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*TM_ROW3' and ase_ob:<br />         ase_ob.row3 = float(words[1]), float(words[2]), float(words[3])<br />         continue<br />      elif word0 == '*MESH':<br />         ase_me = ase_ob.ase_data<br />         continue<br />      elif word0 == '*MESH_NUMVERTEX':<br />         ase_me.num['VERTEX'] = int(words[1])<br />         continue<br />      elif word0 == '*MESH_NUMFACES':<br />         ase_me.num['FACES'] = int(words[1])<br />         continue<br />      elif word0 == '*MESH_VERTEX':<br />         #vert_index, x, y, z<br />         ase_me.append_vert(int(words[1]),float(words[2]),float(words[3]),float(words[4]))<br />         continue<br />      elif word0 == '*MESH_FACE':<br />         #ase_face_index, vi0, vi1, vi2, AB, BC, CA, smooth_groups, mat_indicies<br />         #smooth = mat = False<br />         ase_face_index = words[1]<br />         if ase_face_index.endswith(':'):<br />            ase_face_index = ase_face_index[:-1]<br /><br />         smooth_groups = mat_indices = []<br />         for i,w in enumerate(words):<br />            if w == '*MESH_SMOOTHING' and IMP_SMOOTHGROUPS:<br />               try:<br />                  if words[i+1] != '*MESH_MTLID':<br />                     smooth_groups = [int(i) for i in words[i+1].split(',')]<br />               except:<br />                  smooth_groups = 0<br />            elif w == '*MESH_MTLID' and IMP_SMOOTHGROUPS:<br />               try:<br />                  mat_indices = [int(i) for i in words[i+1].split(',')]<br />               except:<br />                  mat_indices = 0<br />         ase_me.append_face(int(ase_face_index),int(words[3]),int(words[5]),int(words[7]),int(words[9]),int(words[11]),int(words[13]),smooth_groups,mat_indices)<br />         continue<br />      elif READ_UV:<br />         if word0 == '*MESH_NUMTVERTEX':<br />            if not ase_me.ase_uv_channels: ase_me.append_uv_channel()<br />            ase_me.active_uv.num['TVERTEX'] = int(words[1])<br />            ase_me.hasUV = True<br />            continue<br />         elif word0 == '*MESH_MAPPINGCHANNEL':<br />            # uv_channel_index<br />            ase_me.append_uv_channel(int(words[1]))<br />            continue<br />         elif word0 == '*MESH_TVERT':<br />            #uv_index, u, v, w<br />            ase_me.append_tvert(int(words[1]),float(words[2]),float(words[3]),float(words[4]))<br />            continue<br />         elif word0 == '*MESH_NUMTVFACES':<br />            ase_me.active_uv.num['TVFACES'] = int(words[1])<br />            continue<br />         elif word0 == '*MESH_TFACE':<br />            #ase_face_index, uv0, uv1, uv2, opt_IMP_SEAMS<br />            ase_face_index = words[1]<br />            if ase_face_index.endswith(':'):<br />               ase_face_index = ase_face_index[:-1]<br />            ase_me.append_tface(int(ase_face_index),int(words[2]),int(words[3]),int(words[4]),IMP_SEAMS)<br />            continue<br />      elif IMP_VCOLOR:<br />         if word0 == '*MESH_NUMCVERTEX':<br />            ase_me.num['CVERTEX'] = int(words[1])<br />            if ase_me.num['CVERTEX']:<br />               ase_me.hasVC = True<br />            continue<br />         elif word0 == '*MESH_VERTCOL':<br />            #color_index, r, g, b<br />            ase_me.append_vertcol(int(words[1]),float(words[2]),float(words[3]),float(words[4]))<br />            continue<br />         elif word0 == '*MESH_NUMCVFACES':<br />            ase_me.num['CVFACES'] = words[1]<br />            continue<br />         elif word0 == '*MESH_CFACE':<br />            #ase_face_index, ci0, ci1, ci2<br />            ase_face_index = words[1]<br />            if ase_face_index.endswith(':'):<br />               ase_face_index = ase_face_index[:-1]<br />            ase_me.append_cface(int(ase_face_index),int(words[2]),int(words[3]),int(words[4]))<br />            continue<br />      #elif word0 == '*MESH_NORMALS':<br />      elif IMP_AUTOSMOOTH:<br />         if word0 == '*MESH_FACENORMAL':<br />            # ase_face_index, x, y, z<br />            ase_face_index = int(words[1])<br />            ase_me.append_normal(ase_face_index,float(words[2]),float(words[3]),float(words[4]))<br />            continue<br />         elif word0 == '*MESH_VERTEXNORMAL':<br />            # ase_face_index, ase_vert_index, x, y, z<br />            ase_me.append_vnormal(ase_face_index,int(words[1]),float(words[2]),float(words[3]),float(words[4]),IMP_AUTOSMOOTH)<br />            continue<br />      else:<br />         continue<br />   return ase_objects<br /><br />def print_boxed(text): #Copy/Paste from meshtools, only to remove the beep :)<br />   lines = text.splitlines()<br />   maxlinelen = max(map(len, lines))<br />   if sys.platform[:3] == "win":<br />      print chr(218)+chr(196) + chr(196)*maxlinelen + chr(196)+chr(191) <br />      for line in lines: <br />         print chr(179) + ' ' + line.ljust(maxlinelen) + ' ' + chr(179) <br />      print chr(192)+chr(196) + chr(196)*maxlinelen + chr(196)+chr(217) <br />   else: <br />      print '+-' + '-'*maxlinelen + '-+' <br />      for line in lines: print '| ' + line.ljust(maxlinelen) + ' |' <br />      print '+-' + '-'*maxlinelen + '-+' <br /><br />def read(filename):<br /><br />   global counts<br />   counts = {'verts':0,'tris':0,'faces':0}<br /><br />   start = time.clock()<br /><br />   print_boxed("----------ASCII Scene Import----------")<br />   print 'Import File: ', filename<br /><br />   mode = Blender.Window.EditMode()     # are we in edit mode?  If so ...<br />   if mode: Blender.Window.EditMode(0) # leave edit mode before getting the mesh<br /><br />   file = open(filename,'r', OPT_FILE_BUFFER)<br />   ase_objects = read_file(file)<br />   file.close()<br />   spawn(ase_objects)<br />   Blender.Redraw()<br />   if OPT_PROGRESSBAR: Blender.Window.DrawProgressBar(1.0, '')  # clear progressbar<br />   # Blender.Window.EditMode(mode)<br /><br />   end = time.clock()<br />   seconds = " in %.2f %s" % (end-start, "seconds") <br />   #totals = "Imported Verts: %i Faces: %i Tris: %i " % (counts['verts'],counts['tris'],counts['faces'])<br />   #print_boxed(totals)<br />   message = "Successfully imported " + Blender.sys.basename(filename) + seconds <br />   print_boxed(message)<br /><br /><br /><br /><br />def read_ui(filename): <br /><br />   global IMPORT_SC, IMPORT_VC, IMP_UV, IMPORT_GO, IMPORT_SE, IMPORT_SM<br />   global IMP_SCALED,IMP_SMOOTHGROUPS,IMP_VCOLOR,IMP_UV,IMP_FGONS,IMP_QUADS,IMP_SEAMS,IMP_SMOOTHGROUPS,IMP_AUTOSMOOTH<br /><br />   IMPORT_SC = Blender.Draw.Create(IMP_SCALED)<br />   IMPORT_VC = Blender.Draw.Create(IMP_VCOLOR)<br />   IMP_UV = Blender.Draw.Create(IMP_UV)<br />   IMPORT_SE = Blender.Draw.Create(IMP_SEAMS)<br />   IMPORT_SM = Blender.Draw.Create(IMP_SMOOTHGROUPS)<br /><br />   # Get USER Options <br />   pup_block = [('Import Options'),('Scale Meshes', IMPORT_SC, 'Scale the Objects so that they better fit into Blender\'s grid size'),('Vertex Colors', IMPORT_VC, 'Import Vertex Colors if existing'),('UV (Layer)', IMP_UV, 'Import UV and UV layer\'s if existing'),('Smoothing', IMPORT_SM, 'Surround Smoothgroups with sharp edges'),('Seams', IMPORT_SE, 'Try to import Seams from UV islands (from the first UV layer!)')]<br /><br />   if not Blender.Draw.PupBlock('Import ASCII Scene...', pup_block):<br />      return<br /><br />   Blender.Window.WaitCursor(1)<br /><br />   IMP_SCALED = IMPORT_SC.val<br />   IMP_VCOLOR = IMPORT_VC.val<br />   IMP_UV = IMP_UV.val<br />   IMP_SEAMS = IMPORT_SE.val<br />   IMP_SMOOTHGROUPS = IMPORT_SM.val<br /><br />   read(filename)<br /><br />   Blender.Window.WaitCursor(0)<br />   Blender.Redraw()<br /><br /><br />if __name__ == '__main__' and OPT_FILESELECTOR:<br />   Blender.Window.FileSelector(read_ui, 'Import ASCII Scene', ('.ase'))<br />elif __name__ == '__main__':<br />   read_ui(OPT_STATIC_FILENAME)</div></div>

												<br /><br /><span class="gensmall">Last edited by <a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/memberlist.php?mode=viewprofile&amp;u=12761&amp;sid=4cb509476415554019fb7be197498b2a">Goofos</a> on Sun Jun 17, 2007 7:00 pm, edited 5 times in total.</span>
						<br clear="all" /><br /><table width="100%" cellspacing="0"><tr valign="middle"><td class="gensmall" align="right">
														</td>
						</tr></table></td>
				</tr></table></td>
		</tr><tr class="row1"><td class="profile"><strong><a href="viewtopic.php?p=140320#wrapheader">Top</a></strong></td>
			<td><div class="gensmall" style="float: left;"> <a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/memberlist.php?mode=viewprofile&amp;u=12761&amp;sid=4cb509476415554019fb7be197498b2a"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/imageset/en/icon_user_profile.gif" alt="Profile" title="Profile" /></a>  </div> <div class="gensmall" style="float: right;"> </div></td>
		</tr><tr><td class="spacer" colspan="2" height="1"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/images/spacer.gif" alt="" width="1" height="1" /></td>
	</tr></table><table class="tablebg" width="100%" cellspacing="1"><tr class="row2"><td align="center" valign="middle">
				<a name="p140320" id="p140320"></a>
				<b class="postauthor">Bittoman</b>
			</td>
			<td width="100%" height="25">
				<table width="100%" cellspacing="0"><tr><td class="gensmall" width="100%"><div style="float: left;"> <b>Post subject:</b> </div><div style="float: right;"><a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/viewtopic.php?p=140320&amp;sid=4cb509476415554019fb7be197498b2a#p140320"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/imageset/icon_post_target.gif" width="12" height="9" alt="Post" title="Post" /></a><b>Posted:</b> Mon Apr 17, 2006 1:12 pm </div></td>
				</tr></table></td>
		</tr><tr class="row2"><td valign="top" class="profile">
				<table cellspacing="4" align="center" width="150"><tr><td><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/imageset/en/icon_user_offline.gif" alt="Offline" title="Offline" /></td>
				</tr><tr><td class="postdetails">True believer</td>
				</tr><tr><td><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/download/file.php?avatar=4625.jpg" width="47" height="64" alt="User avatar" /></td>
				</tr></table><span class="postdetails">
					<br /><b>Joined:</b> Sun Aug 29, 2004 10:39 pm<br /><b>Posts:</b> 1730				</span>

			</td>
			<td valign="top">
				<table width="100%" cellspacing="5"><tr><td>
					
						<div class="postbody">Nice job, thanks Goofos!</div>

					<br clear="all" /><br /><table width="100%" cellspacing="0"><tr valign="middle"><td class="gensmall" align="right">
														</td>
						</tr></table></td>
				</tr></table></td>
		</tr><tr class="row2"><td class="profile"><strong><a href="viewtopic.php?p=140320#wrapheader">Top</a></strong></td>
			<td><div class="gensmall" style="float: left;"> <a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/memberlist.php?mode=viewprofile&amp;u=4625&amp;sid=4cb509476415554019fb7be197498b2a"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/imageset/en/icon_user_profile.gif" alt="Profile" title="Profile" /></a>  </div> <div class="gensmall" style="float: right;"> </div></td>
		</tr><tr><td class="spacer" colspan="2" height="1"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/images/spacer.gif" alt="" width="1" height="1" /></td>
	</tr></table><table class="tablebg" width="100%" cellspacing="1"><tr class="row1"><td align="center" valign="middle">
				<a name="p140355" id="p140355"></a>
				<b class="postauthor" style="color: #AA0000">kat</b>
			</td>
			<td width="100%" height="25">
				<table width="100%" cellspacing="0"><tr><td class="gensmall" width="100%"><div style="float: left;"> <b>Post subject:</b> </div><div style="float: right;"><a href="https://web.archive.org/web/20070509181516/http://doom3world.org/phpbb2/viewtopic.php?p=140355&amp;sid=4cb509476415554019fb7be197498b2a#p140355"><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/imageset/icon_post_target.gif" width="12" height="9" alt="Post" title="Post" /></a><b>Posted:</b> Mon Apr 17, 2006 10:30 pm </div></td>
				</tr></table></td>
		</tr><tr class="row1"><td valign="top" class="profile">
				<table cellspacing="4" align="center" width="150"><tr><td><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/styles/subsilver2/imageset/en/icon_user_offline.gif" alt="Offline" title="Offline" /></td>
				</tr><tr><td class="postdetails">"...mostly harmless?!"</td>
				</tr><tr><td><img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/download/file.php?avatar=8.gif" width="48" height="48" alt="User avatar" /></td>
				</tr></table><span class="postdetails">
					<br /><b>Joined:</b> Thu Nov 08, 2001 11:00 pm<br /><b>Posts:</b> 4940<br /><b>Location:</b> UK, York				</span>

			</td>
			<td valign="top">
				<table width="100%" cellspacing="5"><tr><td>




<!--
     FILE ARCHIVED ON 18:15:16 May 9, 2007 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 0:06:51 Sep 26, 2014.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
--></td></tr></table></td></tr></table></div></div></body>
</html>
]]></body></post><post id="140291" date="Posted: Mon Apr 17, 2006 2:00 am    Post subject: ASE Importer"><author>Goofos</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">I made a first small script to import ASE meshes. Its not perfect and may a bit lame but should import correct meshes (from 3DS). Materials are currently not supported but UV coords and VertexColors. &#13;
<br/>
Note: Meshes from 3DS are very big in Blender <img src="https://web.archive.org/web/20061012234522im_/http://doom3world.org/phpbb2/images/smiles/icon_biggrin.gif" alt="Very Happy" border="0"/><br/><br/></span><table width="90%" cellspacing="1" cellpadding="3" border="0" align="center"><tr><td><span class="genmed"><b>Code:</b></span></td>	</tr><tr><td class="code">#!BPY&#13;
<br/><br/>
""" &#13;
<br/>
Name: 'ASCII Scene (.ase) v0.12'&#13;
<br/>
Blender: 242&#13;
<br/>
Group: 'Import' &#13;
<br/>
Tooltip: 'ASCII Scene import (*.ase)' &#13;
<br/>
""" &#13;
<br/>
__author__ = "Goofos"&#13;
<br/>
__version__ = "0.12"&#13;
<br/><br/>
# goofos at epruegel.de &#13;
<br/>
# &#13;
<br/>
# ***** BEGIN GPL LICENSE BLOCK ***** &#13;
<br/>
#&#13;
<br/>
# This program is free software; you can redistribute it and/or&#13;
<br/>
# modify it under the terms of the GNU General Public License &#13;
<br/>
# as published by the Free Software Foundation; either version 2&#13;
<br/>
# of the License, or (at your option) any later version. &#13;
<br/>
# &#13;
<br/>
# This program is distributed in the hope that it will be useful, &#13;
<br/>
# but WITHOUT ANY WARRANTY; without even the implied warranty of &#13;
<br/>
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the &#13;
<br/>
# GNU General Public License for more details. &#13;
<br/>
# &#13;
<br/>
# You should have received a copy of the GNU General Public License &#13;
<br/>
# along with this program; if not, write to the Free Software Foundation, &#13;
<br/>
# Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. &#13;
<br/>
# &#13;
<br/>
# ***** END GPL LICENCE BLOCK ***** &#13;
<br/><br/>
import string, time, sys as osSys &#13;
<br/>
import Blender &#13;
<br/>
from Blender import Draw, Mesh, Window, Object, Scene &#13;
<br/>
#import meshtools &#13;
<br/><br/><br/>
def read_main(filename): &#13;
<br/><br/>
   global counts &#13;
<br/>
   counts = {'verts': 0, 'tris': 0} &#13;
<br/><br/>
   start = time.clock() &#13;
<br/>
   file = open(filename, "r") &#13;
<br/><br/>
   print_boxed("----------------start-----------------")&#13;
<br/>
   print 'Import Patch: ', filename &#13;
<br/><br/>
   editmode = Window.EditMode()    # are we in edit mode?  If so ... &#13;
<br/>
   if editmode: Window.EditMode(0) # leave edit mode before getting the mesh&#13;
<br/><br/>
   lines= file.readlines() &#13;
<br/>
   read_file(file, lines) &#13;
<br/><br/>
   Blender.Window.DrawProgressBar(1.0, '')  # clear progressbar&#13;
<br/>
   file.close() &#13;
<br/>
   print "----------------end-----------------" &#13;
<br/>
   end = time.clock() &#13;
<br/>
   seconds = " in %.2f %s" % (end-start, "seconds") &#13;
<br/>
   totals = "Verts: %i Tris: %i " % (counts['verts'], counts['tris']) &#13;
<br/>
   print_boxed(totals) &#13;
<br/>
   message = "Successfully imported " + Blender.sys.basename(filename) + seconds &#13;
<br/>
   #meshtools.print_boxed(message) &#13;
<br/>
   print_boxed(message) &#13;
<br/><br/><br/>
def print_boxed(text): #Copy/Paste from meshtools, only to remove the beep :) &#13;
<br/>
   lines = text.splitlines() &#13;
<br/>
   maxlinelen = max(map(len, lines)) &#13;
<br/>
   if osSys.platform[:3] == "win": &#13;
<br/>
      print chr(218)+chr(196) + chr(196)*maxlinelen + chr(196)+chr(191) &#13;
<br/>
      for line in lines: &#13;
<br/>
         print chr(179) + ' ' + line.ljust(maxlinelen) + ' ' + chr(179) &#13;
<br/>
      print chr(192)+chr(196) + chr(196)*maxlinelen + chr(196)+chr(217) &#13;
<br/>
   else: &#13;
<br/>
      print '+-' + '-'*maxlinelen + '-+' &#13;
<br/>
      for line in lines: print '| ' + line.ljust(maxlinelen) + ' |' &#13;
<br/>
      print '+-' + '-'*maxlinelen + '-+' &#13;
<br/>
   #print '\a\r', # beep when done &#13;
<br/><br/><br/>
class ase_obj: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.name = 'Name' &#13;
<br/>
      self.objType = None &#13;
<br/>
      self.row0x = None &#13;
<br/>
      self.row0y = None &#13;
<br/>
      self.row0z = None &#13;
<br/>
      self.row1x = None &#13;
<br/>
      self.row1y = None &#13;
<br/>
      self.row1z = None &#13;
<br/>
      self.row2x = None &#13;
<br/>
      self.row2y = None &#13;
<br/>
      self.row2z = None &#13;
<br/>
      self.row3x = None &#13;
<br/>
      self.row3y = None &#13;
<br/>
      self.row3z = None &#13;
<br/>
      self.parent = None &#13;
<br/>
      self.obj = None &#13;
<br/>
      self.objName = 'Name' &#13;
<br/><br/>
class ase_mesh: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.name = '' &#13;
<br/>
      self.vCount = 0 &#13;
<br/>
      self.fCount = 0 &#13;
<br/>
      self.uvVCount = 0 &#13;
<br/>
      self.uvFCount = 0 &#13;
<br/>
      self.vcVCount = 0 &#13;
<br/>
      self.vcFCount = 0 &#13;
<br/>
      self.meVerts = [] &#13;
<br/>
      self.meFaces = [] &#13;
<br/>
      self.uvVerts = [] &#13;
<br/>
      self.uvFaces = [] &#13;
<br/>
      self.vcVerts = [] &#13;
<br/>
      self.vcFaces = [] &#13;
<br/>
      self.hasFUV = 0 &#13;
<br/>
      self.hasVC = 0 &#13;
<br/><br/>
class mesh_face: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.v1 = 0 &#13;
<br/>
      self.v2 = 0 &#13;
<br/>
      self.v3 = 0 &#13;
<br/>
      self.mat = None &#13;
<br/>
       &#13;
<br/>
class mesh_vert: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.x = 0.0 &#13;
<br/>
      self.y = 0.0 &#13;
<br/>
      self.z = 0.0 &#13;
<br/><br/>
class mesh_uvVert: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.index = 0 &#13;
<br/>
      self.u = 0.0 &#13;
<br/>
      self.v = 0.0 &#13;
<br/>
      self.vec = Blender.Mathutils.Vector(self.u, self.v) &#13;
<br/><br/>
class mesh_uvFace: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.index = 0 &#13;
<br/>
      self.uv1 = 0 &#13;
<br/>
      self.uv2 = 0 &#13;
<br/>
      self.uv3 = 0 &#13;
<br/>
       &#13;
<br/>
class mesh_vcVert: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.index = 0 &#13;
<br/>
      self.r = 0 &#13;
<br/>
      self.g = 0 &#13;
<br/>
      self.b = 0 &#13;
<br/>
      self.a = 255 &#13;
<br/>
       &#13;
<br/>
class mesh_vcFace: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.index = 0 &#13;
<br/>
      self.c1 = 0 &#13;
<br/>
      self.c2 = 0 &#13;
<br/>
      self.c3 = 0 &#13;
<br/><br/><br/>
def read_file(file, lines): &#13;
<br/><br/>
   objects = [] &#13;
<br/>
   objIdx = 0 &#13;
<br/>
   objCheck = -1 #needed to skip helper objects &#13;
<br/>
   PBidx = 0.0 &#13;
<br/>
   lineCount = float(len(lines)) &#13;
<br/><br/>
   print 'Read file' &#13;
<br/>
   Blender.Window.DrawProgressBar(0.0, "Read File...") &#13;
<br/><br/>
   for line in lines: &#13;
<br/>
      words = string.split(line) &#13;
<br/><br/>
      if (PBidx % 10000) == 0.0: &#13;
<br/>
                   Blender.Window.DrawProgressBar(PBidx / lineCount, "Read File...") &#13;
<br/><br/>
      if not words: &#13;
<br/>
         continue &#13;
<br/>
      elif words[0] == '*GEOMOBJECT': &#13;
<br/>
         objCheck = 0 &#13;
<br/>
         newObj = ase_obj() &#13;
<br/>
         objects.append(newObj) &#13;
<br/>
         obj = objects[objIdx] &#13;
<br/>
         objIdx += 1 &#13;
<br/>
      elif words[0] == '*NODE_NAME' and objCheck != -1: &#13;
<br/>
         if objCheck == 0: &#13;
<br/>
            obj.name = words[1] &#13;
<br/>
            objCheck = 1 &#13;
<br/>
         elif objCheck == 1: &#13;
<br/>
            obj.objName = words[1] &#13;
<br/>
      elif words[0] == '*TM_ROW0' and objCheck != -1: &#13;
<br/>
         obj.row0x = float(words[1]) &#13;
<br/>
         obj.row0y = float(words[2]) &#13;
<br/>
         obj.row0z = float(words[3]) &#13;
<br/>
      elif words[0] == '*TM_ROW1' and objCheck != -1: &#13;
<br/>
         obj.row1x = float(words[1]) &#13;
<br/>
         obj.row1y = float(words[2]) &#13;
<br/>
         obj.row1z = float(words[3]) &#13;
<br/>
      elif words[0] == '*TM_ROW2' and objCheck != -1: &#13;
<br/>
         obj.row2x = float(words[1]) &#13;
<br/>
         obj.row2y = float(words[2]) &#13;
<br/>
         obj.row2z = float(words[3]) &#13;
<br/>
      elif words[0] == '*TM_ROW3' and objCheck != -1: &#13;
<br/>
         obj.row3x = float(words[1]) &#13;
<br/>
         obj.row3y = float(words[2]) &#13;
<br/>
         obj.row3z = float(words[3]) &#13;
<br/>
         objCheck = -1 &#13;
<br/>
      elif words[0] == '*MESH': &#13;
<br/>
         obj.objType = 'Mesh' &#13;
<br/>
         obj.obj = ase_mesh() &#13;
<br/>
         me = obj.obj &#13;
<br/>
      elif words[0] == '*MESH_NUMVERTEX': &#13;
<br/>
         me.vCount = int(words[1]) &#13;
<br/>
      elif words[0] == '*MESH_NUMFACES': &#13;
<br/>
         me.fCount = int(words[1]) &#13;
<br/>
      elif words[0] == '*MESH_VERTEX': &#13;
<br/>
         #v = mesh_vert() &#13;
<br/>
         v = [float(words[2]),float(words[3]),float(words[4])]&#13;
<br/>
         #v.x = float(words[2])&#13;
<br/>
         #v.y = float(words[3])&#13;
<br/>
         #v.z = float(words[4])&#13;
<br/>
         me.meVerts.append(v) &#13;
<br/>
      elif words[0] == '*MESH_FACE':&#13;
<br/>
         #f = mesh_face()&#13;
<br/>
         f = [int(words[3]),int(words[5]),int(words[7])]&#13;
<br/>
         #f.v1 = int(words[3])&#13;
<br/>
         #f.v2 = int(words[5])&#13;
<br/>
         #f.v3 = int(words[7])&#13;
<br/>
         me.meFaces.append(f) &#13;
<br/>
      elif words[0] == '*MESH_NUMTVERTEX': &#13;
<br/>
         me.uvVCount = int(words[1]) &#13;
<br/>
         if me.uvVCount &gt; 0: &#13;
<br/>
            me.hasFUV = 1 &#13;
<br/>
      elif words[0] == '*MESH_TVERT': &#13;
<br/>
         uv = mesh_uvVert() &#13;
<br/>
         uv.index = int(words[1]) &#13;
<br/>
         uv.u = float(words[2]) &#13;
<br/>
         uv.v = float(words[3]) &#13;
<br/>
         me.uvVerts.append(uv) &#13;
<br/>
      elif words[0] == '*MESH_NUMTVFACES': &#13;
<br/>
         me.uvFCount = int(words[1]) &#13;
<br/>
      elif words[0] == '*MESH_TFACE': &#13;
<br/>
         fUv = mesh_uvFace() &#13;
<br/>
         fUv.index = int(words[1]) &#13;
<br/>
         fUv.uv1 = int(words[2]) &#13;
<br/>
         fUv.uv2 = int(words[3]) &#13;
<br/>
         fUv.uv3 = int(words[4]) &#13;
<br/>
         me.uvFaces.append(fUv) &#13;
<br/>
      elif words[0] == '*MESH_NUMCVERTEX': &#13;
<br/>
         me.vcVCount = int(words[1]) &#13;
<br/>
         if me.uvVCount &gt; 0: &#13;
<br/>
            me.hasVC = 1 &#13;
<br/>
      elif words[0] == '*MESH_VERTCOL': &#13;
<br/>
         c = mesh_vcVert() &#13;
<br/>
         c.index = int(words[1]) &#13;
<br/>
         c.r = round(float(words[2])*256) &#13;
<br/>
         c.g = round(float(words[3])*256) &#13;
<br/>
         c.b = round(float(words[4])*256) &#13;
<br/>
         me.vcVerts.append(c) &#13;
<br/>
      elif words[0] == '*MESH_CFACE': &#13;
<br/>
         fc = mesh_vcFace() &#13;
<br/>
         fc.index = int(words[1]) &#13;
<br/>
         fc.c1 = int(words[2]) &#13;
<br/>
         fc.c2 = int(words[3]) &#13;
<br/>
         fc.c3 = int(words[4]) &#13;
<br/>
         me.vcFaces.append(fc) &#13;
<br/><br/>
      PBidx += 1.0 &#13;
<br/><br/>
   spawn_main(objects) &#13;
<br/><br/>
   Blender.Redraw() &#13;
<br/><br/>
def spawn_main(objects):&#13;
<br/><br/>
   PBidx = 0.0 &#13;
<br/>
   objCount = float(len(objects)) &#13;
<br/><br/>
   print 'Import Objects' &#13;
<br/>
   Blender.Window.DrawProgressBar(0.0, "Importing Objects...") &#13;
<br/><br/>
   for obj in objects: &#13;
<br/><br/>
      Blender.Window.DrawProgressBar(PBidx / objCount, "Importing Objects...") &#13;
<br/><br/>
      if obj.objType == 'Mesh': &#13;
<br/>
         spawn_mesh(obj) &#13;
<br/><br/>
      PBidx += 1.0 &#13;
<br/><br/><br/>
def spawn_mesh(obj):&#13;
<br/><br/>
   objMe = obj.obj&#13;
<br/>
   #normal_flag = 1&#13;
<br/><br/>
   row0 = obj.row0x, obj.row0y, obj.row0z&#13;
<br/>
   row1 = obj.row1x, obj.row1y, obj.row1z&#13;
<br/>
   row2 = obj.row2x, obj.row2y, obj.row2z&#13;
<br/>
   row3 = obj.row3x, obj.row3y, obj.row3z&#13;
<br/><br/>
   newMatrix = Blender.Mathutils.Matrix(row0, row1, row2, row3)&#13;
<br/>
   newMatrix.resize4x4()&#13;
<br/><br/>
   newObj = Blender.Object.New(obj.objType, obj.name)&#13;
<br/>
   newObj.setMatrix(newMatrix)&#13;
<br/>
   Blender.Scene.getCurrent().link(newObj) &#13;
<br/><br/><br/>
   newMesh = Blender.Mesh.New(obj.objName) &#13;
<br/>
   newMesh.getFromObject(newObj.name) &#13;
<br/><br/><br/>
   # Verts &#13;
<br/>
   newMesh.verts.extend(objMe.meVerts)&#13;
<br/><br/>
   # Faces &#13;
<br/>
   newMesh.faces.extend(objMe.meFaces)&#13;
<br/><br/>
   #VertCol &#13;
<br/>
   if guiTable['VC'] == 1 and objMe.hasVC == 1: &#13;
<br/>
      newMesh.vertexColors = 1 &#13;
<br/>
      for c in objMe.vcFaces: &#13;
<br/><br/>
         FCol0 = newMesh.faces[c.index].col[0] &#13;
<br/>
         FCol1 = newMesh.faces[c.index].col[1] &#13;
<br/>
         FCol2 = newMesh.faces[c.index].col[2] &#13;
<br/><br/>
         FCol0.r = int(objMe.vcVerts[c.c1].r) &#13;
<br/>
         FCol0.g = int(objMe.vcVerts[c.c1].g) &#13;
<br/>
         FCol0.b = int(objMe.vcVerts[c.c1].b) &#13;
<br/><br/>
         FCol1.r = int(objMe.vcVerts[c.c2].r) &#13;
<br/>
         FCol1.g = int(objMe.vcVerts[c.c2].g) &#13;
<br/>
         FCol1.b = int(objMe.vcVerts[c.c2].b) &#13;
<br/><br/>
         FCol2.r = int(objMe.vcVerts[c.c3].r) &#13;
<br/>
         FCol2.g = int(objMe.vcVerts[c.c3].g) &#13;
<br/>
         FCol2.b = int(objMe.vcVerts[c.c3].b) &#13;
<br/><br/>
   # UV &#13;
<br/>
   if guiTable['UV'] == 1 and objMe.hasFUV == 1: &#13;
<br/>
      newMesh.faceUV = 1 &#13;
<br/>
      for f in objMe.uvFaces: &#13;
<br/>
         uv1 = Blender.Mathutils.Vector(float(objMe.uvVerts[f.uv1].u), float(objMe.uvVerts[f.uv1].v)) &#13;
<br/>
         uv2 = Blender.Mathutils.Vector(float(objMe.uvVerts[f.uv2].u), float(objMe.uvVerts[f.uv2].v)) &#13;
<br/>
         uv3 = Blender.Mathutils.Vector(float(objMe.uvVerts[f.uv3].u), float(objMe.uvVerts[f.uv3].v)) &#13;
<br/>
         newMesh.faces[f.index].uv = [uv1, uv2, uv3] &#13;
<br/><br/>
   newMesh.transform((newObj.getMatrix('worldspace').invert()), 1) &#13;
<br/>
   newObj.link(newMesh) &#13;
<br/><br/>
   counts['verts'] += objMe.vCount &#13;
<br/>
   counts['tris'] += objMe.fCount &#13;
<br/>
   print 'Imported Mesh-Object: ', obj.name &#13;
<br/><br/><br/><br/>
def read_ui(filename): &#13;
<br/><br/>
   global guiTable, IMPORT_VC, IMPORT_UV &#13;
<br/>
   guiTable = {'VC': 1, 'UV': 1} &#13;
<br/><br/>
   for s in Window.GetScreenInfo(): &#13;
<br/>
      Window.QHandle(s['id']) &#13;
<br/><br/>
   IMPORT_VC = Draw.Create(guiTable['VC']) &#13;
<br/>
   IMPORT_UV = Draw.Create(guiTable['UV']) &#13;
<br/><br/>
   # Get USER Options &#13;
<br/>
   pup_block = [('Import Options'),('Vertex Color', IMPORT_VC, 'Import Vertex Colors if exist'),('UV', IMPORT_UV, 'Import UV if exist'),] &#13;
<br/><br/>
   if not Draw.PupBlock('Import...', pup_block): &#13;
<br/>
      return &#13;
<br/><br/>
   Window.WaitCursor(1)&#13;
<br/><br/>
   guiTable['VC'] = IMPORT_VC.val &#13;
<br/>
   guiTable['UV'] = IMPORT_UV.val &#13;
<br/><br/>
   read_main(filename) &#13;
<br/><br/>
   Window.WaitCursor(0) &#13;
<br/><br/><br/>
if __name__ == '__main__': &#13;
<br/>
   Window.FileSelector(read_ui, 'Import ASCII Scene', ('.ase'))</td>	</tr></table><span class="postbody"/><span class="gensmall"><br/><br/>Last edited by Goofos on Tue Aug 15, 2006 12:25 pm; edited 4 times in total</span></td>
			</tr>]]></body></post><post id="140320" date="Posted: Mon Apr 17, 2006 1:12 pm    Post subject: "><author>Bittoman</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Nice job, thanks Goofos!</span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="140355" date="Posted: Mon Apr 17, 2006 10:30 pm    Post subject: "><author>kat</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Not tried it yet but 'GG' on doing this one. Another step up the ladder for Blender!<br/>_________________<br/><a href="https://web.archive.org/web/20061012234522/http://www.doom3world.org/" target="_blank" class="postlink"><img src="https://web.archive.org/web/20061012234522im_/http://www.doom3world.org/site/img/d3w.gif" border="0"/>Co-Admin</a> - <a href="https://web.archive.org/web/20061012234522/http://www.quake3bits.com/" target="_blank" class="postlink">Modelling and modding tutorials and tips</a></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="143616" date="Posted: Fri May 19, 2006 8:04 pm    Post subject: "><author>kat</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Just tried this script for the 1st time and encountered the following error with Blender 2.41 when run as a script from the text window (Alt+P).&#13;
<br/></span><table width="90%" cellspacing="1" cellpadding="3" border="0" align="center"><tr><td><span class="genmed"><b>Code:</b></span></td>	</tr><tr><td class="code">IndentationError: unindent does not match any outer indentation level&#13;
<br/>
  File "goofosASE_import_17Ap", line 295&#13;
<br/>
    if obj.objType == 'Mesh':&#13;
<br/>
                             ^</td>	</tr></table><span class="postbody"><br/>_________________<br/><a href="https://web.archive.org/web/20061012234522/http://www.doom3world.org/" target="_blank" class="postlink"><img src="https://web.archive.org/web/20061012234522im_/http://www.doom3world.org/site/img/d3w.gif" border="0"/>Co-Admin</a> - <a href="https://web.archive.org/web/20061012234522/http://www.quake3bits.com/" target="_blank" class="postlink">Modelling and modding tutorials and tips</a></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="143762" date="Posted: Sun May 21, 2006 3:58 pm    Post subject: "><author>Goofos</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Should work now. Seems my OS is a bit more tollerant with format errors :&gt;</span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="144077" date="Posted: Fri May 26, 2006 10:43 am    Post subject: "><author>OrbWeaver</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">I haven't tried this but it sounds great. Until now ASE has been almost universally considered an "export-only" format.</span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="144120" date="Posted: Fri May 26, 2006 5:33 pm    Post subject: New error"><author>kat</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">New error when doing Ctrl+P to run the script</span><table width="90%" cellspacing="1" cellpadding="3" border="0" align="center"><tr><td><span class="genmed"><b>Code:</b></span></td>	</tr><tr><td class="code">SyntaxError: invalid token&#13;
<br/>
  File "goofosASE_import_26Ma", line 382&#13;
<br/>
    pup_block = [\&#13;
<br/>
                  ^</td>	</tr></table><span class="postbody"><br/>_________________<br/><a href="https://web.archive.org/web/20061012234522/http://www.doom3world.org/" target="_blank" class="postlink"><img src="https://web.archive.org/web/20061012234522im_/http://www.doom3world.org/site/img/d3w.gif" border="0"/>Co-Admin</a> - <a href="https://web.archive.org/web/20061012234522/http://www.quake3bits.com/" target="_blank" class="postlink">Modelling and modding tutorials and tips</a></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="144546" date="Posted: Wed May 31, 2006 3:07 pm    Post subject: "><author>Goofos</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">There was a space at end of the line if you copy/paste the script from the forum. I have put the array in one line, should work now.</span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="144572" date="Posted: Wed May 31, 2006 6:19 pm    Post subject: "><author>kat</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">DUDE!! sorted. Both vertex and UVW import work fine and dandy.<br/>_________________<br/><a href="https://web.archive.org/web/20061012234522/http://www.doom3world.org/" target="_blank" class="postlink"><img src="https://web.archive.org/web/20061012234522im_/http://www.doom3world.org/site/img/d3w.gif" border="0"/>Co-Admin</a> - <a href="https://web.archive.org/web/20061012234522/http://www.quake3bits.com/" target="_blank" class="postlink">Modelling and modding tutorials and tips</a></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="153676" date="Posted: Tue Aug 15, 2006 12:07 pm    Post subject: "><author>Goofos</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Fixed a problem with the matrices, dont know why this suddenly happened.&#13;
<br/><br/>
[edit]&#13;
<br/>
I quickly updated it again (to v0.12) <img src="https://web.archive.org/web/20061012234522im_/http://doom3world.org/phpbb2/images/smiles/icon_biggrin.gif" alt="Very Happy" border="0"/> to use some improvements of 2.42 (which doesn't worked with 2.40). Now it should import (big) meshes much faster.</span><span class="gensmall"><br/><br/>Last edited by Goofos on Tue Aug 15, 2006 12:34 pm; edited 1 time in total</span></td>
			</tr>]]></body></post><post id="154876" date="Posted: Fri Aug 25, 2006 2:29 am    Post subject: "><author>Tweaker</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Excellent, I was having problems importing with 2.42a, but this seems to have fixed it.  Thanks.   <img src="https://web.archive.org/web/20061012234522im_/http://doom3world.org/phpbb2/images/smiles/icon_biggrin.gif" alt="Very Happy" border="0"/></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="140291" date="Posted: Mon Apr 17, 2006 2:00 am    Post subject: ASE Importer"><author>Goofos</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">I made a first small script to import ASE meshes. Its not perfect and may a bit lame but should import correct meshes (from 3DS). Materials are currently not supported but UV coords and VertexColors. &#13;
<br/>
Note: Meshes from 3DS are very big in Blender <img src="https://web.archive.org/web/20061012234151im_/http://doom3world.org/phpbb2/images/smiles/icon_biggrin.gif" alt="Very Happy" border="0"/><br/><br/></span><table width="90%" cellspacing="1" cellpadding="3" border="0" align="center"><tr><td><span class="genmed"><b>Code:</b></span></td>	</tr><tr><td class="code">#!BPY&#13;
<br/><br/>
""" &#13;
<br/>
Name: 'ASCII Scene (.ase) v0.12'&#13;
<br/>
Blender: 242&#13;
<br/>
Group: 'Import' &#13;
<br/>
Tooltip: 'ASCII Scene import (*.ase)' &#13;
<br/>
""" &#13;
<br/>
__author__ = "Goofos"&#13;
<br/>
__version__ = "0.12"&#13;
<br/><br/>
# goofos at epruegel.de &#13;
<br/>
# &#13;
<br/>
# ***** BEGIN GPL LICENSE BLOCK ***** &#13;
<br/>
#&#13;
<br/>
# This program is free software; you can redistribute it and/or&#13;
<br/>
# modify it under the terms of the GNU General Public License &#13;
<br/>
# as published by the Free Software Foundation; either version 2&#13;
<br/>
# of the License, or (at your option) any later version. &#13;
<br/>
# &#13;
<br/>
# This program is distributed in the hope that it will be useful, &#13;
<br/>
# but WITHOUT ANY WARRANTY; without even the implied warranty of &#13;
<br/>
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the &#13;
<br/>
# GNU General Public License for more details. &#13;
<br/>
# &#13;
<br/>
# You should have received a copy of the GNU General Public License &#13;
<br/>
# along with this program; if not, write to the Free Software Foundation, &#13;
<br/>
# Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. &#13;
<br/>
# &#13;
<br/>
# ***** END GPL LICENCE BLOCK ***** &#13;
<br/><br/>
import string, time, sys as osSys &#13;
<br/>
import Blender &#13;
<br/>
from Blender import Draw, Mesh, Window, Object, Scene &#13;
<br/>
#import meshtools &#13;
<br/><br/><br/>
def read_main(filename): &#13;
<br/><br/>
   global counts &#13;
<br/>
   counts = {'verts': 0, 'tris': 0} &#13;
<br/><br/>
   start = time.clock() &#13;
<br/>
   file = open(filename, "r") &#13;
<br/><br/>
   print_boxed("----------------start-----------------")&#13;
<br/>
   print 'Import Patch: ', filename &#13;
<br/><br/>
   editmode = Window.EditMode()    # are we in edit mode?  If so ... &#13;
<br/>
   if editmode: Window.EditMode(0) # leave edit mode before getting the mesh&#13;
<br/><br/>
   lines= file.readlines() &#13;
<br/>
   read_file(file, lines) &#13;
<br/><br/>
   Blender.Window.DrawProgressBar(1.0, '')  # clear progressbar&#13;
<br/>
   file.close() &#13;
<br/>
   print "----------------end-----------------" &#13;
<br/>
   end = time.clock() &#13;
<br/>
   seconds = " in %.2f %s" % (end-start, "seconds") &#13;
<br/>
   totals = "Verts: %i Tris: %i " % (counts['verts'], counts['tris']) &#13;
<br/>
   print_boxed(totals) &#13;
<br/>
   message = "Successfully imported " + Blender.sys.basename(filename) + seconds &#13;
<br/>
   #meshtools.print_boxed(message) &#13;
<br/>
   print_boxed(message) &#13;
<br/><br/><br/>
def print_boxed(text): #Copy/Paste from meshtools, only to remove the beep :) &#13;
<br/>
   lines = text.splitlines() &#13;
<br/>
   maxlinelen = max(map(len, lines)) &#13;
<br/>
   if osSys.platform[:3] == "win": &#13;
<br/>
      print chr(218)+chr(196) + chr(196)*maxlinelen + chr(196)+chr(191) &#13;
<br/>
      for line in lines: &#13;
<br/>
         print chr(179) + ' ' + line.ljust(maxlinelen) + ' ' + chr(179) &#13;
<br/>
      print chr(192)+chr(196) + chr(196)*maxlinelen + chr(196)+chr(217) &#13;
<br/>
   else: &#13;
<br/>
      print '+-' + '-'*maxlinelen + '-+' &#13;
<br/>
      for line in lines: print '| ' + line.ljust(maxlinelen) + ' |' &#13;
<br/>
      print '+-' + '-'*maxlinelen + '-+' &#13;
<br/>
   #print '\a\r', # beep when done &#13;
<br/><br/><br/>
class ase_obj: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.name = 'Name' &#13;
<br/>
      self.objType = None &#13;
<br/>
      self.row0x = None &#13;
<br/>
      self.row0y = None &#13;
<br/>
      self.row0z = None &#13;
<br/>
      self.row1x = None &#13;
<br/>
      self.row1y = None &#13;
<br/>
      self.row1z = None &#13;
<br/>
      self.row2x = None &#13;
<br/>
      self.row2y = None &#13;
<br/>
      self.row2z = None &#13;
<br/>
      self.row3x = None &#13;
<br/>
      self.row3y = None &#13;
<br/>
      self.row3z = None &#13;
<br/>
      self.parent = None &#13;
<br/>
      self.obj = None &#13;
<br/>
      self.objName = 'Name' &#13;
<br/><br/>
class ase_mesh: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.name = '' &#13;
<br/>
      self.vCount = 0 &#13;
<br/>
      self.fCount = 0 &#13;
<br/>
      self.uvVCount = 0 &#13;
<br/>
      self.uvFCount = 0 &#13;
<br/>
      self.vcVCount = 0 &#13;
<br/>
      self.vcFCount = 0 &#13;
<br/>
      self.meVerts = [] &#13;
<br/>
      self.meFaces = [] &#13;
<br/>
      self.uvVerts = [] &#13;
<br/>
      self.uvFaces = [] &#13;
<br/>
      self.vcVerts = [] &#13;
<br/>
      self.vcFaces = [] &#13;
<br/>
      self.hasFUV = 0 &#13;
<br/>
      self.hasVC = 0 &#13;
<br/><br/>
class mesh_face: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.v1 = 0 &#13;
<br/>
      self.v2 = 0 &#13;
<br/>
      self.v3 = 0 &#13;
<br/>
      self.mat = None &#13;
<br/>
       &#13;
<br/>
class mesh_vert: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.x = 0.0 &#13;
<br/>
      self.y = 0.0 &#13;
<br/>
      self.z = 0.0 &#13;
<br/><br/>
class mesh_uvVert: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.index = 0 &#13;
<br/>
      self.u = 0.0 &#13;
<br/>
      self.v = 0.0 &#13;
<br/>
      self.vec = Blender.Mathutils.Vector(self.u, self.v) &#13;
<br/><br/>
class mesh_uvFace: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.index = 0 &#13;
<br/>
      self.uv1 = 0 &#13;
<br/>
      self.uv2 = 0 &#13;
<br/>
      self.uv3 = 0 &#13;
<br/>
       &#13;
<br/>
class mesh_vcVert: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.index = 0 &#13;
<br/>
      self.r = 0 &#13;
<br/>
      self.g = 0 &#13;
<br/>
      self.b = 0 &#13;
<br/>
      self.a = 255 &#13;
<br/>
       &#13;
<br/>
class mesh_vcFace: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.index = 0 &#13;
<br/>
      self.c1 = 0 &#13;
<br/>
      self.c2 = 0 &#13;
<br/>
      self.c3 = 0 &#13;
<br/><br/><br/>
def read_file(file, lines): &#13;
<br/><br/>
   objects = [] &#13;
<br/>
   objIdx = 0 &#13;
<br/>
   objCheck = -1 #needed to skip helper objects &#13;
<br/>
   PBidx = 0.0 &#13;
<br/>
   lineCount = float(len(lines)) &#13;
<br/><br/>
   print 'Read file' &#13;
<br/>
   Blender.Window.DrawProgressBar(0.0, "Read File...") &#13;
<br/><br/>
   for line in lines: &#13;
<br/>
      words = string.split(line) &#13;
<br/><br/>
      if (PBidx % 10000) == 0.0: &#13;
<br/>
                   Blender.Window.DrawProgressBar(PBidx / lineCount, "Read File...") &#13;
<br/><br/>
      if not words: &#13;
<br/>
         continue &#13;
<br/>
      elif words[0] == '*GEOMOBJECT': &#13;
<br/>
         objCheck = 0 &#13;
<br/>
         newObj = ase_obj() &#13;
<br/>
         objects.append(newObj) &#13;
<br/>
         obj = objects[objIdx] &#13;
<br/>
         objIdx += 1 &#13;
<br/>
      elif words[0] == '*NODE_NAME' and objCheck != -1: &#13;
<br/>
         if objCheck == 0: &#13;
<br/>
            obj.name = words[1] &#13;
<br/>
            objCheck = 1 &#13;
<br/>
         elif objCheck == 1: &#13;
<br/>
            obj.objName = words[1] &#13;
<br/>
      elif words[0] == '*TM_ROW0' and objCheck != -1: &#13;
<br/>
         obj.row0x = float(words[1]) &#13;
<br/>
         obj.row0y = float(words[2]) &#13;
<br/>
         obj.row0z = float(words[3]) &#13;
<br/>
      elif words[0] == '*TM_ROW1' and objCheck != -1: &#13;
<br/>
         obj.row1x = float(words[1]) &#13;
<br/>
         obj.row1y = float(words[2]) &#13;
<br/>
         obj.row1z = float(words[3]) &#13;
<br/>
      elif words[0] == '*TM_ROW2' and objCheck != -1: &#13;
<br/>
         obj.row2x = float(words[1]) &#13;
<br/>
         obj.row2y = float(words[2]) &#13;
<br/>
         obj.row2z = float(words[3]) &#13;
<br/>
      elif words[0] == '*TM_ROW3' and objCheck != -1: &#13;
<br/>
         obj.row3x = float(words[1]) &#13;
<br/>
         obj.row3y = float(words[2]) &#13;
<br/>
         obj.row3z = float(words[3]) &#13;
<br/>
         objCheck = -1 &#13;
<br/>
      elif words[0] == '*MESH': &#13;
<br/>
         obj.objType = 'Mesh' &#13;
<br/>
         obj.obj = ase_mesh() &#13;
<br/>
         me = obj.obj &#13;
<br/>
      elif words[0] == '*MESH_NUMVERTEX': &#13;
<br/>
         me.vCount = int(words[1]) &#13;
<br/>
      elif words[0] == '*MESH_NUMFACES': &#13;
<br/>
         me.fCount = int(words[1]) &#13;
<br/>
      elif words[0] == '*MESH_VERTEX': &#13;
<br/>
         #v = mesh_vert() &#13;
<br/>
         v = [float(words[2]),float(words[3]),float(words[4])]&#13;
<br/>
         #v.x = float(words[2])&#13;
<br/>
         #v.y = float(words[3])&#13;
<br/>
         #v.z = float(words[4])&#13;
<br/>
         me.meVerts.append(v) &#13;
<br/>
      elif words[0] == '*MESH_FACE':&#13;
<br/>
         #f = mesh_face()&#13;
<br/>
         f = [int(words[3]),int(words[5]),int(words[7])]&#13;
<br/>
         #f.v1 = int(words[3])&#13;
<br/>
         #f.v2 = int(words[5])&#13;
<br/>
         #f.v3 = int(words[7])&#13;
<br/>
         me.meFaces.append(f) &#13;
<br/>
      elif words[0] == '*MESH_NUMTVERTEX': &#13;
<br/>
         me.uvVCount = int(words[1]) &#13;
<br/>
         if me.uvVCount &gt; 0: &#13;
<br/>
            me.hasFUV = 1 &#13;
<br/>
      elif words[0] == '*MESH_TVERT': &#13;
<br/>
         uv = mesh_uvVert() &#13;
<br/>
         uv.index = int(words[1]) &#13;
<br/>
         uv.u = float(words[2]) &#13;
<br/>
         uv.v = float(words[3]) &#13;
<br/>
         me.uvVerts.append(uv) &#13;
<br/>
      elif words[0] == '*MESH_NUMTVFACES': &#13;
<br/>
         me.uvFCount = int(words[1]) &#13;
<br/>
      elif words[0] == '*MESH_TFACE': &#13;
<br/>
         fUv = mesh_uvFace() &#13;
<br/>
         fUv.index = int(words[1]) &#13;
<br/>
         fUv.uv1 = int(words[2]) &#13;
<br/>
         fUv.uv2 = int(words[3]) &#13;
<br/>
         fUv.uv3 = int(words[4]) &#13;
<br/>
         me.uvFaces.append(fUv) &#13;
<br/>
      elif words[0] == '*MESH_NUMCVERTEX': &#13;
<br/>
         me.vcVCount = int(words[1]) &#13;
<br/>
         if me.uvVCount &gt; 0: &#13;
<br/>
            me.hasVC = 1 &#13;
<br/>
      elif words[0] == '*MESH_VERTCOL': &#13;
<br/>
         c = mesh_vcVert() &#13;
<br/>
         c.index = int(words[1]) &#13;
<br/>
         c.r = round(float(words[2])*256) &#13;
<br/>
         c.g = round(float(words[3])*256) &#13;
<br/>
         c.b = round(float(words[4])*256) &#13;
<br/>
         me.vcVerts.append(c) &#13;
<br/>
      elif words[0] == '*MESH_CFACE': &#13;
<br/>
         fc = mesh_vcFace() &#13;
<br/>
         fc.index = int(words[1]) &#13;
<br/>
         fc.c1 = int(words[2]) &#13;
<br/>
         fc.c2 = int(words[3]) &#13;
<br/>
         fc.c3 = int(words[4]) &#13;
<br/>
         me.vcFaces.append(fc) &#13;
<br/><br/>
      PBidx += 1.0 &#13;
<br/><br/>
   spawn_main(objects) &#13;
<br/><br/>
   Blender.Redraw() &#13;
<br/><br/>
def spawn_main(objects):&#13;
<br/><br/>
   PBidx = 0.0 &#13;
<br/>
   objCount = float(len(objects)) &#13;
<br/><br/>
   print 'Import Objects' &#13;
<br/>
   Blender.Window.DrawProgressBar(0.0, "Importing Objects...") &#13;
<br/><br/>
   for obj in objects: &#13;
<br/><br/>
      Blender.Window.DrawProgressBar(PBidx / objCount, "Importing Objects...") &#13;
<br/><br/>
      if obj.objType == 'Mesh': &#13;
<br/>
         spawn_mesh(obj) &#13;
<br/><br/>
      PBidx += 1.0 &#13;
<br/><br/><br/>
def spawn_mesh(obj):&#13;
<br/><br/>
   objMe = obj.obj&#13;
<br/>
   #normal_flag = 1&#13;
<br/><br/>
   row0 = obj.row0x, obj.row0y, obj.row0z&#13;
<br/>
   row1 = obj.row1x, obj.row1y, obj.row1z&#13;
<br/>
   row2 = obj.row2x, obj.row2y, obj.row2z&#13;
<br/>
   row3 = obj.row3x, obj.row3y, obj.row3z&#13;
<br/><br/>
   newMatrix = Blender.Mathutils.Matrix(row0, row1, row2, row3)&#13;
<br/>
   newMatrix.resize4x4()&#13;
<br/><br/>
   newObj = Blender.Object.New(obj.objType, obj.name)&#13;
<br/>
   newObj.setMatrix(newMatrix)&#13;
<br/>
   Blender.Scene.getCurrent().link(newObj) &#13;
<br/><br/><br/>
   newMesh = Blender.Mesh.New(obj.objName) &#13;
<br/>
   newMesh.getFromObject(newObj.name) &#13;
<br/><br/><br/>
   # Verts &#13;
<br/>
   newMesh.verts.extend(objMe.meVerts)&#13;
<br/><br/>
   # Faces &#13;
<br/>
   newMesh.faces.extend(objMe.meFaces)&#13;
<br/><br/>
   #VertCol &#13;
<br/>
   if guiTable['VC'] == 1 and objMe.hasVC == 1: &#13;
<br/>
      newMesh.vertexColors = 1 &#13;
<br/>
      for c in objMe.vcFaces: &#13;
<br/><br/>
         FCol0 = newMesh.faces[c.index].col[0] &#13;
<br/>
         FCol1 = newMesh.faces[c.index].col[1] &#13;
<br/>
         FCol2 = newMesh.faces[c.index].col[2] &#13;
<br/><br/>
         FCol0.r = int(objMe.vcVerts[c.c1].r) &#13;
<br/>
         FCol0.g = int(objMe.vcVerts[c.c1].g) &#13;
<br/>
         FCol0.b = int(objMe.vcVerts[c.c1].b) &#13;
<br/><br/>
         FCol1.r = int(objMe.vcVerts[c.c2].r) &#13;
<br/>
         FCol1.g = int(objMe.vcVerts[c.c2].g) &#13;
<br/>
         FCol1.b = int(objMe.vcVerts[c.c2].b) &#13;
<br/><br/>
         FCol2.r = int(objMe.vcVerts[c.c3].r) &#13;
<br/>
         FCol2.g = int(objMe.vcVerts[c.c3].g) &#13;
<br/>
         FCol2.b = int(objMe.vcVerts[c.c3].b) &#13;
<br/><br/>
   # UV &#13;
<br/>
   if guiTable['UV'] == 1 and objMe.hasFUV == 1: &#13;
<br/>
      newMesh.faceUV = 1 &#13;
<br/>
      for f in objMe.uvFaces: &#13;
<br/>
         uv1 = Blender.Mathutils.Vector(float(objMe.uvVerts[f.uv1].u), float(objMe.uvVerts[f.uv1].v)) &#13;
<br/>
         uv2 = Blender.Mathutils.Vector(float(objMe.uvVerts[f.uv2].u), float(objMe.uvVerts[f.uv2].v)) &#13;
<br/>
         uv3 = Blender.Mathutils.Vector(float(objMe.uvVerts[f.uv3].u), float(objMe.uvVerts[f.uv3].v)) &#13;
<br/>
         newMesh.faces[f.index].uv = [uv1, uv2, uv3] &#13;
<br/><br/>
   newMesh.transform((newObj.getMatrix('worldspace').invert()), 1) &#13;
<br/>
   newObj.link(newMesh) &#13;
<br/><br/>
   counts['verts'] += objMe.vCount &#13;
<br/>
   counts['tris'] += objMe.fCount &#13;
<br/>
   print 'Imported Mesh-Object: ', obj.name &#13;
<br/><br/><br/><br/>
def read_ui(filename): &#13;
<br/><br/>
   global guiTable, IMPORT_VC, IMPORT_UV &#13;
<br/>
   guiTable = {'VC': 1, 'UV': 1} &#13;
<br/><br/>
   for s in Window.GetScreenInfo(): &#13;
<br/>
      Window.QHandle(s['id']) &#13;
<br/><br/>
   IMPORT_VC = Draw.Create(guiTable['VC']) &#13;
<br/>
   IMPORT_UV = Draw.Create(guiTable['UV']) &#13;
<br/><br/>
   # Get USER Options &#13;
<br/>
   pup_block = [('Import Options'),('Vertex Color', IMPORT_VC, 'Import Vertex Colors if exist'),('UV', IMPORT_UV, 'Import UV if exist'),] &#13;
<br/><br/>
   if not Draw.PupBlock('Import...', pup_block): &#13;
<br/>
      return &#13;
<br/><br/>
   Window.WaitCursor(1)&#13;
<br/><br/>
   guiTable['VC'] = IMPORT_VC.val &#13;
<br/>
   guiTable['UV'] = IMPORT_UV.val &#13;
<br/><br/>
   read_main(filename) &#13;
<br/><br/>
   Window.WaitCursor(0) &#13;
<br/><br/><br/>
if __name__ == '__main__': &#13;
<br/>
   Window.FileSelector(read_ui, 'Import ASCII Scene', ('.ase'))</td>	</tr></table><span class="postbody"/><span class="gensmall"><br/><br/>Last edited by Goofos on Tue Aug 15, 2006 12:25 pm; edited 4 times in total</span></td>
			</tr>]]></body></post><post id="140320" date="Posted: Mon Apr 17, 2006 1:12 pm    Post subject: "><author>Bittoman</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Nice job, thanks Goofos!</span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="140355" date="Posted: Mon Apr 17, 2006 10:30 pm    Post subject: "><author>kat</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Not tried it yet but 'GG' on doing this one. Another step up the ladder for Blender!<br/>_________________<br/><a href="https://web.archive.org/web/20061012234151/http://www.doom3world.org/" target="_blank" class="postlink"><img src="https://web.archive.org/web/20061012234151im_/http://www.doom3world.org/site/img/d3w.gif" border="0"/>Co-Admin</a> - <a href="https://web.archive.org/web/20061012234151/http://www.quake3bits.com/" target="_blank" class="postlink">Modelling and modding tutorials and tips</a></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="143616" date="Posted: Fri May 19, 2006 8:04 pm    Post subject: "><author>kat</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Just tried this script for the 1st time and encountered the following error with Blender 2.41 when run as a script from the text window (Alt+P).&#13;
<br/></span><table width="90%" cellspacing="1" cellpadding="3" border="0" align="center"><tr><td><span class="genmed"><b>Code:</b></span></td>	</tr><tr><td class="code">IndentationError: unindent does not match any outer indentation level&#13;
<br/>
  File "goofosASE_import_17Ap", line 295&#13;
<br/>
    if obj.objType == 'Mesh':&#13;
<br/>
                             ^</td>	</tr></table><span class="postbody"><br/>_________________<br/><a href="https://web.archive.org/web/20061012234151/http://www.doom3world.org/" target="_blank" class="postlink"><img src="https://web.archive.org/web/20061012234151im_/http://www.doom3world.org/site/img/d3w.gif" border="0"/>Co-Admin</a> - <a href="https://web.archive.org/web/20061012234151/http://www.quake3bits.com/" target="_blank" class="postlink">Modelling and modding tutorials and tips</a></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="143762" date="Posted: Sun May 21, 2006 3:58 pm    Post subject: "><author>Goofos</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Should work now. Seems my OS is a bit more tollerant with format errors :&gt;</span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="144077" date="Posted: Fri May 26, 2006 10:43 am    Post subject: "><author>OrbWeaver</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">I haven't tried this but it sounds great. Until now ASE has been almost universally considered an "export-only" format.</span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="144120" date="Posted: Fri May 26, 2006 5:33 pm    Post subject: New error"><author>kat</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">New error when doing Ctrl+P to run the script</span><table width="90%" cellspacing="1" cellpadding="3" border="0" align="center"><tr><td><span class="genmed"><b>Code:</b></span></td>	</tr><tr><td class="code">SyntaxError: invalid token&#13;
<br/>
  File "goofosASE_import_26Ma", line 382&#13;
<br/>
    pup_block = [\&#13;
<br/>
                  ^</td>	</tr></table><span class="postbody"><br/>_________________<br/><a href="https://web.archive.org/web/20061012234151/http://www.doom3world.org/" target="_blank" class="postlink"><img src="https://web.archive.org/web/20061012234151im_/http://www.doom3world.org/site/img/d3w.gif" border="0"/>Co-Admin</a> - <a href="https://web.archive.org/web/20061012234151/http://www.quake3bits.com/" target="_blank" class="postlink">Modelling and modding tutorials and tips</a></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="144546" date="Posted: Wed May 31, 2006 3:07 pm    Post subject: "><author>Goofos</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">There was a space at end of the line if you copy/paste the script from the forum. I have put the array in one line, should work now.</span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="144572" date="Posted: Wed May 31, 2006 6:19 pm    Post subject: "><author>kat</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">DUDE!! sorted. Both vertex and UVW import work fine and dandy.<br/>_________________<br/><a href="https://web.archive.org/web/20061012234151/http://www.doom3world.org/" target="_blank" class="postlink"><img src="https://web.archive.org/web/20061012234151im_/http://www.doom3world.org/site/img/d3w.gif" border="0"/>Co-Admin</a> - <a href="https://web.archive.org/web/20061012234151/http://www.quake3bits.com/" target="_blank" class="postlink">Modelling and modding tutorials and tips</a></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="153676" date="Posted: Tue Aug 15, 2006 12:07 pm    Post subject: "><author>Goofos</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Fixed a problem with the matrices, dont know why this suddenly happened.&#13;
<br/><br/>
[edit]&#13;
<br/>
I quickly updated it again (to v0.12) <img src="https://web.archive.org/web/20061012234151im_/http://doom3world.org/phpbb2/images/smiles/icon_biggrin.gif" alt="Very Happy" border="0"/> to use some improvements of 2.42 (which doesn't worked with 2.40). Now it should import (big) meshes much faster.</span><span class="gensmall"><br/><br/>Last edited by Goofos on Tue Aug 15, 2006 12:34 pm; edited 1 time in total</span></td>
			</tr>]]></body></post><post id="154876" date="Posted: Fri Aug 25, 2006 2:29 am    Post subject: "><author>Tweaker</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Excellent, I was having problems importing with 2.42a, but this seems to have fixed it.  Thanks.   <img src="https://web.archive.org/web/20061012234151im_/http://doom3world.org/phpbb2/images/smiles/icon_biggrin.gif" alt="Very Happy" border="0"/></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="140291" date="Posted: Mon Apr 17, 2006 2:00 am    Post subject: ASE Importer"><author>Goofos</author><body><![CDATA[<tr>
  <td colspan="2">
    <span class="postbody"><img src="https://web.archive.org/web/20070509181516im_/http://www.doom3world.org/phpbb2/images/smiles/icon_arrow.gif" alt="Arrow" border="0"/> Version: 0.13&#13;
<br/><br/>
Supports Mesh Objects with vertex colors, multiple UV, smoothgroups.&#13;
<br/><br/>
A little Note!: you should not try to import very big ase files (&gt;50 MB with 512 MB RAM). With much RAM you might can try this.&#13;
<br/><br/></span>
    <table width="90%" cellspacing="1" cellpadding="3" border="0" align="center">
      <tr><td><span class="genmed"><b>Code:</b></span></td>	</tr>
      <tr>
        <td class="code">#!BPY&#13;
<br/><br/>
"""&#13;
<br/>
Name: 'ASCII Scene (.ase) v0.13'&#13;
<br/>
Blender: 244&#13;
<br/>
Group: 'Import'&#13;
<br/>
Tooltip: 'Import from ASCII Scene Export file format (.ase)'&#13;
<br/>
""" &#13;
<br/>
__author__ = "Goofos"&#13;
<br/>
__version__ = "0.13"&#13;
<br/><br/>
# goofos&#13;
<br/>
#&#13;
<br/>
# ***** BEGIN GPL LICENSE BLOCK *****&#13;
<br/>
#&#13;
<br/>
# This program is free software; you can redistribute it and/or&#13;
<br/>
# modify it under the terms of the GNU General Public License&#13;
<br/>
# as published by the Free Software Foundation; either version 2&#13;
<br/>
# of the License, or (at your option) any later version.&#13;
<br/>
# &#13;
<br/>
# This program is distributed in the hope that it will be useful,&#13;
<br/>
# but WITHOUT ANY WARRANTY; without even the implied warranty of&#13;
<br/>
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&#13;
<br/>
# GNU General Public License for more details.&#13;
<br/>
# &#13;
<br/>
# You should have received a copy of the GNU General Public License&#13;
<br/>
# along with this program; if not, write to the Free Software Foundation,&#13;
<br/>
# Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.&#13;
<br/>
# &#13;
<br/>
# ***** END GPL LICENCE BLOCK *****&#13;
<br/><br/>
import time, sys&#13;
<br/>
import Blender&#13;
<br/>
from Blender import Scene, Object, Mesh&#13;
<br/><br/>
'''&#13;
<br/>
Some Options&#13;
<br/>
'''&#13;
<br/>
# Scale Factor (float)&#13;
<br/>
OPT_SCALE = 0.1&#13;
<br/>
# Add EdgeSplit Modifier when importing sharp edges (bool)&#13;
<br/>
OPT_MOD_EDGESPLIT = True&#13;
<br/>
# Enable the fileselector (bool)&#13;
<br/>
OPT_FILESELECTOR = True&#13;
<br/>
# If the fileselector is disabled, specify a static filename (string)&#13;
<br/>
OPT_STATIC_FILENAME = 'E:\ASE Files\garage.ASE'&#13;
<br/>
# Enable Progressbar (bool)&#13;
<br/>
OPT_PROGRESSBAR = False&#13;
<br/>
# File buffer. After testing with big files i think there is no real difference.&#13;
<br/>
# -1 = system default, 0 = unbuffered, 1 = line buffered, &gt;1 = buffer size&#13;
<br/>
OPT_FILE_BUFFER = -1&#13;
<br/><br/>
'''&#13;
<br/>
Import Options&#13;
<br/>
'''&#13;
<br/>
# Import Meshes scaled, defined by the scale factor of OPT_SCALE (bool)&#13;
<br/>
# Note: Object location data looses some precision, .. i think!&#13;
<br/>
IMP_SCALED = True&#13;
<br/>
# Import Vertex Colors (bool)&#13;
<br/>
IMP_VCOLOR = True&#13;
<br/>
# Import UV Coords and UV layers (bool)&#13;
<br/>
IMP_UV = True&#13;
<br/>
# Import NGons as Blender FGons (bool)&#13;
<br/>
# Note: Include quads, too.&#13;
<br/>
IMP_FGONS = False&#13;
<br/>
# Try to find possible quads and convert the two tris to a quad (bool)&#13;
<br/>
# Note: Very slow!! ablsolutely doesn't work accurate :/&#13;
<br/>
# i don't know wether this is a script problem or a blender problem!&#13;
<br/>
IMP_QUADS = False&#13;
<br/>
# Surround UV islands with seams (bool)&#13;
<br/>
IMP_SEAMS = False&#13;
<br/>
# Surround smooth groups with sharp edges (bool)&#13;
<br/>
IMP_SMOOTHGROUPS = True&#13;
<br/>
# Try to find the lowest autosmooth angle in vertex normals (bool)&#13;
<br/>
# Note: i dont know if this is correct :&gt;&#13;
<br/>
IMP_AUTOSMOOTH = False&#13;
<br/><br/><br/><br/><br/><br/>
class Ase_group:&#13;
<br/>
   def __init__(self):&#13;
<br/>
      self.name = 'Name'&#13;
<br/>
      self.ase_type = 'GROUP'&#13;
<br/>
      self.ase_helper = None&#13;
<br/>
      self.ase_objects = []&#13;
<br/><br/>
class Ase_object:&#13;
<br/><br/>
   def __init__(self, ase_object_type, name=''):&#13;
<br/>
      #if ase_object_type not in ['GEOM','HELPER','SHAPE','LIGHT','CAMERA']: return&#13;
<br/>
      if ase_object_type not in ['geom','helper','shape','light','camera']: return&#13;
<br/>
      self.name = name&#13;
<br/>
      self.ase_type = ase_object_type #GEOM, HELPER, SHAPE, LIGHT, CAMERA&#13;
<br/>
      self.row0 = None&#13;
<br/>
      self.row1 = None&#13;
<br/>
      self.row2 = None&#13;
<br/>
      self.row3 = None&#13;
<br/>
      self.parent = None&#13;
<br/><br/>
      #new_ase_data = None&#13;
<br/>
      if ase_object_type == 'geom':&#13;
<br/>
         new_ase_data = Ase_mesh(self)&#13;
<br/>
      self.ase_data = new_ase_data&#13;
<br/><br/>
class Ase_mesh:&#13;
<br/>
   def __init__(self, ase_obj=None):&#13;
<br/>
      self.name = 'Name'&#13;
<br/>
      self.num = {'VERTS':0,'FACES':0,'CVERTEX':0,'CVFACES':0}&#13;
<br/>
      self.ase_verts = {}&#13;
<br/>
      self.vertseq = []&#13;
<br/>
      self.ase_edges = {}&#13;
<br/>
      self.ase_faces = {}&#13;
<br/>
      self.faceseq = []&#13;
<br/>
      self.ase_uv_channels = {}&#13;
<br/>
      self.active_uv = None&#13;
<br/>
      self.ase_vertcolors = {}&#13;
<br/>
      self.ase_cfaces = {}&#13;
<br/>
      self.autosmooth = 0&#13;
<br/>
      self.hasUV = 0&#13;
<br/>
      self.hasVC = 0 &#13;
<br/><br/>
   def sort_edgekeys(self,vi0,vi1,vi2):&#13;
<br/>
      '''&#13;
<br/>
      Returns sorted edge keys of the given triangle vert indicies.&#13;
<br/>
      '''&#13;
<br/>
      if vi0 &gt; vi1: ed_k0 = vi1,vi0&#13;
<br/>
      else: ed_k0 = vi0,vi1&#13;
<br/>
      if vi1 &gt; vi2: ed_k1 = vi2,vi1&#13;
<br/>
      else: ed_k1 = vi1,vi2&#13;
<br/>
      if vi0 &gt; vi2: ed_k2 = vi2,vi0&#13;
<br/>
      else: ed_k2 = vi0,vi2&#13;
<br/>
      return ed_k0,ed_k1,ed_k2&#13;
<br/><br/>
   def append_vert(self, ase_vert_index, x, y, z):&#13;
<br/>
      '''&#13;
<br/>
      Create a new Vertex for this Mesh.&#13;
<br/>
      '''&#13;
<br/>
      ase_v = Ase_vert(ase_vert_index, x, y, z)&#13;
<br/>
      self.ase_verts[ase_vert_index] = ase_v&#13;
<br/>
      #self.vertseq.insert(ase_vert_index, (ase_v.co.x,ase_v.co.y,ase_v.co.z))&#13;
<br/>
      self.vertseq.insert(ase_vert_index, ase_v.co)&#13;
<br/>
      &#13;
<br/>
   def append_face(self, index, vi0, vi1, vi2, AB=1, BC=1, CA=1, smooth_groups=[0], mat_indices=0):&#13;
<br/>
      '''&#13;
<br/>
      Uhm ... work in progress!&#13;
<br/>
      '''&#13;
<br/>
      # create a new Ase_face&#13;
<br/>
      ase_f = Ase_face(index, vi0, vi1, vi2, smooth_groups, mat_indices)&#13;
<br/>
      ed_keys = self.sort_edgekeys(vi0,vi1,vi2)&#13;
<br/>
      #ed_keys = [vi0,vi1].sort(),[vi1,vi2].sort(),[vi0,vi2].sort()&#13;
<br/>
      ase_f.edge_keys = ed_keys&#13;
<br/>
      ase_f.vis_sum = AB+BC+CA&#13;
<br/>
      if ase_f.vis_sum == 2:&#13;
<br/>
         if not AB: ase_f.tri_edge = ed_keys[0]&#13;
<br/>
         elif not BC: ase_f.tri_edge = ed_keys[1]&#13;
<br/>
         elif not CA: ase_f.tri_edge = ed_keys[2]&#13;
<br/><br/>
      # set visibility (fgon) and sharp for edges&#13;
<br/>
      # and look if the two face users might form a quad&#13;
<br/>
      # or create a new Ase_edge&#13;
<br/>
      for k,vis in zip(ed_keys,[AB,BC,CA]):&#13;
<br/>
         # Ase_edge already exist or create a new one&#13;
<br/>
         if not self.ase_edges.has_key(k):&#13;
<br/>
            ase_ed = Ase_edge(k)&#13;
<br/>
            ase_ed.fusers.append(ase_f.index)&#13;
<br/>
            ase_ed.visible = vis&#13;
<br/>
            self.ase_edges[k] = ase_ed&#13;
<br/>
            continue&#13;
<br/>
         else:&#13;
<br/>
            ase_ed = self.ase_edges[k]&#13;
<br/>
            ase_ed.fusers.append(ase_f.index)&#13;
<br/>
            if ase_f.vis_sum == 2 and not ase_ed.visible:&#13;
<br/>
               ase_f.tri_edge = k&#13;
<br/><br/>
         fusers = [i for i in ase_ed.fusers if i != ase_f.index]&#13;
<br/>
         if not fusers: continue&#13;
<br/>
         for i in fusers:&#13;
<br/>
            ase_f2 = self.ase_faces[i]&#13;
<br/>
            # if this edge is invisible and both tris only have&#13;
<br/>
            # this invisible edge, than the two tris could form a quad&#13;
<br/>
            # easy done with a sum of all vis variables of the edges&#13;
<br/>
            if k == ase_f.tri_edge:&#13;
<br/>
               if ase_f.tri_edge == ase_f2.tri_edge:&#13;
<br/>
                  ase_f.quad_team = ase_f2.index&#13;
<br/>
                  ase_f2.quad_team = ase_f.index&#13;
<br/><br/>
            # look if this edge is sharp&#13;
<br/>
            # if not both faces share at least one smoothgroup var&#13;
<br/>
            # than this edge is sharp&#13;
<br/>
            #if ase_ed.sharp: continue&#13;
<br/>
            for sg in smooth_groups:&#13;
<br/>
               if sg not in ase_f2.smooth_groups:&#13;
<br/>
                  ase_ed.sharp = True&#13;
<br/><br/>
      self.ase_faces[ase_f.index] = ase_f&#13;
<br/>
      self.faceseq.insert(ase_f.index, (ase_f.v0, ase_f.v1, ase_f.v2))&#13;
<br/><br/>
   def append_uv_channel(self, layer_index=1):&#13;
<br/>
      ''' &#13;
<br/>
      Create a new UV Layer and set it active.&#13;
<br/>
      '''&#13;
<br/>
      self.ase_uv_channels[layer_index] = Ase_uv_channel(layer_index)&#13;
<br/>
      self.active_uv = self.ase_uv_channels[layer_index]&#13;
<br/><br/>
   def append_tvert(self, ase_uv_index, u, v, w=0):&#13;
<br/>
      '''&#13;
<br/>
      Create a new UV Vector in the active! UV Channel.&#13;
<br/>
      '''&#13;
<br/>
      if not self.active_uv: return&#13;
<br/>
      #self.active_uv.ase_tverts[ase_uv_index] = Ase_tvert(ase_uv_index,u,v,w)&#13;
<br/>
      self.active_uv.ase_tverts[ase_uv_index] = (u,v)&#13;
<br/><br/>
   def append_tface(self, ase_face_index, uvi0, uvi1, uvi2, opt_check_seams=False):&#13;
<br/>
      '''&#13;
<br/>
      Create a new Face UV with indicies to UV Vectors in the active UV Layer.&#13;
<br/>
      Optional check for Seams and store into the UV Channel.&#13;
<br/>
      '''&#13;
<br/>
      if not self.active_uv: return&#13;
<br/>
      self.active_uv.ase_tfaces[ase_face_index] = [uvi0, uvi1, uvi2]&#13;
<br/>
      # look if this face has seams&#13;
<br/>
      # might useless because it makes no sense to import seams for all UV layers&#13;
<br/>
      # that's why those edge keys are separately written to each ase UV layer&#13;
<br/>
      if opt_check_seams:&#13;
<br/>
         edge_keys = self.ase_faces[ase_face_index].edge_keys&#13;
<br/>
         for ed_key,uvs in zip(edge_keys,[[uvi0,uvi1],[uvi1,uvi2],[uvi0,uvi2]]):&#13;
<br/>
            uvs.sort()&#13;
<br/>
            ase_ed,active_uv = self.ase_edges[ed_key],self.active_uv&#13;
<br/>
            if not active_uv.ase_tedges.has_key(ed_key):&#13;
<br/>
               active_uv.ase_tedges[ed_key] = uvs&#13;
<br/>
               continue&#13;
<br/>
            elif active_uv.ase_tedges[ed_key] != uvs:&#13;
<br/>
               active_uv.seams.append(ed_key)&#13;
<br/><br/>
   def append_vertcol(self, ase_color_index, r, g, b):&#13;
<br/>
      #new = Ase_vertcolor(ase_color_index, r, g, b)&#13;
<br/>
      #self.ase_vertcolors[ase_color_index] = new&#13;
<br/>
      self.ase_vertcolors[ase_color_index] = (r,g,b)&#13;
<br/>
      &#13;
<br/>
   def append_cface(self, ase_face_index, ci0, ci1, ci2):&#13;
<br/>
      ase_f = self.ase_faces[ase_face_index]&#13;
<br/>
      #f.c0, f.c1, f.c2 = ci0, ci1, ci2&#13;
<br/>
      self.ase_cfaces[ase_face_index] = (ci0, ci1, ci2)&#13;
<br/><br/>
   def append_normal(self, ase_face_index, x, y, z):&#13;
<br/>
      self.ase_faces[ase_face_index].normal = Blender.Mathutils.Vector(x,y,z)&#13;
<br/><br/>
   def append_vnormal(self, ase_face_index, ase_vert_index, x, y, z, opt_check_smooth=False):&#13;
<br/>
      ase_f = self.ase_faces[ase_face_index]&#13;
<br/>
      self.ase_verts[ase_vert_index].normals[ase_face_index] = Blender.Mathutils.Vector(x,y,z)&#13;
<br/>
      if opt_check_smooth and ase_f.smooth_groups:&#13;
<br/>
         ase_edges = [self.ase_edges[key] for key in ase_f.edge_keys]&#13;
<br/>
         for ed_key,ase_ed in zip(ase_f.edge_keys,ase_edges):&#13;
<br/>
            if ase_ed.sharp or len(ase_ed.fusers) &lt; 2: continue&#13;
<br/>
            for vi in ed_key:&#13;
<br/>
               if not self.ase_verts.has_key(vi): continue&#13;
<br/>
               vnormals = self.ase_verts[vi].normals&#13;
<br/>
               fi0, fi1 = ase_ed.fusers[0:2]&#13;
<br/>
               if vnormals.has_key(fi0) and vnormals.has_key(fi1):&#13;
<br/>
                  vnor0, vnor1 = vnormals[fi0],vnormals[fi1]&#13;
<br/>
                  if vnor0 == vnor1:&#13;
<br/>
                     continue&#13;
<br/>
                  else:&#13;
<br/>
                     angle = round(Blender.Mathutils.AngleBetweenVecs(vnor0, vnor1))&#13;
<br/>
                     if not self.autosmooth: self.autosmooth = angle&#13;
<br/>
                     elif angle and self.autosmooth &gt; angle:&#13;
<br/>
                        print angle&#13;
<br/>
                        self.autosmooth = angle&#13;
<br/><br/><br/>
class Ase_vert:&#13;
<br/>
   def __init__(self, index, x, y, z):&#13;
<br/>
      self.index = index&#13;
<br/>
      #self.co = Blender.Mathutils.Vector(x,y,z)&#13;
<br/>
      self.co = (x,y,z)&#13;
<br/>
      self.normals = {}&#13;
<br/><br/>
class Ase_edge:&#13;
<br/>
   def __init__(self, key):&#13;
<br/>
      self.key = key&#13;
<br/>
      self.fusers = []&#13;
<br/>
      self.uvs = None&#13;
<br/>
      self.visible = 1&#13;
<br/>
      self.sharp = False&#13;
<br/><br/>
class Ase_face:&#13;
<br/>
   def __init__(self, ase_face_index, v0, v1, v2, smooth_groups=0, mat_indices=0):&#13;
<br/>
      self.index = ase_face_index&#13;
<br/>
      self.v0 = v0&#13;
<br/>
      self.v1 = v1&#13;
<br/>
      self.v2 = v2&#13;
<br/>
      self.edge_keys = None&#13;
<br/>
      self.c0 = None&#13;
<br/>
      self.c1 = None&#13;
<br/>
      self.c2 = None&#13;
<br/>
      self.normal = None&#13;
<br/>
      #self.vert_normals = {}&#13;
<br/>
      self.mat_indices = mat_indices&#13;
<br/>
      self.smooth_groups = smooth_groups # 0 = solid face&#13;
<br/>
      self.vis_sum = 3&#13;
<br/>
      self.quad_team = None&#13;
<br/>
      self.tri_edge = None&#13;
<br/><br/>
class Ase_uv_channel:&#13;
<br/>
   def __init__(self, index=1):&#13;
<br/>
      self.index = index&#13;
<br/>
      self.num = {'TVERTEX':0,'TVFACES':0}&#13;
<br/>
      self.uv_layer_name = 'UVTex#' + str(self.index)&#13;
<br/>
      self.ase_tverts = {}&#13;
<br/>
      self.ase_tfaces = {}&#13;
<br/>
      self.ase_tedges = {}&#13;
<br/>
      self.seams = []&#13;
<br/><br/>
class Ase_tvert:&#13;
<br/>
   def __init__(self,index, u, v, w=0):&#13;
<br/>
      self.index = index&#13;
<br/>
      #self.vec = Blender.Mathutils.Vector(u,v)&#13;
<br/>
      self.vec = (u,v)&#13;
<br/><br/>
class Ase_tface:&#13;
<br/>
   def __init__(self, index, uvi0, uvi1, uvi2):&#13;
<br/>
      self.index = index&#13;
<br/>
      self.uv = {0:uvi0, 1:uvi1, 2:uvi2}&#13;
<br/><br/>
class Ase_vertcolor:&#13;
<br/>
   def __init__(self, index, r, g, b):&#13;
<br/>
      self.index = 0 &#13;
<br/>
      self.r = round(r*256)&#13;
<br/>
      self.g = round(g*256)&#13;
<br/>
      self.b = round(b*256)&#13;
<br/>
      self.a = 255.0&#13;
<br/><br/><br/>
def spawn(ase_objects):&#13;
<br/><br/>
   PB_index = 0.0&#13;
<br/>
   PB_num = float(len(ase_objects))&#13;
<br/><br/>
   print 'Import Objects...'&#13;
<br/>
   if OPT_PROGRESSBAR: Blender.Window.DrawProgressBar(0.0, "Importing Objects...")&#13;
<br/><br/>
   scene = Blender.Scene.GetCurrent()&#13;
<br/>
   for ase_ob in ase_objects: &#13;
<br/>
      if OPT_PROGRESSBAR and not (PB_index % PB_num):&#13;
<br/>
         Blender.Window.DrawProgressBar(PB_index / PB_num, "Importing Objects...")&#13;
<br/><br/>
      if ase_ob.ase_type == 'geom':&#13;
<br/>
         spawn_mesh(scene,ase_ob)&#13;
<br/><br/>
      PB_index += 1.0&#13;
<br/><br/>
def spawn_mesh(scene,ase_ob):&#13;
<br/><br/>
   ase_me = ase_ob.ase_data&#13;
<br/>
   #normal_flag = 1&#13;
<br/><br/>
   row0 = ase_ob.row0&#13;
<br/>
   row1 = ase_ob.row1&#13;
<br/>
   row2 = ase_ob.row2&#13;
<br/>
   row3 = ase_ob.row3&#13;
<br/><br/>
   matrix = Blender.Mathutils.Matrix(row0, row1, row2, row3)&#13;
<br/>
   matrix.resize4x4()&#13;
<br/><br/>
   # create new Blender Object and link to scene&#13;
<br/>
   ob = Blender.Object.New('Mesh', ase_ob.name)&#13;
<br/>
   ob.setMatrix(matrix)&#13;
<br/>
   scene.objects.link(ob)&#13;
<br/><br/>
   # get Mesh data from Object&#13;
<br/>
   me = ob.getData(0,1)&#13;
<br/>
   me.vertexColors = me.faceUV = False&#13;
<br/><br/>
   # create Verts and Faces&#13;
<br/>
   # seems like extend() is limited to a length of 64000?&#13;
<br/>
   # this is a problem when importing big meshes.&#13;
<br/>
   div = divmod(ase_me.num['VERTEX'], 64000)&#13;
<br/>
   if div[1]: div = div[0]+1&#13;
<br/>
   else: div = div[0]&#13;
<br/>
   start = 0&#13;
<br/>
   for i in range(div):&#13;
<br/>
      end = start+64000&#13;
<br/>
      me.verts.extend(ase_me.vertseq[start:end])&#13;
<br/>
      start = end&#13;
<br/>
   div = divmod(ase_me.num['FACES'], 64000)&#13;
<br/>
   face_index_list = []&#13;
<br/>
   if div[1]: div = div[0]+1&#13;
<br/>
   else: div = div[0]&#13;
<br/>
   start = 0&#13;
<br/>
   for i in range(div):&#13;
<br/>
      end = start+64000&#13;
<br/>
      me.faces.extend(ase_me.faceseq[start:end])&#13;
<br/>
      start = end&#13;
<br/><br/>
   # import Vertex Colors, Solid/Smooth to faces&#13;
<br/>
   if IMP_VCOLOR:&#13;
<br/>
      me.vertexColors = ase_me.hasVC&#13;
<br/>
      ase_vcolors = ase_me.ase_vertcolors&#13;
<br/>
   for i,ase_f in ase_me.ase_faces.iteritems():&#13;
<br/>
      try:f = me.faces[i]&#13;
<br/>
      except:&#13;
<br/>
         # dont know what's the problem with this&#13;
<br/>
         print 'array index out of range:', i&#13;
<br/>
         continue&#13;
<br/>
      if me.vertexColors:&#13;
<br/>
         cface = ase_me.ase_cfaces[i]&#13;
<br/>
         c0,c1,c2 = ase_vcolors[cface[0]],ase_vcolors[cface[1]],ase_vcolors[cface[2]]&#13;
<br/>
         fc0,fc1,fc2 = f.col[:]&#13;
<br/>
         fc0.r,fc0.g,fc0.b = int(c0[0]*255),int(c0[1]*255),int(c0[2]*255)&#13;
<br/>
         fc1.r,fc1.g,fc1.b = int(c1[0]*255),int(c1[1]*255),int(c1[2]*255)&#13;
<br/>
         fc2.r,fc2.g,fc2.b = int(c2[0]*255),int(c2[1]*255),int(c2[2]*255)&#13;
<br/>
      if ase_f.smooth_groups:&#13;
<br/>
         f.smooth = 1&#13;
<br/><br/>
   # import UV layer's&#13;
<br/>
   if IMP_UV and ase_me.hasUV:&#13;
<br/>
      for uv_chan in ase_me.ase_uv_channels.itervalues():&#13;
<br/>
         me.addUVLayer(uv_chan.uv_layer_name)&#13;
<br/>
         me.activeUVLayer = uv_chan.uv_layer_name&#13;
<br/>
         tverts = uv_chan.ase_tverts&#13;
<br/>
         for fi,uvis in uv_chan.ase_tfaces.iteritems():&#13;
<br/>
            try:f = me.faces[fi]&#13;
<br/>
            except: continue&#13;
<br/>
            uv1,uv2,uv3 = tverts[uvis[0]],tverts[uvis[1]],tverts[uvis[2]]&#13;
<br/>
            f.uv = [Blender.Mathutils.Vector(uv1), Blender.Mathutils.Vector(uv2), Blender.Mathutils.Vector(uv3)]&#13;
<br/>
      me.activeUVLayer = ase_me.ase_uv_channels[1].uv_layer_name&#13;
<br/><br/>
   # EXPERIMENTAL!&#13;
<br/>
   # convert tris to quads&#13;
<br/>
   # this is currently the easiest way i found without destroying uvs or vcolors&#13;
<br/>
   # but don't work like expected...:/&#13;
<br/>
   if IMP_QUADS:&#13;
<br/>
      #quad_teams = set([i for i,ase_f in ase_me.ase_faces.iteritems() if ase_f.quad_team != None])&#13;
<br/>
      quad_teams = []&#13;
<br/>
      for i,ase_f in ase_me.ase_faces.iteritems():&#13;
<br/>
         if ase_f.quad_team != None:&#13;
<br/>
            if ase_f.index &lt; ase_f.quad_team: qt = ase_f.index,ase_f.quad_team&#13;
<br/>
            elif ase_f.index &gt; ase_f.quad_team: qt = ase_f.quad_team,ase_f.index&#13;
<br/>
            if qt not in quad_teams:&#13;
<br/>
               quad_teams.append(qt)&#13;
<br/><br/>
      faces = me.faces&#13;
<br/>
      # first deselect all faces&#13;
<br/>
      for f in faces: f.sel = 0&#13;
<br/>
      for t0,t1 in quad_teams:&#13;
<br/>
         ase_f0 = ase_me.ase_faces[t0]&#13;
<br/>
         ase_f1 = ase_me.ase_faces[t1]&#13;
<br/>
         try: f0,f1 = me.faces[ase_f0.index], me.faces[ase_f1.index]&#13;
<br/>
         except: continue&#13;
<br/>
         f0.sel = 1&#13;
<br/>
         f1.sel = 1&#13;
<br/>
         me.triangleToQuad()&#13;
<br/>
         for i in faces.selected():&#13;
<br/>
            faces[i].sel = 0&#13;
<br/><br/>
   # apply the matrix to mesh (and optional fit the ob and me to blender)&#13;
<br/>
   if IMP_SCALED:&#13;
<br/>
      # seems this isn't accurate because of precision of the location vector&#13;
<br/>
      scale = Blender.Mathutils.ScaleMatrix(OPT_SCALE,4)&#13;
<br/>
      inv_matrix = ob.getMatrix().copy().invert() * scale&#13;
<br/>
      ob.setLocation(ob.getMatrix().translationPart() * scale)&#13;
<br/>
   else:&#13;
<br/>
      inv_matrix = ob.getMatrix().copy().invert()&#13;
<br/>
   me.transform(inv_matrix, 1)&#13;
<br/>
   me.calcNormals()&#13;
<br/><br/>
   # apply sharp, seam and fgon flags to edges.&#13;
<br/>
   add_EDGESPLIT = False&#13;
<br/>
   if IMP_FGONS or IMP_SEAMS or IMP_SMOOTHGROUPS:&#13;
<br/>
      SHARP = Mesh.EdgeFlags.SHARP&#13;
<br/>
      SEAM = Mesh.EdgeFlags.SEAM&#13;
<br/>
      FGON = Mesh.EdgeFlags.FGON&#13;
<br/>
      seam_keys = []&#13;
<br/>
      if ase_me.hasUV: seam_keys = ase_me.ase_uv_channels[1].seams&#13;
<br/>
      for k,ase_ed in ase_me.ase_edges.iteritems():&#13;
<br/>
         if ase_ed.sharp or not ase_ed.visible or k in seam_keys:&#13;
<br/>
            edi = me.findEdges(k[0],k[1])&#13;
<br/>
            if edi:&#13;
<br/>
               ed = me.edges[edi]&#13;
<br/>
               if ase_me.hasUV and k in seam_keys and IMP_SEAMS: ed.flag |= SEAM&#13;
<br/>
               if not ase_ed.visible and IMP_FGONS: ed.flag |= FGON&#13;
<br/>
               if ase_ed.sharp and IMP_SMOOTHGROUPS:&#13;
<br/>
                    ed.flag |= SHARP&#13;
<br/>
                  add_EDGESPLIT = True&#13;
<br/><br/><br/><br/>
   # add EdgeSplit Modiefier when the mesh has sharp edges&#13;
<br/>
   # autosmooth is EXPERIMENTAL! because i dont know if this is correct!&#13;
<br/>
   if add_EDGESPLIT and OPT_MOD_EDGESPLIT:&#13;
<br/>
      mod = ob.modifiers.append(Blender.Modifier.Types.EDGESPLIT)&#13;
<br/>
      if not ase_me.autosmooth:&#13;
<br/>
         mod[Blender.Modifier.Settings.EDGESPLIT_FROM_ANGLE] = 0&#13;
<br/>
      else:&#13;
<br/>
         mod[Blender.Modifier.Settings.EDGESPLIT_ANGLE] = ase_me.autosmooth&#13;
<br/>
      mod[Blender.Modifier.Settings.EDGESPLIT_FROM_SHARP] = 1&#13;
<br/>
      ob.makeDisplayList() # Needed to apply the modifier&#13;
<br/>
   elif not add_EDGESPLIT and ase_me.autosmooth:&#13;
<br/>
      AUTOSMOOTH = Mesh.Modes.AUTOSMOOTH&#13;
<br/>
      me.modes |= AUTOSMOOTH&#13;
<br/>
      me.degr = ase_me.autosmooth&#13;
<br/><br/>
   me.update()&#13;
<br/>
   counts['verts'] += ase_me.num['VERTEX']&#13;
<br/>
   counts['tris'] += ase_me.num['FACES']&#13;
<br/>
   counts['faces'] += len(me.faces)&#13;
<br/>
   print 'Imported Mesh-Object: ', ob.name&#13;
<br/><br/>
#def oj_the_object_jockey(file):&#13;
<br/>
def read_file(file):&#13;
<br/>
   '''&#13;
<br/>
   Read an .ase file and return a list of ase_objects&#13;
<br/>
   '''&#13;
<br/>
   lines= file.readlines()&#13;
<br/><br/>
   print 'Read file...'&#13;
<br/>
   PB_index = 0.0&#13;
<br/>
   PB_num = float(len(lines))&#13;
<br/>
   if OPT_PROGRESSBAR: Blender.Window.DrawProgressBar(0.0, "Read File...")&#13;
<br/><br/>
   # it is needed to read UV if Seams should be imported even when importing UV is disabled&#13;
<br/>
   READ_UV = False&#13;
<br/>
   if IMP_UV or IMP_SEAMS: READ_UV = True&#13;
<br/>
   #if IMP_AUTOSMOOTH and not IMP_SMOOTHGROUPS: IMP_AUTOSMOOTH = False&#13;
<br/><br/>
   ase_objects = []&#13;
<br/>
   ase_ob = False&#13;
<br/>
   for line in lines:&#13;
<br/>
      if OPT_PROGRESSBAR and not (PB_index % 10000):&#13;
<br/>
         Blender.Window.DrawProgressBar(PB_index / PB_num, "Read File...")&#13;
<br/>
      PB_index += 1&#13;
<br/><br/>
      words = line.split()&#13;
<br/>
      if not words:&#13;
<br/>
         continue&#13;
<br/>
      word0 = words[0]&#13;
<br/>
      if word0 == '*GEOMOBJECT':&#13;
<br/>
         #if ase_ob: ase_objects.append(ase_ob)&#13;
<br/>
         ase_ob_type = word0.lower()[1:-6] #get rid of '*' and 'OBJECT'&#13;
<br/>
         ase_ob = Ase_object(ase_ob_type)&#13;
<br/>
         ase_objects.append(ase_ob)&#13;
<br/>
         continue&#13;
<br/>
      elif word0 in ['*HELPEROBJECT','*SHAPEOBJECT','*LIGHTOBJECT','*CAMERAOBJECT','*GROUP']:&#13;
<br/>
         # Not supported objects!&#13;
<br/>
         # because these objects too use a TM_NODE,&#13;
<br/>
         # ase_ob should be set back to False to prevent errors.&#13;
<br/>
         ase_ob = False&#13;
<br/>
         continue&#13;
<br/>
      elif word0 == '*NODE_NAME' and ase_ob:&#13;
<br/>
         name = words[1][1:-1] #get rid of '"'&#13;
<br/>
         if ase_ob and ase_ob.name != '': ase_ob.ase_data.name = name&#13;
<br/>
         elif ase_ob: ase_ob.name = name&#13;
<br/>
         continue&#13;
<br/>
      elif word0 == '*NODE_PARENT' and ase_ob:&#13;
<br/>
         ase_ob.parent = words[1][1:-1] #get rid of '"'&#13;
<br/>
         continue&#13;
<br/>
      elif word0 == '*TM_ROW0' and ase_ob:&#13;
<br/>
         ase_ob.row0 = float(words[1]), float(words[2]), float(words[3])&#13;
<br/>
         continue&#13;
<br/>
      elif word0 == '*TM_ROW1' and ase_ob:&#13;
<br/>
         ase_ob.row1 = float(words[1]), float(words[2]), float(words[3])&#13;
<br/>
         continue&#13;
<br/>
      elif word0 == '*TM_ROW2' and ase_ob:&#13;
<br/>
         ase_ob.row2 = float(words[1]), float(words[2]), float(words[3])&#13;
<br/>
         continue&#13;
<br/>
      elif word0 == '*TM_ROW3' and ase_ob:&#13;
<br/>
         ase_ob.row3 = float(words[1]), float(words[2]), float(words[3])&#13;
<br/>
         continue&#13;
<br/>
      elif word0 == '*MESH':&#13;
<br/>
         ase_me = ase_ob.ase_data&#13;
<br/>
         continue&#13;
<br/>
      elif word0 == '*MESH_NUMVERTEX':&#13;
<br/>
         ase_me.num['VERTEX'] = int(words[1])&#13;
<br/>
         continue&#13;
<br/>
      elif word0 == '*MESH_NUMFACES':&#13;
<br/>
         ase_me.num['FACES'] = int(words[1])&#13;
<br/>
         continue&#13;
<br/>
      elif word0 == '*MESH_VERTEX':&#13;
<br/>
         #vert_index, x, y, z&#13;
<br/>
         ase_me.append_vert(int(words[1]),float(words[2]),float(words[3]),float(words[4]))&#13;
<br/>
         continue&#13;
<br/>
      elif word0 == '*MESH_FACE':&#13;
<br/>
         #ase_face_index, vi0, vi1, vi2, AB, BC, CA, smooth_groups, mat_indicies&#13;
<br/>
         #smooth = mat = False&#13;
<br/>
         ase_face_index = words[1]&#13;
<br/>
         if ase_face_index.endswith(':'):&#13;
<br/>
            ase_face_index = ase_face_index[:-1]&#13;
<br/><br/>
         smooth_groups = mat_indices = []&#13;
<br/>
         for i,w in enumerate(words):&#13;
<br/>
            if w == '*MESH_SMOOTHING' and IMP_SMOOTHGROUPS:&#13;
<br/>
               try:&#13;
<br/>
                  if words[i+1] != '*MESH_MTLID':&#13;
<br/>
                     smooth_groups = [int(i) for i in words[i+1].split(',')]&#13;
<br/>
               except:&#13;
<br/>
                  smooth_groups = 0&#13;
<br/>
            elif w == '*MESH_MTLID' and IMP_SMOOTHGROUPS:&#13;
<br/>
               try:&#13;
<br/>
                  mat_indices = [int(i) for i in words[i+1].split(',')]&#13;
<br/>
               except:&#13;
<br/>
                  mat_indices = 0&#13;
<br/>
         ase_me.append_face(int(ase_face_index),int(words[3]),int(words[5]),int(words[7]),int(words[9]),int(words[11]),int(words[13]),smooth_groups,mat_indices)&#13;
<br/>
         continue&#13;
<br/>
      elif READ_UV:&#13;
<br/>
         if word0 == '*MESH_NUMTVERTEX':&#13;
<br/>
            if not ase_me.ase_uv_channels: ase_me.append_uv_channel()&#13;
<br/>
            ase_me.active_uv.num['TVERTEX'] = int(words[1])&#13;
<br/>
            ase_me.hasUV = True&#13;
<br/>
            continue&#13;
<br/>
         elif word0 == '*MESH_MAPPINGCHANNEL':&#13;
<br/>
            # uv_channel_index&#13;
<br/>
            ase_me.append_uv_channel(int(words[1]))&#13;
<br/>
            continue&#13;
<br/>
         elif word0 == '*MESH_TVERT':&#13;
<br/>
            #uv_index, u, v, w&#13;
<br/>
            ase_me.append_tvert(int(words[1]),float(words[2]),float(words[3]),float(words[4]))&#13;
<br/>
            continue&#13;
<br/>
         elif word0 == '*MESH_NUMTVFACES':&#13;
<br/>
            ase_me.active_uv.num['TVFACES'] = int(words[1])&#13;
<br/>
            continue&#13;
<br/>
         elif word0 == '*MESH_TFACE':&#13;
<br/>
            #ase_face_index, uv0, uv1, uv2, opt_IMP_SEAMS&#13;
<br/>
            ase_face_index = words[1]&#13;
<br/>
            if ase_face_index.endswith(':'):&#13;
<br/>
               ase_face_index = ase_face_index[:-1]&#13;
<br/>
            ase_me.append_tface(int(ase_face_index),int(words[2]),int(words[3]),int(words[4]),IMP_SEAMS)&#13;
<br/>
            continue&#13;
<br/>
      elif IMP_VCOLOR:&#13;
<br/>
         if word0 == '*MESH_NUMCVERTEX':&#13;
<br/>
            ase_me.num['CVERTEX'] = int(words[1])&#13;
<br/>
            if ase_me.num['CVERTEX']:&#13;
<br/>
               ase_me.hasVC = True&#13;
<br/>
            continue&#13;
<br/>
         elif word0 == '*MESH_VERTCOL':&#13;
<br/>
            #color_index, r, g, b&#13;
<br/><!--
     FILE ARCHIVED ON 18:15:16 May 9, 2007 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 0:07:02 Sep 26, 2014.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
--></td>
      </tr>
    </table>
  </td>
</tr>]]></body></post><post id="140291" date="Posted: Mon Apr 17, 2006 2:00 am    Post subject: ASE Importer"><author>Goofos</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">I made a first small script to import ASE meshes. Its not perfect and may a bit lame but should import correct meshes (from 3DS). Materials are currently not supported but UV coords and VertexColors. &#13;
<br/>
Note: Meshes from 3DS are very big in Blender <img src="https://web.archive.org/web/20061012234245im_/http://doom3world.org/phpbb2/images/smiles/icon_biggrin.gif" alt="Very Happy" border="0"/><br/><br/></span><table width="90%" cellspacing="1" cellpadding="3" border="0" align="center"><tr><td><span class="genmed"><b>Code:</b></span></td>	</tr><tr><td class="code">#!BPY&#13;
<br/><br/>
""" &#13;
<br/>
Name: 'ASCII Scene (.ase) v0.12'&#13;
<br/>
Blender: 242&#13;
<br/>
Group: 'Import' &#13;
<br/>
Tooltip: 'ASCII Scene import (*.ase)' &#13;
<br/>
""" &#13;
<br/>
__author__ = "Goofos"&#13;
<br/>
__version__ = "0.12"&#13;
<br/><br/>
# goofos at epruegel.de &#13;
<br/>
# &#13;
<br/>
# ***** BEGIN GPL LICENSE BLOCK ***** &#13;
<br/>
#&#13;
<br/>
# This program is free software; you can redistribute it and/or&#13;
<br/>
# modify it under the terms of the GNU General Public License &#13;
<br/>
# as published by the Free Software Foundation; either version 2&#13;
<br/>
# of the License, or (at your option) any later version. &#13;
<br/>
# &#13;
<br/>
# This program is distributed in the hope that it will be useful, &#13;
<br/>
# but WITHOUT ANY WARRANTY; without even the implied warranty of &#13;
<br/>
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the &#13;
<br/>
# GNU General Public License for more details. &#13;
<br/>
# &#13;
<br/>
# You should have received a copy of the GNU General Public License &#13;
<br/>
# along with this program; if not, write to the Free Software Foundation, &#13;
<br/>
# Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. &#13;
<br/>
# &#13;
<br/>
# ***** END GPL LICENCE BLOCK ***** &#13;
<br/><br/>
import string, time, sys as osSys &#13;
<br/>
import Blender &#13;
<br/>
from Blender import Draw, Mesh, Window, Object, Scene &#13;
<br/>
#import meshtools &#13;
<br/><br/><br/>
def read_main(filename): &#13;
<br/><br/>
   global counts &#13;
<br/>
   counts = {'verts': 0, 'tris': 0} &#13;
<br/><br/>
   start = time.clock() &#13;
<br/>
   file = open(filename, "r") &#13;
<br/><br/>
   print_boxed("----------------start-----------------")&#13;
<br/>
   print 'Import Patch: ', filename &#13;
<br/><br/>
   editmode = Window.EditMode()    # are we in edit mode?  If so ... &#13;
<br/>
   if editmode: Window.EditMode(0) # leave edit mode before getting the mesh&#13;
<br/><br/>
   lines= file.readlines() &#13;
<br/>
   read_file(file, lines) &#13;
<br/><br/>
   Blender.Window.DrawProgressBar(1.0, '')  # clear progressbar&#13;
<br/>
   file.close() &#13;
<br/>
   print "----------------end-----------------" &#13;
<br/>
   end = time.clock() &#13;
<br/>
   seconds = " in %.2f %s" % (end-start, "seconds") &#13;
<br/>
   totals = "Verts: %i Tris: %i " % (counts['verts'], counts['tris']) &#13;
<br/>
   print_boxed(totals) &#13;
<br/>
   message = "Successfully imported " + Blender.sys.basename(filename) + seconds &#13;
<br/>
   #meshtools.print_boxed(message) &#13;
<br/>
   print_boxed(message) &#13;
<br/><br/><br/>
def print_boxed(text): #Copy/Paste from meshtools, only to remove the beep :) &#13;
<br/>
   lines = text.splitlines() &#13;
<br/>
   maxlinelen = max(map(len, lines)) &#13;
<br/>
   if osSys.platform[:3] == "win": &#13;
<br/>
      print chr(218)+chr(196) + chr(196)*maxlinelen + chr(196)+chr(191) &#13;
<br/>
      for line in lines: &#13;
<br/>
         print chr(179) + ' ' + line.ljust(maxlinelen) + ' ' + chr(179) &#13;
<br/>
      print chr(192)+chr(196) + chr(196)*maxlinelen + chr(196)+chr(217) &#13;
<br/>
   else: &#13;
<br/>
      print '+-' + '-'*maxlinelen + '-+' &#13;
<br/>
      for line in lines: print '| ' + line.ljust(maxlinelen) + ' |' &#13;
<br/>
      print '+-' + '-'*maxlinelen + '-+' &#13;
<br/>
   #print '\a\r', # beep when done &#13;
<br/><br/><br/>
class ase_obj: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.name = 'Name' &#13;
<br/>
      self.objType = None &#13;
<br/>
      self.row0x = None &#13;
<br/>
      self.row0y = None &#13;
<br/>
      self.row0z = None &#13;
<br/>
      self.row1x = None &#13;
<br/>
      self.row1y = None &#13;
<br/>
      self.row1z = None &#13;
<br/>
      self.row2x = None &#13;
<br/>
      self.row2y = None &#13;
<br/>
      self.row2z = None &#13;
<br/>
      self.row3x = None &#13;
<br/>
      self.row3y = None &#13;
<br/>
      self.row3z = None &#13;
<br/>
      self.parent = None &#13;
<br/>
      self.obj = None &#13;
<br/>
      self.objName = 'Name' &#13;
<br/><br/>
class ase_mesh: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.name = '' &#13;
<br/>
      self.vCount = 0 &#13;
<br/>
      self.fCount = 0 &#13;
<br/>
      self.uvVCount = 0 &#13;
<br/>
      self.uvFCount = 0 &#13;
<br/>
      self.vcVCount = 0 &#13;
<br/>
      self.vcFCount = 0 &#13;
<br/>
      self.meVerts = [] &#13;
<br/>
      self.meFaces = [] &#13;
<br/>
      self.uvVerts = [] &#13;
<br/>
      self.uvFaces = [] &#13;
<br/>
      self.vcVerts = [] &#13;
<br/>
      self.vcFaces = [] &#13;
<br/>
      self.hasFUV = 0 &#13;
<br/>
      self.hasVC = 0 &#13;
<br/><br/>
class mesh_face: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.v1 = 0 &#13;
<br/>
      self.v2 = 0 &#13;
<br/>
      self.v3 = 0 &#13;
<br/>
      self.mat = None &#13;
<br/>
       &#13;
<br/>
class mesh_vert: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.x = 0.0 &#13;
<br/>
      self.y = 0.0 &#13;
<br/>
      self.z = 0.0 &#13;
<br/><br/>
class mesh_uvVert: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.index = 0 &#13;
<br/>
      self.u = 0.0 &#13;
<br/>
      self.v = 0.0 &#13;
<br/>
      self.vec = Blender.Mathutils.Vector(self.u, self.v) &#13;
<br/><br/>
class mesh_uvFace: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.index = 0 &#13;
<br/>
      self.uv1 = 0 &#13;
<br/>
      self.uv2 = 0 &#13;
<br/>
      self.uv3 = 0 &#13;
<br/>
       &#13;
<br/>
class mesh_vcVert: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.index = 0 &#13;
<br/>
      self.r = 0 &#13;
<br/>
      self.g = 0 &#13;
<br/>
      self.b = 0 &#13;
<br/>
      self.a = 255 &#13;
<br/>
       &#13;
<br/>
class mesh_vcFace: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.index = 0 &#13;
<br/>
      self.c1 = 0 &#13;
<br/>
      self.c2 = 0 &#13;
<br/>
      self.c3 = 0 &#13;
<br/><br/><br/>
def read_file(file, lines): &#13;
<br/><br/>
   objects = [] &#13;
<br/>
   objIdx = 0 &#13;
<br/>
   objCheck = -1 #needed to skip helper objects &#13;
<br/>
   PBidx = 0.0 &#13;
<br/>
   lineCount = float(len(lines)) &#13;
<br/><br/>
   print 'Read file' &#13;
<br/>
   Blender.Window.DrawProgressBar(0.0, "Read File...") &#13;
<br/><br/>
   for line in lines: &#13;
<br/>
      words = string.split(line) &#13;
<br/><br/>
      if (PBidx % 10000) == 0.0: &#13;
<br/>
                   Blender.Window.DrawProgressBar(PBidx / lineCount, "Read File...") &#13;
<br/><br/>
      if not words: &#13;
<br/>
         continue &#13;
<br/>
      elif words[0] == '*GEOMOBJECT': &#13;
<br/>
         objCheck = 0 &#13;
<br/>
         newObj = ase_obj() &#13;
<br/>
         objects.append(newObj) &#13;
<br/>
         obj = objects[objIdx] &#13;
<br/>
         objIdx += 1 &#13;
<br/>
      elif words[0] == '*NODE_NAME' and objCheck != -1: &#13;
<br/>
         if objCheck == 0: &#13;
<br/>
            obj.name = words[1] &#13;
<br/>
            objCheck = 1 &#13;
<br/>
         elif objCheck == 1: &#13;
<br/>
            obj.objName = words[1] &#13;
<br/>
      elif words[0] == '*TM_ROW0' and objCheck != -1: &#13;
<br/>
         obj.row0x = float(words[1]) &#13;
<br/>
         obj.row0y = float(words[2]) &#13;
<br/>
         obj.row0z = float(words[3]) &#13;
<br/>
      elif words[0] == '*TM_ROW1' and objCheck != -1: &#13;
<br/>
         obj.row1x = float(words[1]) &#13;
<br/>
         obj.row1y = float(words[2]) &#13;
<br/>
         obj.row1z = float(words[3]) &#13;
<br/>
      elif words[0] == '*TM_ROW2' and objCheck != -1: &#13;
<br/>
         obj.row2x = float(words[1]) &#13;
<br/>
         obj.row2y = float(words[2]) &#13;
<br/>
         obj.row2z = float(words[3]) &#13;
<br/>
      elif words[0] == '*TM_ROW3' and objCheck != -1: &#13;
<br/>
         obj.row3x = float(words[1]) &#13;
<br/>
         obj.row3y = float(words[2]) &#13;
<br/>
         obj.row3z = float(words[3]) &#13;
<br/>
         objCheck = -1 &#13;
<br/>
      elif words[0] == '*MESH': &#13;
<br/>
         obj.objType = 'Mesh' &#13;
<br/>
         obj.obj = ase_mesh() &#13;
<br/>
         me = obj.obj &#13;
<br/>
      elif words[0] == '*MESH_NUMVERTEX': &#13;
<br/>
         me.vCount = int(words[1]) &#13;
<br/>
      elif words[0] == '*MESH_NUMFACES': &#13;
<br/>
         me.fCount = int(words[1]) &#13;
<br/>
      elif words[0] == '*MESH_VERTEX': &#13;
<br/>
         #v = mesh_vert() &#13;
<br/>
         v = [float(words[2]),float(words[3]),float(words[4])]&#13;
<br/>
         #v.x = float(words[2])&#13;
<br/>
         #v.y = float(words[3])&#13;
<br/>
         #v.z = float(words[4])&#13;
<br/>
         me.meVerts.append(v) &#13;
<br/>
      elif words[0] == '*MESH_FACE':&#13;
<br/>
         #f = mesh_face()&#13;
<br/>
         f = [int(words[3]),int(words[5]),int(words[7])]&#13;
<br/>
         #f.v1 = int(words[3])&#13;
<br/>
         #f.v2 = int(words[5])&#13;
<br/>
         #f.v3 = int(words[7])&#13;
<br/>
         me.meFaces.append(f) &#13;
<br/>
      elif words[0] == '*MESH_NUMTVERTEX': &#13;
<br/>
         me.uvVCount = int(words[1]) &#13;
<br/>
         if me.uvVCount &gt; 0: &#13;
<br/>
            me.hasFUV = 1 &#13;
<br/>
      elif words[0] == '*MESH_TVERT': &#13;
<br/>
         uv = mesh_uvVert() &#13;
<br/>
         uv.index = int(words[1]) &#13;
<br/>
         uv.u = float(words[2]) &#13;
<br/>
         uv.v = float(words[3]) &#13;
<br/>
         me.uvVerts.append(uv) &#13;
<br/>
      elif words[0] == '*MESH_NUMTVFACES': &#13;
<br/>
         me.uvFCount = int(words[1]) &#13;
<br/>
      elif words[0] == '*MESH_TFACE': &#13;
<br/>
         fUv = mesh_uvFace() &#13;
<br/>
         fUv.index = int(words[1]) &#13;
<br/>
         fUv.uv1 = int(words[2]) &#13;
<br/>
         fUv.uv2 = int(words[3]) &#13;
<br/>
         fUv.uv3 = int(words[4]) &#13;
<br/>
         me.uvFaces.append(fUv) &#13;
<br/>
      elif words[0] == '*MESH_NUMCVERTEX': &#13;
<br/>
         me.vcVCount = int(words[1]) &#13;
<br/>
         if me.uvVCount &gt; 0: &#13;
<br/>
            me.hasVC = 1 &#13;
<br/>
      elif words[0] == '*MESH_VERTCOL': &#13;
<br/>
         c = mesh_vcVert() &#13;
<br/>
         c.index = int(words[1]) &#13;
<br/>
         c.r = round(float(words[2])*256) &#13;
<br/>
         c.g = round(float(words[3])*256) &#13;
<br/>
         c.b = round(float(words[4])*256) &#13;
<br/>
         me.vcVerts.append(c) &#13;
<br/>
      elif words[0] == '*MESH_CFACE': &#13;
<br/>
         fc = mesh_vcFace() &#13;
<br/>
         fc.index = int(words[1]) &#13;
<br/>
         fc.c1 = int(words[2]) &#13;
<br/>
         fc.c2 = int(words[3]) &#13;
<br/>
         fc.c3 = int(words[4]) &#13;
<br/>
         me.vcFaces.append(fc) &#13;
<br/><br/>
      PBidx += 1.0 &#13;
<br/><br/>
   spawn_main(objects) &#13;
<br/><br/>
   Blender.Redraw() &#13;
<br/><br/>
def spawn_main(objects):&#13;
<br/><br/>
   PBidx = 0.0 &#13;
<br/>
   objCount = float(len(objects)) &#13;
<br/><br/>
   print 'Import Objects' &#13;
<br/>
   Blender.Window.DrawProgressBar(0.0, "Importing Objects...") &#13;
<br/><br/>
   for obj in objects: &#13;
<br/><br/>
      Blender.Window.DrawProgressBar(PBidx / objCount, "Importing Objects...") &#13;
<br/><br/>
      if obj.objType == 'Mesh': &#13;
<br/>
         spawn_mesh(obj) &#13;
<br/><br/>
      PBidx += 1.0 &#13;
<br/><br/><br/>
def spawn_mesh(obj):&#13;
<br/><br/>
   objMe = obj.obj&#13;
<br/>
   #normal_flag = 1&#13;
<br/><br/>
   row0 = obj.row0x, obj.row0y, obj.row0z&#13;
<br/>
   row1 = obj.row1x, obj.row1y, obj.row1z&#13;
<br/>
   row2 = obj.row2x, obj.row2y, obj.row2z&#13;
<br/>
   row3 = obj.row3x, obj.row3y, obj.row3z&#13;
<br/><br/>
   newMatrix = Blender.Mathutils.Matrix(row0, row1, row2, row3)&#13;
<br/>
   newMatrix.resize4x4()&#13;
<br/><br/>
   newObj = Blender.Object.New(obj.objType, obj.name)&#13;
<br/>
   newObj.setMatrix(newMatrix)&#13;
<br/>
   Blender.Scene.getCurrent().link(newObj) &#13;
<br/><br/><br/>
   newMesh = Blender.Mesh.New(obj.objName) &#13;
<br/>
   newMesh.getFromObject(newObj.name) &#13;
<br/><br/><br/>
   # Verts &#13;
<br/>
   newMesh.verts.extend(objMe.meVerts)&#13;
<br/><br/>
   # Faces &#13;
<br/>
   newMesh.faces.extend(objMe.meFaces)&#13;
<br/><br/>
   #VertCol &#13;
<br/>
   if guiTable['VC'] == 1 and objMe.hasVC == 1: &#13;
<br/>
      newMesh.vertexColors = 1 &#13;
<br/>
      for c in objMe.vcFaces: &#13;
<br/><br/>
         FCol0 = newMesh.faces[c.index].col[0] &#13;
<br/>
         FCol1 = newMesh.faces[c.index].col[1] &#13;
<br/>
         FCol2 = newMesh.faces[c.index].col[2] &#13;
<br/><br/>
         FCol0.r = int(objMe.vcVerts[c.c1].r) &#13;
<br/>
         FCol0.g = int(objMe.vcVerts[c.c1].g) &#13;
<br/>
         FCol0.b = int(objMe.vcVerts[c.c1].b) &#13;
<br/><br/>
         FCol1.r = int(objMe.vcVerts[c.c2].r) &#13;
<br/>
         FCol1.g = int(objMe.vcVerts[c.c2].g) &#13;
<br/>
         FCol1.b = int(objMe.vcVerts[c.c2].b) &#13;
<br/><br/>
         FCol2.r = int(objMe.vcVerts[c.c3].r) &#13;
<br/>
         FCol2.g = int(objMe.vcVerts[c.c3].g) &#13;
<br/>
         FCol2.b = int(objMe.vcVerts[c.c3].b) &#13;
<br/><br/>
   # UV &#13;
<br/>
   if guiTable['UV'] == 1 and objMe.hasFUV == 1: &#13;
<br/>
      newMesh.faceUV = 1 &#13;
<br/>
      for f in objMe.uvFaces: &#13;
<br/>
         uv1 = Blender.Mathutils.Vector(float(objMe.uvVerts[f.uv1].u), float(objMe.uvVerts[f.uv1].v)) &#13;
<br/>
         uv2 = Blender.Mathutils.Vector(float(objMe.uvVerts[f.uv2].u), float(objMe.uvVerts[f.uv2].v)) &#13;
<br/>
         uv3 = Blender.Mathutils.Vector(float(objMe.uvVerts[f.uv3].u), float(objMe.uvVerts[f.uv3].v)) &#13;
<br/>
         newMesh.faces[f.index].uv = [uv1, uv2, uv3] &#13;
<br/><br/>
   newMesh.transform((newObj.getMatrix('worldspace').invert()), 1) &#13;
<br/>
   newObj.link(newMesh) &#13;
<br/><br/>
   counts['verts'] += objMe.vCount &#13;
<br/>
   counts['tris'] += objMe.fCount &#13;
<br/>
   print 'Imported Mesh-Object: ', obj.name &#13;
<br/><br/><br/><br/>
def read_ui(filename): &#13;
<br/><br/>
   global guiTable, IMPORT_VC, IMPORT_UV &#13;
<br/>
   guiTable = {'VC': 1, 'UV': 1} &#13;
<br/><br/>
   for s in Window.GetScreenInfo(): &#13;
<br/>
      Window.QHandle(s['id']) &#13;
<br/><br/>
   IMPORT_VC = Draw.Create(guiTable['VC']) &#13;
<br/>
   IMPORT_UV = Draw.Create(guiTable['UV']) &#13;
<br/><br/>
   # Get USER Options &#13;
<br/>
   pup_block = [('Import Options'),('Vertex Color', IMPORT_VC, 'Import Vertex Colors if exist'),('UV', IMPORT_UV, 'Import UV if exist'),] &#13;
<br/><br/>
   if not Draw.PupBlock('Import...', pup_block): &#13;
<br/>
      return &#13;
<br/><br/>
   Window.WaitCursor(1)&#13;
<br/><br/>
   guiTable['VC'] = IMPORT_VC.val &#13;
<br/>
   guiTable['UV'] = IMPORT_UV.val &#13;
<br/><br/>
   read_main(filename) &#13;
<br/><br/>
   Window.WaitCursor(0) &#13;
<br/><br/><br/>
if __name__ == '__main__': &#13;
<br/>
   Window.FileSelector(read_ui, 'Import ASCII Scene', ('.ase'))</td>	</tr></table><span class="postbody"/><span class="gensmall"><br/><br/>Last edited by Goofos on Tue Aug 15, 2006 12:25 pm; edited 4 times in total</span></td>
			</tr>]]></body></post><post id="140320" date="Posted: Mon Apr 17, 2006 1:12 pm    Post subject: "><author>Bittoman</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Nice job, thanks Goofos!</span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="140355" date="Posted: Mon Apr 17, 2006 10:30 pm    Post subject: "><author>kat</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Not tried it yet but 'GG' on doing this one. Another step up the ladder for Blender!<br/>_________________<br/><a href="https://web.archive.org/web/20061012234245/http://www.doom3world.org/" target="_blank" class="postlink"><img src="https://web.archive.org/web/20061012234245im_/http://www.doom3world.org/site/img/d3w.gif" border="0"/>Co-Admin</a> - <a href="https://web.archive.org/web/20061012234245/http://www.quake3bits.com/" target="_blank" class="postlink">Modelling and modding tutorials and tips</a></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="143616" date="Posted: Fri May 19, 2006 8:04 pm    Post subject: "><author>kat</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Just tried this script for the 1st time and encountered the following error with Blender 2.41 when run as a script from the text window (Alt+P).&#13;
<br/></span><table width="90%" cellspacing="1" cellpadding="3" border="0" align="center"><tr><td><span class="genmed"><b>Code:</b></span></td>	</tr><tr><td class="code">IndentationError: unindent does not match any outer indentation level&#13;
<br/>
  File "goofosASE_import_17Ap", line 295&#13;
<br/>
    if obj.objType == 'Mesh':&#13;
<br/>
                             ^</td>	</tr></table><span class="postbody"><br/>_________________<br/><a href="https://web.archive.org/web/20061012234245/http://www.doom3world.org/" target="_blank" class="postlink"><img src="https://web.archive.org/web/20061012234245im_/http://www.doom3world.org/site/img/d3w.gif" border="0"/>Co-Admin</a> - <a href="https://web.archive.org/web/20061012234245/http://www.quake3bits.com/" target="_blank" class="postlink">Modelling and modding tutorials and tips</a></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="143762" date="Posted: Sun May 21, 2006 3:58 pm    Post subject: "><author>Goofos</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Should work now. Seems my OS is a bit more tollerant with format errors :&gt;</span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="144077" date="Posted: Fri May 26, 2006 10:43 am    Post subject: "><author>OrbWeaver</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">I haven't tried this but it sounds great. Until now ASE has been almost universally considered an "export-only" format.</span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="144120" date="Posted: Fri May 26, 2006 5:33 pm    Post subject: New error"><author>kat</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">New error when doing Ctrl+P to run the script</span><table width="90%" cellspacing="1" cellpadding="3" border="0" align="center"><tr><td><span class="genmed"><b>Code:</b></span></td>	</tr><tr><td class="code">SyntaxError: invalid token&#13;
<br/>
  File "goofosASE_import_26Ma", line 382&#13;
<br/>
    pup_block = [\&#13;
<br/>
                  ^</td>	</tr></table><span class="postbody"><br/>_________________<br/><a href="https://web.archive.org/web/20061012234245/http://www.doom3world.org/" target="_blank" class="postlink"><img src="https://web.archive.org/web/20061012234245im_/http://www.doom3world.org/site/img/d3w.gif" border="0"/>Co-Admin</a> - <a href="https://web.archive.org/web/20061012234245/http://www.quake3bits.com/" target="_blank" class="postlink">Modelling and modding tutorials and tips</a></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="144546" date="Posted: Wed May 31, 2006 3:07 pm    Post subject: "><author>Goofos</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">There was a space at end of the line if you copy/paste the script from the forum. I have put the array in one line, should work now.</span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="144572" date="Posted: Wed May 31, 2006 6:19 pm    Post subject: "><author>kat</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">DUDE!! sorted. Both vertex and UVW import work fine and dandy.<br/>_________________<br/><a href="https://web.archive.org/web/20061012234245/http://www.doom3world.org/" target="_blank" class="postlink"><img src="https://web.archive.org/web/20061012234245im_/http://www.doom3world.org/site/img/d3w.gif" border="0"/>Co-Admin</a> - <a href="https://web.archive.org/web/20061012234245/http://www.quake3bits.com/" target="_blank" class="postlink">Modelling and modding tutorials and tips</a></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="153676" date="Posted: Tue Aug 15, 2006 12:07 pm    Post subject: "><author>Goofos</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Fixed a problem with the matrices, dont know why this suddenly happened.&#13;
<br/><br/>
[edit]&#13;
<br/>
I quickly updated it again (to v0.12) <img src="https://web.archive.org/web/20061012234245im_/http://doom3world.org/phpbb2/images/smiles/icon_biggrin.gif" alt="Very Happy" border="0"/> to use some improvements of 2.42 (which doesn't worked with 2.40). Now it should import (big) meshes much faster.</span><span class="gensmall"><br/><br/>Last edited by Goofos on Tue Aug 15, 2006 12:34 pm; edited 1 time in total</span></td>
			</tr>]]></body></post><post id="154876" date="Posted: Fri Aug 25, 2006 2:29 am    Post subject: "><author>Tweaker</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Excellent, I was having problems importing with 2.42a, but this seems to have fixed it.  Thanks.   <img src="https://web.archive.org/web/20061012234245im_/http://doom3world.org/phpbb2/images/smiles/icon_biggrin.gif" alt="Very Happy" border="0"/></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="140291" date="Posted: Mon Apr 17, 2006 2:00 am    Post subject: ASE Importer"><author>Goofos</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">I made a first small script to import ASE meshes. Its not perfect and may a bit lame but should import correct meshes (from 3DS). Materials are currently not supported but UV coords and VertexColors. &#13;
<br/>
Note: Meshes from 3DS are very big in Blender <img src="https://web.archive.org/web/20061012234303im_/http://doom3world.org/phpbb2/images/smiles/icon_biggrin.gif" alt="Very Happy" border="0"/><br/><br/></span><table width="90%" cellspacing="1" cellpadding="3" border="0" align="center"><tr><td><span class="genmed"><b>Code:</b></span></td>	</tr><tr><td class="code">#!BPY&#13;
<br/><br/>
""" &#13;
<br/>
Name: 'ASCII Scene (.ase) v0.12'&#13;
<br/>
Blender: 242&#13;
<br/>
Group: 'Import' &#13;
<br/>
Tooltip: 'ASCII Scene import (*.ase)' &#13;
<br/>
""" &#13;
<br/>
__author__ = "Goofos"&#13;
<br/>
__version__ = "0.12"&#13;
<br/><br/>
# goofos at epruegel.de &#13;
<br/>
# &#13;
<br/>
# ***** BEGIN GPL LICENSE BLOCK ***** &#13;
<br/>
#&#13;
<br/>
# This program is free software; you can redistribute it and/or&#13;
<br/>
# modify it under the terms of the GNU General Public License &#13;
<br/>
# as published by the Free Software Foundation; either version 2&#13;
<br/>
# of the License, or (at your option) any later version. &#13;
<br/>
# &#13;
<br/>
# This program is distributed in the hope that it will be useful, &#13;
<br/>
# but WITHOUT ANY WARRANTY; without even the implied warranty of &#13;
<br/>
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the &#13;
<br/>
# GNU General Public License for more details. &#13;
<br/>
# &#13;
<br/>
# You should have received a copy of the GNU General Public License &#13;
<br/>
# along with this program; if not, write to the Free Software Foundation, &#13;
<br/>
# Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. &#13;
<br/>
# &#13;
<br/>
# ***** END GPL LICENCE BLOCK ***** &#13;
<br/><br/>
import string, time, sys as osSys &#13;
<br/>
import Blender &#13;
<br/>
from Blender import Draw, Mesh, Window, Object, Scene &#13;
<br/>
#import meshtools &#13;
<br/><br/><br/>
def read_main(filename): &#13;
<br/><br/>
   global counts &#13;
<br/>
   counts = {'verts': 0, 'tris': 0} &#13;
<br/><br/>
   start = time.clock() &#13;
<br/>
   file = open(filename, "r") &#13;
<br/><br/>
   print_boxed("----------------start-----------------")&#13;
<br/>
   print 'Import Patch: ', filename &#13;
<br/><br/>
   editmode = Window.EditMode()    # are we in edit mode?  If so ... &#13;
<br/>
   if editmode: Window.EditMode(0) # leave edit mode before getting the mesh&#13;
<br/><br/>
   lines= file.readlines() &#13;
<br/>
   read_file(file, lines) &#13;
<br/><br/>
   Blender.Window.DrawProgressBar(1.0, '')  # clear progressbar&#13;
<br/>
   file.close() &#13;
<br/>
   print "----------------end-----------------" &#13;
<br/>
   end = time.clock() &#13;
<br/>
   seconds = " in %.2f %s" % (end-start, "seconds") &#13;
<br/>
   totals = "Verts: %i Tris: %i " % (counts['verts'], counts['tris']) &#13;
<br/>
   print_boxed(totals) &#13;
<br/>
   message = "Successfully imported " + Blender.sys.basename(filename) + seconds &#13;
<br/>
   #meshtools.print_boxed(message) &#13;
<br/>
   print_boxed(message) &#13;
<br/><br/><br/>
def print_boxed(text): #Copy/Paste from meshtools, only to remove the beep :) &#13;
<br/>
   lines = text.splitlines() &#13;
<br/>
   maxlinelen = max(map(len, lines)) &#13;
<br/>
   if osSys.platform[:3] == "win": &#13;
<br/>
      print chr(218)+chr(196) + chr(196)*maxlinelen + chr(196)+chr(191) &#13;
<br/>
      for line in lines: &#13;
<br/>
         print chr(179) + ' ' + line.ljust(maxlinelen) + ' ' + chr(179) &#13;
<br/>
      print chr(192)+chr(196) + chr(196)*maxlinelen + chr(196)+chr(217) &#13;
<br/>
   else: &#13;
<br/>
      print '+-' + '-'*maxlinelen + '-+' &#13;
<br/>
      for line in lines: print '| ' + line.ljust(maxlinelen) + ' |' &#13;
<br/>
      print '+-' + '-'*maxlinelen + '-+' &#13;
<br/>
   #print '\a\r', # beep when done &#13;
<br/><br/><br/>
class ase_obj: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.name = 'Name' &#13;
<br/>
      self.objType = None &#13;
<br/>
      self.row0x = None &#13;
<br/>
      self.row0y = None &#13;
<br/>
      self.row0z = None &#13;
<br/>
      self.row1x = None &#13;
<br/>
      self.row1y = None &#13;
<br/>
      self.row1z = None &#13;
<br/>
      self.row2x = None &#13;
<br/>
      self.row2y = None &#13;
<br/>
      self.row2z = None &#13;
<br/>
      self.row3x = None &#13;
<br/>
      self.row3y = None &#13;
<br/>
      self.row3z = None &#13;
<br/>
      self.parent = None &#13;
<br/>
      self.obj = None &#13;
<br/>
      self.objName = 'Name' &#13;
<br/><br/>
class ase_mesh: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.name = '' &#13;
<br/>
      self.vCount = 0 &#13;
<br/>
      self.fCount = 0 &#13;
<br/>
      self.uvVCount = 0 &#13;
<br/>
      self.uvFCount = 0 &#13;
<br/>
      self.vcVCount = 0 &#13;
<br/>
      self.vcFCount = 0 &#13;
<br/>
      self.meVerts = [] &#13;
<br/>
      self.meFaces = [] &#13;
<br/>
      self.uvVerts = [] &#13;
<br/>
      self.uvFaces = [] &#13;
<br/>
      self.vcVerts = [] &#13;
<br/>
      self.vcFaces = [] &#13;
<br/>
      self.hasFUV = 0 &#13;
<br/>
      self.hasVC = 0 &#13;
<br/><br/>
class mesh_face: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.v1 = 0 &#13;
<br/>
      self.v2 = 0 &#13;
<br/>
      self.v3 = 0 &#13;
<br/>
      self.mat = None &#13;
<br/>
       &#13;
<br/>
class mesh_vert: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.x = 0.0 &#13;
<br/>
      self.y = 0.0 &#13;
<br/>
      self.z = 0.0 &#13;
<br/><br/>
class mesh_uvVert: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.index = 0 &#13;
<br/>
      self.u = 0.0 &#13;
<br/>
      self.v = 0.0 &#13;
<br/>
      self.vec = Blender.Mathutils.Vector(self.u, self.v) &#13;
<br/><br/>
class mesh_uvFace: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.index = 0 &#13;
<br/>
      self.uv1 = 0 &#13;
<br/>
      self.uv2 = 0 &#13;
<br/>
      self.uv3 = 0 &#13;
<br/>
       &#13;
<br/>
class mesh_vcVert: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.index = 0 &#13;
<br/>
      self.r = 0 &#13;
<br/>
      self.g = 0 &#13;
<br/>
      self.b = 0 &#13;
<br/>
      self.a = 255 &#13;
<br/>
       &#13;
<br/>
class mesh_vcFace: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.index = 0 &#13;
<br/>
      self.c1 = 0 &#13;
<br/>
      self.c2 = 0 &#13;
<br/>
      self.c3 = 0 &#13;
<br/><br/><br/>
def read_file(file, lines): &#13;
<br/><br/>
   objects = [] &#13;
<br/>
   objIdx = 0 &#13;
<br/>
   objCheck = -1 #needed to skip helper objects &#13;
<br/>
   PBidx = 0.0 &#13;
<br/>
   lineCount = float(len(lines)) &#13;
<br/><br/>
   print 'Read file' &#13;
<br/>
   Blender.Window.DrawProgressBar(0.0, "Read File...") &#13;
<br/><br/>
   for line in lines: &#13;
<br/>
      words = string.split(line) &#13;
<br/><br/>
      if (PBidx % 10000) == 0.0: &#13;
<br/>
                   Blender.Window.DrawProgressBar(PBidx / lineCount, "Read File...") &#13;
<br/><br/>
      if not words: &#13;
<br/>
         continue &#13;
<br/>
      elif words[0] == '*GEOMOBJECT': &#13;
<br/>
         objCheck = 0 &#13;
<br/>
         newObj = ase_obj() &#13;
<br/>
         objects.append(newObj) &#13;
<br/>
         obj = objects[objIdx] &#13;
<br/>
         objIdx += 1 &#13;
<br/>
      elif words[0] == '*NODE_NAME' and objCheck != -1: &#13;
<br/>
         if objCheck == 0: &#13;
<br/>
            obj.name = words[1] &#13;
<br/>
            objCheck = 1 &#13;
<br/>
         elif objCheck == 1: &#13;
<br/>
            obj.objName = words[1] &#13;
<br/>
      elif words[0] == '*TM_ROW0' and objCheck != -1: &#13;
<br/>
         obj.row0x = float(words[1]) &#13;
<br/>
         obj.row0y = float(words[2]) &#13;
<br/>
         obj.row0z = float(words[3]) &#13;
<br/>
      elif words[0] == '*TM_ROW1' and objCheck != -1: &#13;
<br/>
         obj.row1x = float(words[1]) &#13;
<br/>
         obj.row1y = float(words[2]) &#13;
<br/>
         obj.row1z = float(words[3]) &#13;
<br/>
      elif words[0] == '*TM_ROW2' and objCheck != -1: &#13;
<br/>
         obj.row2x = float(words[1]) &#13;
<br/>
         obj.row2y = float(words[2]) &#13;
<br/>
         obj.row2z = float(words[3]) &#13;
<br/>
      elif words[0] == '*TM_ROW3' and objCheck != -1: &#13;
<br/>
         obj.row3x = float(words[1]) &#13;
<br/>
         obj.row3y = float(words[2]) &#13;
<br/>
         obj.row3z = float(words[3]) &#13;
<br/>
         objCheck = -1 &#13;
<br/>
      elif words[0] == '*MESH': &#13;
<br/>
         obj.objType = 'Mesh' &#13;
<br/>
         obj.obj = ase_mesh() &#13;
<br/>
         me = obj.obj &#13;
<br/>
      elif words[0] == '*MESH_NUMVERTEX': &#13;
<br/>
         me.vCount = int(words[1]) &#13;
<br/>
      elif words[0] == '*MESH_NUMFACES': &#13;
<br/>
         me.fCount = int(words[1]) &#13;
<br/>
      elif words[0] == '*MESH_VERTEX': &#13;
<br/>
         #v = mesh_vert() &#13;
<br/>
         v = [float(words[2]),float(words[3]),float(words[4])]&#13;
<br/>
         #v.x = float(words[2])&#13;
<br/>
         #v.y = float(words[3])&#13;
<br/>
         #v.z = float(words[4])&#13;
<br/>
         me.meVerts.append(v) &#13;
<br/>
      elif words[0] == '*MESH_FACE':&#13;
<br/>
         #f = mesh_face()&#13;
<br/>
         f = [int(words[3]),int(words[5]),int(words[7])]&#13;
<br/>
         #f.v1 = int(words[3])&#13;
<br/>
         #f.v2 = int(words[5])&#13;
<br/>
         #f.v3 = int(words[7])&#13;
<br/>
         me.meFaces.append(f) &#13;
<br/>
      elif words[0] == '*MESH_NUMTVERTEX': &#13;
<br/>
         me.uvVCount = int(words[1]) &#13;
<br/>
         if me.uvVCount &gt; 0: &#13;
<br/>
            me.hasFUV = 1 &#13;
<br/>
      elif words[0] == '*MESH_TVERT': &#13;
<br/>
         uv = mesh_uvVert() &#13;
<br/>
         uv.index = int(words[1]) &#13;
<br/>
         uv.u = float(words[2]) &#13;
<br/>
         uv.v = float(words[3]) &#13;
<br/>
         me.uvVerts.append(uv) &#13;
<br/>
      elif words[0] == '*MESH_NUMTVFACES': &#13;
<br/>
         me.uvFCount = int(words[1]) &#13;
<br/>
      elif words[0] == '*MESH_TFACE': &#13;
<br/>
         fUv = mesh_uvFace() &#13;
<br/>
         fUv.index = int(words[1]) &#13;
<br/>
         fUv.uv1 = int(words[2]) &#13;
<br/>
         fUv.uv2 = int(words[3]) &#13;
<br/>
         fUv.uv3 = int(words[4]) &#13;
<br/>
         me.uvFaces.append(fUv) &#13;
<br/>
      elif words[0] == '*MESH_NUMCVERTEX': &#13;
<br/>
         me.vcVCount = int(words[1]) &#13;
<br/>
         if me.uvVCount &gt; 0: &#13;
<br/>
            me.hasVC = 1 &#13;
<br/>
      elif words[0] == '*MESH_VERTCOL': &#13;
<br/>
         c = mesh_vcVert() &#13;
<br/>
         c.index = int(words[1]) &#13;
<br/>
         c.r = round(float(words[2])*256) &#13;
<br/>
         c.g = round(float(words[3])*256) &#13;
<br/>
         c.b = round(float(words[4])*256) &#13;
<br/>
         me.vcVerts.append(c) &#13;
<br/>
      elif words[0] == '*MESH_CFACE': &#13;
<br/>
         fc = mesh_vcFace() &#13;
<br/>
         fc.index = int(words[1]) &#13;
<br/>
         fc.c1 = int(words[2]) &#13;
<br/>
         fc.c2 = int(words[3]) &#13;
<br/>
         fc.c3 = int(words[4]) &#13;
<br/>
         me.vcFaces.append(fc) &#13;
<br/><br/>
      PBidx += 1.0 &#13;
<br/><br/>
   spawn_main(objects) &#13;
<br/><br/>
   Blender.Redraw() &#13;
<br/><br/>
def spawn_main(objects):&#13;
<br/><br/>
   PBidx = 0.0 &#13;
<br/>
   objCount = float(len(objects)) &#13;
<br/><br/>
   print 'Import Objects' &#13;
<br/>
   Blender.Window.DrawProgressBar(0.0, "Importing Objects...") &#13;
<br/><br/>
   for obj in objects: &#13;
<br/><br/>
      Blender.Window.DrawProgressBar(PBidx / objCount, "Importing Objects...") &#13;
<br/><br/>
      if obj.objType == 'Mesh': &#13;
<br/>
         spawn_mesh(obj) &#13;
<br/><br/>
      PBidx += 1.0 &#13;
<br/><br/><br/>
def spawn_mesh(obj):&#13;
<br/><br/>
   objMe = obj.obj&#13;
<br/>
   #normal_flag = 1&#13;
<br/><br/>
   row0 = obj.row0x, obj.row0y, obj.row0z&#13;
<br/>
   row1 = obj.row1x, obj.row1y, obj.row1z&#13;
<br/>
   row2 = obj.row2x, obj.row2y, obj.row2z&#13;
<br/>
   row3 = obj.row3x, obj.row3y, obj.row3z&#13;
<br/><br/>
   newMatrix = Blender.Mathutils.Matrix(row0, row1, row2, row3)&#13;
<br/>
   newMatrix.resize4x4()&#13;
<br/><br/>
   newObj = Blender.Object.New(obj.objType, obj.name)&#13;
<br/>
   newObj.setMatrix(newMatrix)&#13;
<br/>
   Blender.Scene.getCurrent().link(newObj) &#13;
<br/><br/><br/>
   newMesh = Blender.Mesh.New(obj.objName) &#13;
<br/>
   newMesh.getFromObject(newObj.name) &#13;
<br/><br/><br/>
   # Verts &#13;
<br/>
   newMesh.verts.extend(objMe.meVerts)&#13;
<br/><br/>
   # Faces &#13;
<br/>
   newMesh.faces.extend(objMe.meFaces)&#13;
<br/><br/>
   #VertCol &#13;
<br/>
   if guiTable['VC'] == 1 and objMe.hasVC == 1: &#13;
<br/>
      newMesh.vertexColors = 1 &#13;
<br/>
      for c in objMe.vcFaces: &#13;
<br/><br/>
         FCol0 = newMesh.faces[c.index].col[0] &#13;
<br/>
         FCol1 = newMesh.faces[c.index].col[1] &#13;
<br/>
         FCol2 = newMesh.faces[c.index].col[2] &#13;
<br/><br/>
         FCol0.r = int(objMe.vcVerts[c.c1].r) &#13;
<br/>
         FCol0.g = int(objMe.vcVerts[c.c1].g) &#13;
<br/>
         FCol0.b = int(objMe.vcVerts[c.c1].b) &#13;
<br/><br/>
         FCol1.r = int(objMe.vcVerts[c.c2].r) &#13;
<br/>
         FCol1.g = int(objMe.vcVerts[c.c2].g) &#13;
<br/>
         FCol1.b = int(objMe.vcVerts[c.c2].b) &#13;
<br/><br/>
         FCol2.r = int(objMe.vcVerts[c.c3].r) &#13;
<br/>
         FCol2.g = int(objMe.vcVerts[c.c3].g) &#13;
<br/>
         FCol2.b = int(objMe.vcVerts[c.c3].b) &#13;
<br/><br/>
   # UV &#13;
<br/>
   if guiTable['UV'] == 1 and objMe.hasFUV == 1: &#13;
<br/>
      newMesh.faceUV = 1 &#13;
<br/>
      for f in objMe.uvFaces: &#13;
<br/>
         uv1 = Blender.Mathutils.Vector(float(objMe.uvVerts[f.uv1].u), float(objMe.uvVerts[f.uv1].v)) &#13;
<br/>
         uv2 = Blender.Mathutils.Vector(float(objMe.uvVerts[f.uv2].u), float(objMe.uvVerts[f.uv2].v)) &#13;
<br/>
         uv3 = Blender.Mathutils.Vector(float(objMe.uvVerts[f.uv3].u), float(objMe.uvVerts[f.uv3].v)) &#13;
<br/>
         newMesh.faces[f.index].uv = [uv1, uv2, uv3] &#13;
<br/><br/>
   newMesh.transform((newObj.getMatrix('worldspace').invert()), 1) &#13;
<br/>
   newObj.link(newMesh) &#13;
<br/><br/>
   counts['verts'] += objMe.vCount &#13;
<br/>
   counts['tris'] += objMe.fCount &#13;
<br/>
   print 'Imported Mesh-Object: ', obj.name &#13;
<br/><br/><br/><br/>
def read_ui(filename): &#13;
<br/><br/>
   global guiTable, IMPORT_VC, IMPORT_UV &#13;
<br/>
   guiTable = {'VC': 1, 'UV': 1} &#13;
<br/><br/>
   for s in Window.GetScreenInfo(): &#13;
<br/>
      Window.QHandle(s['id']) &#13;
<br/><br/>
   IMPORT_VC = Draw.Create(guiTable['VC']) &#13;
<br/>
   IMPORT_UV = Draw.Create(guiTable['UV']) &#13;
<br/><br/>
   # Get USER Options &#13;
<br/>
   pup_block = [('Import Options'),('Vertex Color', IMPORT_VC, 'Import Vertex Colors if exist'),('UV', IMPORT_UV, 'Import UV if exist'),] &#13;
<br/><br/>
   if not Draw.PupBlock('Import...', pup_block): &#13;
<br/>
      return &#13;
<br/><br/>
   Window.WaitCursor(1)&#13;
<br/><br/>
   guiTable['VC'] = IMPORT_VC.val &#13;
<br/>
   guiTable['UV'] = IMPORT_UV.val &#13;
<br/><br/>
   read_main(filename) &#13;
<br/><br/>
   Window.WaitCursor(0) &#13;
<br/><br/><br/>
if __name__ == '__main__': &#13;
<br/>
   Window.FileSelector(read_ui, 'Import ASCII Scene', ('.ase'))</td>	</tr></table><span class="postbody"/><span class="gensmall"><br/><br/>Last edited by Goofos on Tue Aug 15, 2006 12:25 pm; edited 4 times in total</span></td>
			</tr>]]></body></post><post id="140320" date="Posted: Mon Apr 17, 2006 1:12 pm    Post subject: "><author>Bittoman</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Nice job, thanks Goofos!</span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="140355" date="Posted: Mon Apr 17, 2006 10:30 pm    Post subject: "><author>kat</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Not tried it yet but 'GG' on doing this one. Another step up the ladder for Blender!<br/>_________________<br/><a href="https://web.archive.org/web/20061012234303/http://www.doom3world.org/" target="_blank" class="postlink"><img src="https://web.archive.org/web/20061012234303im_/http://www.doom3world.org/site/img/d3w.gif" border="0"/>Co-Admin</a> - <a href="https://web.archive.org/web/20061012234303/http://www.quake3bits.com/" target="_blank" class="postlink">Modelling and modding tutorials and tips</a></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="143616" date="Posted: Fri May 19, 2006 8:04 pm    Post subject: "><author>kat</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Just tried this script for the 1st time and encountered the following error with Blender 2.41 when run as a script from the text window (Alt+P).&#13;
<br/></span><table width="90%" cellspacing="1" cellpadding="3" border="0" align="center"><tr><td><span class="genmed"><b>Code:</b></span></td>	</tr><tr><td class="code">IndentationError: unindent does not match any outer indentation level&#13;
<br/>
  File "goofosASE_import_17Ap", line 295&#13;
<br/>
    if obj.objType == 'Mesh':&#13;
<br/>
                             ^</td>	</tr></table><span class="postbody"><br/>_________________<br/><a href="https://web.archive.org/web/20061012234303/http://www.doom3world.org/" target="_blank" class="postlink"><img src="https://web.archive.org/web/20061012234303im_/http://www.doom3world.org/site/img/d3w.gif" border="0"/>Co-Admin</a> - <a href="https://web.archive.org/web/20061012234303/http://www.quake3bits.com/" target="_blank" class="postlink">Modelling and modding tutorials and tips</a></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="143762" date="Posted: Sun May 21, 2006 3:58 pm    Post subject: "><author>Goofos</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Should work now. Seems my OS is a bit more tollerant with format errors :&gt;</span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="144077" date="Posted: Fri May 26, 2006 10:43 am    Post subject: "><author>OrbWeaver</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">I haven't tried this but it sounds great. Until now ASE has been almost universally considered an "export-only" format.</span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="144120" date="Posted: Fri May 26, 2006 5:33 pm    Post subject: New error"><author>kat</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">New error when doing Ctrl+P to run the script</span><table width="90%" cellspacing="1" cellpadding="3" border="0" align="center"><tr><td><span class="genmed"><b>Code:</b></span></td>	</tr><tr><td class="code">SyntaxError: invalid token&#13;
<br/>
  File "goofosASE_import_26Ma", line 382&#13;
<br/>
    pup_block = [\&#13;
<br/>
                  ^</td>	</tr></table><span class="postbody"><br/>_________________<br/><a href="https://web.archive.org/web/20061012234303/http://www.doom3world.org/" target="_blank" class="postlink"><img src="https://web.archive.org/web/20061012234303im_/http://www.doom3world.org/site/img/d3w.gif" border="0"/>Co-Admin</a> - <a href="https://web.archive.org/web/20061012234303/http://www.quake3bits.com/" target="_blank" class="postlink">Modelling and modding tutorials and tips</a></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="144546" date="Posted: Wed May 31, 2006 3:07 pm    Post subject: "><author>Goofos</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">There was a space at end of the line if you copy/paste the script from the forum. I have put the array in one line, should work now.</span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="144572" date="Posted: Wed May 31, 2006 6:19 pm    Post subject: "><author>kat</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">DUDE!! sorted. Both vertex and UVW import work fine and dandy.<br/>_________________<br/><a href="https://web.archive.org/web/20061012234303/http://www.doom3world.org/" target="_blank" class="postlink"><img src="https://web.archive.org/web/20061012234303im_/http://www.doom3world.org/site/img/d3w.gif" border="0"/>Co-Admin</a> - <a href="https://web.archive.org/web/20061012234303/http://www.quake3bits.com/" target="_blank" class="postlink">Modelling and modding tutorials and tips</a></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="153676" date="Posted: Tue Aug 15, 2006 12:07 pm    Post subject: "><author>Goofos</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Fixed a problem with the matrices, dont know why this suddenly happened.&#13;
<br/><br/>
[edit]&#13;
<br/>
I quickly updated it again (to v0.12) <img src="https://web.archive.org/web/20061012234303im_/http://doom3world.org/phpbb2/images/smiles/icon_biggrin.gif" alt="Very Happy" border="0"/> to use some improvements of 2.42 (which doesn't worked with 2.40). Now it should import (big) meshes much faster.</span><span class="gensmall"><br/><br/>Last edited by Goofos on Tue Aug 15, 2006 12:34 pm; edited 1 time in total</span></td>
			</tr>]]></body></post><post id="154876" date="Posted: Fri Aug 25, 2006 2:29 am    Post subject: "><author>Tweaker</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Excellent, I was having problems importing with 2.42a, but this seems to have fixed it.  Thanks.   <img src="https://web.archive.org/web/20061012234303im_/http://doom3world.org/phpbb2/images/smiles/icon_biggrin.gif" alt="Very Happy" border="0"/></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="140291" date="Posted: Mon Apr 17, 2006 2:00 am    Post subject: ASE Importer"><author>Goofos</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">I made a first small script to import ASE meshes. Its not perfect and may a bit lame but should import correct meshes (from 3DS). Materials are currently not supported but UV coords and VertexColors. &#13;
<br/>
Note: Meshes from 3DS are very big in Blender <img src="https://web.archive.org/web/20061012234547im_/http://doom3world.org/phpbb2/images/smiles/icon_biggrin.gif" alt="Very Happy" border="0"/><br/><br/></span><table width="90%" cellspacing="1" cellpadding="3" border="0" align="center"><tr><td><span class="genmed"><b>Code:</b></span></td>	</tr><tr><td class="code">#!BPY&#13;
<br/><br/>
""" &#13;
<br/>
Name: 'ASCII Scene (.ase) v0.12'&#13;
<br/>
Blender: 242&#13;
<br/>
Group: 'Import' &#13;
<br/>
Tooltip: 'ASCII Scene import (*.ase)' &#13;
<br/>
""" &#13;
<br/>
__author__ = "Goofos"&#13;
<br/>
__version__ = "0.12"&#13;
<br/><br/>
# goofos at epruegel.de &#13;
<br/>
# &#13;
<br/>
# ***** BEGIN GPL LICENSE BLOCK ***** &#13;
<br/>
#&#13;
<br/>
# This program is free software; you can redistribute it and/or&#13;
<br/>
# modify it under the terms of the GNU General Public License &#13;
<br/>
# as published by the Free Software Foundation; either version 2&#13;
<br/>
# of the License, or (at your option) any later version. &#13;
<br/>
# &#13;
<br/>
# This program is distributed in the hope that it will be useful, &#13;
<br/>
# but WITHOUT ANY WARRANTY; without even the implied warranty of &#13;
<br/>
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the &#13;
<br/>
# GNU General Public License for more details. &#13;
<br/>
# &#13;
<br/>
# You should have received a copy of the GNU General Public License &#13;
<br/>
# along with this program; if not, write to the Free Software Foundation, &#13;
<br/>
# Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. &#13;
<br/>
# &#13;
<br/>
# ***** END GPL LICENCE BLOCK ***** &#13;
<br/><br/>
import string, time, sys as osSys &#13;
<br/>
import Blender &#13;
<br/>
from Blender import Draw, Mesh, Window, Object, Scene &#13;
<br/>
#import meshtools &#13;
<br/><br/><br/>
def read_main(filename): &#13;
<br/><br/>
   global counts &#13;
<br/>
   counts = {'verts': 0, 'tris': 0} &#13;
<br/><br/>
   start = time.clock() &#13;
<br/>
   file = open(filename, "r") &#13;
<br/><br/>
   print_boxed("----------------start-----------------")&#13;
<br/>
   print 'Import Patch: ', filename &#13;
<br/><br/>
   editmode = Window.EditMode()    # are we in edit mode?  If so ... &#13;
<br/>
   if editmode: Window.EditMode(0) # leave edit mode before getting the mesh&#13;
<br/><br/>
   lines= file.readlines() &#13;
<br/>
   read_file(file, lines) &#13;
<br/><br/>
   Blender.Window.DrawProgressBar(1.0, '')  # clear progressbar&#13;
<br/>
   file.close() &#13;
<br/>
   print "----------------end-----------------" &#13;
<br/>
   end = time.clock() &#13;
<br/>
   seconds = " in %.2f %s" % (end-start, "seconds") &#13;
<br/>
   totals = "Verts: %i Tris: %i " % (counts['verts'], counts['tris']) &#13;
<br/>
   print_boxed(totals) &#13;
<br/>
   message = "Successfully imported " + Blender.sys.basename(filename) + seconds &#13;
<br/>
   #meshtools.print_boxed(message) &#13;
<br/>
   print_boxed(message) &#13;
<br/><br/><br/>
def print_boxed(text): #Copy/Paste from meshtools, only to remove the beep :) &#13;
<br/>
   lines = text.splitlines() &#13;
<br/>
   maxlinelen = max(map(len, lines)) &#13;
<br/>
   if osSys.platform[:3] == "win": &#13;
<br/>
      print chr(218)+chr(196) + chr(196)*maxlinelen + chr(196)+chr(191) &#13;
<br/>
      for line in lines: &#13;
<br/>
         print chr(179) + ' ' + line.ljust(maxlinelen) + ' ' + chr(179) &#13;
<br/>
      print chr(192)+chr(196) + chr(196)*maxlinelen + chr(196)+chr(217) &#13;
<br/>
   else: &#13;
<br/>
      print '+-' + '-'*maxlinelen + '-+' &#13;
<br/>
      for line in lines: print '| ' + line.ljust(maxlinelen) + ' |' &#13;
<br/>
      print '+-' + '-'*maxlinelen + '-+' &#13;
<br/>
   #print '\a\r', # beep when done &#13;
<br/><br/><br/>
class ase_obj: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.name = 'Name' &#13;
<br/>
      self.objType = None &#13;
<br/>
      self.row0x = None &#13;
<br/>
      self.row0y = None &#13;
<br/>
      self.row0z = None &#13;
<br/>
      self.row1x = None &#13;
<br/>
      self.row1y = None &#13;
<br/>
      self.row1z = None &#13;
<br/>
      self.row2x = None &#13;
<br/>
      self.row2y = None &#13;
<br/>
      self.row2z = None &#13;
<br/>
      self.row3x = None &#13;
<br/>
      self.row3y = None &#13;
<br/>
      self.row3z = None &#13;
<br/>
      self.parent = None &#13;
<br/>
      self.obj = None &#13;
<br/>
      self.objName = 'Name' &#13;
<br/><br/>
class ase_mesh: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.name = '' &#13;
<br/>
      self.vCount = 0 &#13;
<br/>
      self.fCount = 0 &#13;
<br/>
      self.uvVCount = 0 &#13;
<br/>
      self.uvFCount = 0 &#13;
<br/>
      self.vcVCount = 0 &#13;
<br/>
      self.vcFCount = 0 &#13;
<br/>
      self.meVerts = [] &#13;
<br/>
      self.meFaces = [] &#13;
<br/>
      self.uvVerts = [] &#13;
<br/>
      self.uvFaces = [] &#13;
<br/>
      self.vcVerts = [] &#13;
<br/>
      self.vcFaces = [] &#13;
<br/>
      self.hasFUV = 0 &#13;
<br/>
      self.hasVC = 0 &#13;
<br/><br/>
class mesh_face: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.v1 = 0 &#13;
<br/>
      self.v2 = 0 &#13;
<br/>
      self.v3 = 0 &#13;
<br/>
      self.mat = None &#13;
<br/>
       &#13;
<br/>
class mesh_vert: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.x = 0.0 &#13;
<br/>
      self.y = 0.0 &#13;
<br/>
      self.z = 0.0 &#13;
<br/><br/>
class mesh_uvVert: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.index = 0 &#13;
<br/>
      self.u = 0.0 &#13;
<br/>
      self.v = 0.0 &#13;
<br/>
      self.vec = Blender.Mathutils.Vector(self.u, self.v) &#13;
<br/><br/>
class mesh_uvFace: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.index = 0 &#13;
<br/>
      self.uv1 = 0 &#13;
<br/>
      self.uv2 = 0 &#13;
<br/>
      self.uv3 = 0 &#13;
<br/>
       &#13;
<br/>
class mesh_vcVert: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.index = 0 &#13;
<br/>
      self.r = 0 &#13;
<br/>
      self.g = 0 &#13;
<br/>
      self.b = 0 &#13;
<br/>
      self.a = 255 &#13;
<br/>
       &#13;
<br/>
class mesh_vcFace: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.index = 0 &#13;
<br/>
      self.c1 = 0 &#13;
<br/>
      self.c2 = 0 &#13;
<br/>
      self.c3 = 0 &#13;
<br/><br/><br/>
def read_file(file, lines): &#13;
<br/><br/>
   objects = [] &#13;
<br/>
   objIdx = 0 &#13;
<br/>
   objCheck = -1 #needed to skip helper objects &#13;
<br/>
   PBidx = 0.0 &#13;
<br/>
   lineCount = float(len(lines)) &#13;
<br/><br/>
   print 'Read file' &#13;
<br/>
   Blender.Window.DrawProgressBar(0.0, "Read File...") &#13;
<br/><br/>
   for line in lines: &#13;
<br/>
      words = string.split(line) &#13;
<br/><br/>
      if (PBidx % 10000) == 0.0: &#13;
<br/>
                   Blender.Window.DrawProgressBar(PBidx / lineCount, "Read File...") &#13;
<br/><br/>
      if not words: &#13;
<br/>
         continue &#13;
<br/>
      elif words[0] == '*GEOMOBJECT': &#13;
<br/>
         objCheck = 0 &#13;
<br/>
         newObj = ase_obj() &#13;
<br/>
         objects.append(newObj) &#13;
<br/>
         obj = objects[objIdx] &#13;
<br/>
         objIdx += 1 &#13;
<br/>
      elif words[0] == '*NODE_NAME' and objCheck != -1: &#13;
<br/>
         if objCheck == 0: &#13;
<br/>
            obj.name = words[1] &#13;
<br/>
            objCheck = 1 &#13;
<br/>
         elif objCheck == 1: &#13;
<br/>
            obj.objName = words[1] &#13;
<br/>
      elif words[0] == '*TM_ROW0' and objCheck != -1: &#13;
<br/>
         obj.row0x = float(words[1]) &#13;
<br/>
         obj.row0y = float(words[2]) &#13;
<br/>
         obj.row0z = float(words[3]) &#13;
<br/>
      elif words[0] == '*TM_ROW1' and objCheck != -1: &#13;
<br/>
         obj.row1x = float(words[1]) &#13;
<br/>
         obj.row1y = float(words[2]) &#13;
<br/>
         obj.row1z = float(words[3]) &#13;
<br/>
      elif words[0] == '*TM_ROW2' and objCheck != -1: &#13;
<br/>
         obj.row2x = float(words[1]) &#13;
<br/>
         obj.row2y = float(words[2]) &#13;
<br/>
         obj.row2z = float(words[3]) &#13;
<br/>
      elif words[0] == '*TM_ROW3' and objCheck != -1: &#13;
<br/>
         obj.row3x = float(words[1]) &#13;
<br/>
         obj.row3y = float(words[2]) &#13;
<br/>
         obj.row3z = float(words[3]) &#13;
<br/>
         objCheck = -1 &#13;
<br/>
      elif words[0] == '*MESH': &#13;
<br/>
         obj.objType = 'Mesh' &#13;
<br/>
         obj.obj = ase_mesh() &#13;
<br/>
         me = obj.obj &#13;
<br/>
      elif words[0] == '*MESH_NUMVERTEX': &#13;
<br/>
         me.vCount = int(words[1]) &#13;
<br/>
      elif words[0] == '*MESH_NUMFACES': &#13;
<br/>
         me.fCount = int(words[1]) &#13;
<br/>
      elif words[0] == '*MESH_VERTEX': &#13;
<br/>
         #v = mesh_vert() &#13;
<br/>
         v = [float(words[2]),float(words[3]),float(words[4])]&#13;
<br/>
         #v.x = float(words[2])&#13;
<br/>
         #v.y = float(words[3])&#13;
<br/>
         #v.z = float(words[4])&#13;
<br/>
         me.meVerts.append(v) &#13;
<br/>
      elif words[0] == '*MESH_FACE':&#13;
<br/>
         #f = mesh_face()&#13;
<br/>
         f = [int(words[3]),int(words[5]),int(words[7])]&#13;
<br/>
         #f.v1 = int(words[3])&#13;
<br/>
         #f.v2 = int(words[5])&#13;
<br/>
         #f.v3 = int(words[7])&#13;
<br/>
         me.meFaces.append(f) &#13;
<br/>
      elif words[0] == '*MESH_NUMTVERTEX': &#13;
<br/>
         me.uvVCount = int(words[1]) &#13;
<br/>
         if me.uvVCount &gt; 0: &#13;
<br/>
            me.hasFUV = 1 &#13;
<br/>
      elif words[0] == '*MESH_TVERT': &#13;
<br/>
         uv = mesh_uvVert() &#13;
<br/>
         uv.index = int(words[1]) &#13;
<br/>
         uv.u = float(words[2]) &#13;
<br/>
         uv.v = float(words[3]) &#13;
<br/>
         me.uvVerts.append(uv) &#13;
<br/>
      elif words[0] == '*MESH_NUMTVFACES': &#13;
<br/>
         me.uvFCount = int(words[1]) &#13;
<br/>
      elif words[0] == '*MESH_TFACE': &#13;
<br/>
         fUv = mesh_uvFace() &#13;
<br/>
         fUv.index = int(words[1]) &#13;
<br/>
         fUv.uv1 = int(words[2]) &#13;
<br/>
         fUv.uv2 = int(words[3]) &#13;
<br/>
         fUv.uv3 = int(words[4]) &#13;
<br/>
         me.uvFaces.append(fUv) &#13;
<br/>
      elif words[0] == '*MESH_NUMCVERTEX': &#13;
<br/>
         me.vcVCount = int(words[1]) &#13;
<br/>
         if me.uvVCount &gt; 0: &#13;
<br/>
            me.hasVC = 1 &#13;
<br/>
      elif words[0] == '*MESH_VERTCOL': &#13;
<br/>
         c = mesh_vcVert() &#13;
<br/>
         c.index = int(words[1]) &#13;
<br/>
         c.r = round(float(words[2])*256) &#13;
<br/>
         c.g = round(float(words[3])*256) &#13;
<br/>
         c.b = round(float(words[4])*256) &#13;
<br/>
         me.vcVerts.append(c) &#13;
<br/>
      elif words[0] == '*MESH_CFACE': &#13;
<br/>
         fc = mesh_vcFace() &#13;
<br/>
         fc.index = int(words[1]) &#13;
<br/>
         fc.c1 = int(words[2]) &#13;
<br/>
         fc.c2 = int(words[3]) &#13;
<br/>
         fc.c3 = int(words[4]) &#13;
<br/>
         me.vcFaces.append(fc) &#13;
<br/><br/>
      PBidx += 1.0 &#13;
<br/><br/>
   spawn_main(objects) &#13;
<br/><br/>
   Blender.Redraw() &#13;
<br/><br/>
def spawn_main(objects):&#13;
<br/><br/>
   PBidx = 0.0 &#13;
<br/>
   objCount = float(len(objects)) &#13;
<br/><br/>
   print 'Import Objects' &#13;
<br/>
   Blender.Window.DrawProgressBar(0.0, "Importing Objects...") &#13;
<br/><br/>
   for obj in objects: &#13;
<br/><br/>
      Blender.Window.DrawProgressBar(PBidx / objCount, "Importing Objects...") &#13;
<br/><br/>
      if obj.objType == 'Mesh': &#13;
<br/>
         spawn_mesh(obj) &#13;
<br/><br/>
      PBidx += 1.0 &#13;
<br/><br/><br/>
def spawn_mesh(obj):&#13;
<br/><br/>
   objMe = obj.obj&#13;
<br/>
   #normal_flag = 1&#13;
<br/><br/>
   row0 = obj.row0x, obj.row0y, obj.row0z&#13;
<br/>
   row1 = obj.row1x, obj.row1y, obj.row1z&#13;
<br/>
   row2 = obj.row2x, obj.row2y, obj.row2z&#13;
<br/>
   row3 = obj.row3x, obj.row3y, obj.row3z&#13;
<br/><br/>
   newMatrix = Blender.Mathutils.Matrix(row0, row1, row2, row3)&#13;
<br/>
   newMatrix.resize4x4()&#13;
<br/><br/>
   newObj = Blender.Object.New(obj.objType, obj.name)&#13;
<br/>
   newObj.setMatrix(newMatrix)&#13;
<br/>
   Blender.Scene.getCurrent().link(newObj) &#13;
<br/><br/><br/>
   newMesh = Blender.Mesh.New(obj.objName) &#13;
<br/>
   newMesh.getFromObject(newObj.name) &#13;
<br/><br/><br/>
   # Verts &#13;
<br/>
   newMesh.verts.extend(objMe.meVerts)&#13;
<br/><br/>
   # Faces &#13;
<br/>
   newMesh.faces.extend(objMe.meFaces)&#13;
<br/><br/>
   #VertCol &#13;
<br/>
   if guiTable['VC'] == 1 and objMe.hasVC == 1: &#13;
<br/>
      newMesh.vertexColors = 1 &#13;
<br/>
      for c in objMe.vcFaces: &#13;
<br/><br/>
         FCol0 = newMesh.faces[c.index].col[0] &#13;
<br/>
         FCol1 = newMesh.faces[c.index].col[1] &#13;
<br/>
         FCol2 = newMesh.faces[c.index].col[2] &#13;
<br/><br/>
         FCol0.r = int(objMe.vcVerts[c.c1].r) &#13;
<br/>
         FCol0.g = int(objMe.vcVerts[c.c1].g) &#13;
<br/>
         FCol0.b = int(objMe.vcVerts[c.c1].b) &#13;
<br/><br/>
         FCol1.r = int(objMe.vcVerts[c.c2].r) &#13;
<br/>
         FCol1.g = int(objMe.vcVerts[c.c2].g) &#13;
<br/>
         FCol1.b = int(objMe.vcVerts[c.c2].b) &#13;
<br/><br/>
         FCol2.r = int(objMe.vcVerts[c.c3].r) &#13;
<br/>
         FCol2.g = int(objMe.vcVerts[c.c3].g) &#13;
<br/>
         FCol2.b = int(objMe.vcVerts[c.c3].b) &#13;
<br/><br/>
   # UV &#13;
<br/>
   if guiTable['UV'] == 1 and objMe.hasFUV == 1: &#13;
<br/>
      newMesh.faceUV = 1 &#13;
<br/>
      for f in objMe.uvFaces: &#13;
<br/>
         uv1 = Blender.Mathutils.Vector(float(objMe.uvVerts[f.uv1].u), float(objMe.uvVerts[f.uv1].v)) &#13;
<br/>
         uv2 = Blender.Mathutils.Vector(float(objMe.uvVerts[f.uv2].u), float(objMe.uvVerts[f.uv2].v)) &#13;
<br/>
         uv3 = Blender.Mathutils.Vector(float(objMe.uvVerts[f.uv3].u), float(objMe.uvVerts[f.uv3].v)) &#13;
<br/>
         newMesh.faces[f.index].uv = [uv1, uv2, uv3] &#13;
<br/><br/>
   newMesh.transform((newObj.getMatrix('worldspace').invert()), 1) &#13;
<br/>
   newObj.link(newMesh) &#13;
<br/><br/>
   counts['verts'] += objMe.vCount &#13;
<br/>
   counts['tris'] += objMe.fCount &#13;
<br/>
   print 'Imported Mesh-Object: ', obj.name &#13;
<br/><br/><br/><br/>
def read_ui(filename): &#13;
<br/><br/>
   global guiTable, IMPORT_VC, IMPORT_UV &#13;
<br/>
   guiTable = {'VC': 1, 'UV': 1} &#13;
<br/><br/>
   for s in Window.GetScreenInfo(): &#13;
<br/>
      Window.QHandle(s['id']) &#13;
<br/><br/>
   IMPORT_VC = Draw.Create(guiTable['VC']) &#13;
<br/>
   IMPORT_UV = Draw.Create(guiTable['UV']) &#13;
<br/><br/>
   # Get USER Options &#13;
<br/>
   pup_block = [('Import Options'),('Vertex Color', IMPORT_VC, 'Import Vertex Colors if exist'),('UV', IMPORT_UV, 'Import UV if exist'),] &#13;
<br/><br/>
   if not Draw.PupBlock('Import...', pup_block): &#13;
<br/>
      return &#13;
<br/><br/>
   Window.WaitCursor(1)&#13;
<br/><br/>
   guiTable['VC'] = IMPORT_VC.val &#13;
<br/>
   guiTable['UV'] = IMPORT_UV.val &#13;
<br/><br/>
   read_main(filename) &#13;
<br/><br/>
   Window.WaitCursor(0) &#13;
<br/><br/><br/>
if __name__ == '__main__': &#13;
<br/>
   Window.FileSelector(read_ui, 'Import ASCII Scene', ('.ase'))</td>	</tr></table><span class="postbody"/><span class="gensmall"><br/><br/>Last edited by Goofos on Tue Aug 15, 2006 12:25 pm; edited 4 times in total</span></td>
			</tr>]]></body></post><post id="140320" date="Posted: Mon Apr 17, 2006 1:12 pm    Post subject: "><author>Bittoman</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Nice job, thanks Goofos!</span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="140355" date="Posted: Mon Apr 17, 2006 10:30 pm    Post subject: "><author>kat</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Not tried it yet but 'GG' on doing this one. Another step up the ladder for Blender!<br/>_________________<br/><a href="https://web.archive.org/web/20061012234547/http://www.doom3world.org/" target="_blank" class="postlink"><img src="https://web.archive.org/web/20061012234547im_/http://www.doom3world.org/site/img/d3w.gif" border="0"/>Co-Admin</a> - <a href="https://web.archive.org/web/20061012234547/http://www.quake3bits.com/" target="_blank" class="postlink">Modelling and modding tutorials and tips</a></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="143616" date="Posted: Fri May 19, 2006 8:04 pm    Post subject: "><author>kat</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Just tried this script for the 1st time and encountered the following error with Blender 2.41 when run as a script from the text window (Alt+P).&#13;
<br/></span><table width="90%" cellspacing="1" cellpadding="3" border="0" align="center"><tr><td><span class="genmed"><b>Code:</b></span></td>	</tr><tr><td class="code">IndentationError: unindent does not match any outer indentation level&#13;
<br/>
  File "goofosASE_import_17Ap", line 295&#13;
<br/>
    if obj.objType == 'Mesh':&#13;
<br/>
                             ^</td>	</tr></table><span class="postbody"><br/>_________________<br/><a href="https://web.archive.org/web/20061012234547/http://www.doom3world.org/" target="_blank" class="postlink"><img src="https://web.archive.org/web/20061012234547im_/http://www.doom3world.org/site/img/d3w.gif" border="0"/>Co-Admin</a> - <a href="https://web.archive.org/web/20061012234547/http://www.quake3bits.com/" target="_blank" class="postlink">Modelling and modding tutorials and tips</a></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="143762" date="Posted: Sun May 21, 2006 3:58 pm    Post subject: "><author>Goofos</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Should work now. Seems my OS is a bit more tollerant with format errors :&gt;</span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="144077" date="Posted: Fri May 26, 2006 10:43 am    Post subject: "><author>OrbWeaver</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">I haven't tried this but it sounds great. Until now ASE has been almost universally considered an "export-only" format.</span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="144120" date="Posted: Fri May 26, 2006 5:33 pm    Post subject: New error"><author>kat</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">New error when doing Ctrl+P to run the script</span><table width="90%" cellspacing="1" cellpadding="3" border="0" align="center"><tr><td><span class="genmed"><b>Code:</b></span></td>	</tr><tr><td class="code">SyntaxError: invalid token&#13;
<br/>
  File "goofosASE_import_26Ma", line 382&#13;
<br/>
    pup_block = [\&#13;
<br/>
                  ^</td>	</tr></table><span class="postbody"><br/>_________________<br/><a href="https://web.archive.org/web/20061012234547/http://www.doom3world.org/" target="_blank" class="postlink"><img src="https://web.archive.org/web/20061012234547im_/http://www.doom3world.org/site/img/d3w.gif" border="0"/>Co-Admin</a> - <a href="https://web.archive.org/web/20061012234547/http://www.quake3bits.com/" target="_blank" class="postlink">Modelling and modding tutorials and tips</a></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="144546" date="Posted: Wed May 31, 2006 3:07 pm    Post subject: "><author>Goofos</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">There was a space at end of the line if you copy/paste the script from the forum. I have put the array in one line, should work now.</span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="144572" date="Posted: Wed May 31, 2006 6:19 pm    Post subject: "><author>kat</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">DUDE!! sorted. Both vertex and UVW import work fine and dandy.<br/>_________________<br/><a href="https://web.archive.org/web/20061012234547/http://www.doom3world.org/" target="_blank" class="postlink"><img src="https://web.archive.org/web/20061012234547im_/http://www.doom3world.org/site/img/d3w.gif" border="0"/>Co-Admin</a> - <a href="https://web.archive.org/web/20061012234547/http://www.quake3bits.com/" target="_blank" class="postlink">Modelling and modding tutorials and tips</a></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="153676" date="Posted: Tue Aug 15, 2006 12:07 pm    Post subject: "><author>Goofos</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Fixed a problem with the matrices, dont know why this suddenly happened.&#13;
<br/><br/>
[edit]&#13;
<br/>
I quickly updated it again (to v0.12) <img src="https://web.archive.org/web/20061012234547im_/http://doom3world.org/phpbb2/images/smiles/icon_biggrin.gif" alt="Very Happy" border="0"/> to use some improvements of 2.42 (which doesn't worked with 2.40). Now it should import (big) meshes much faster.</span><span class="gensmall"><br/><br/>Last edited by Goofos on Tue Aug 15, 2006 12:34 pm; edited 1 time in total</span></td>
			</tr>]]></body></post><post id="154876" date="Posted: Fri Aug 25, 2006 2:29 am    Post subject: "><author>Tweaker</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Excellent, I was having problems importing with 2.42a, but this seems to have fixed it.  Thanks.   <img src="https://web.archive.org/web/20061012234547im_/http://doom3world.org/phpbb2/images/smiles/icon_biggrin.gif" alt="Very Happy" border="0"/></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="140291" date="Posted: Mon Apr 17, 2006 2:00 am    Post subject: ASE Importer"><author>Goofos</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">I made a first small script to import ASE meshes. Its not perfect and may a bit lame but should import correct meshes (from 3DS). Materials are currently not supported but UV coords and VertexColors. &#13;
<br/>
Note: Meshes from 3DS are very big in Blender <img src="https://web.archive.org/web/20061012234650im_/http://doom3world.org/phpbb2/images/smiles/icon_biggrin.gif" alt="Very Happy" border="0"/><br/><br/></span><table width="90%" cellspacing="1" cellpadding="3" border="0" align="center"><tr><td><span class="genmed"><b>Code:</b></span></td>	</tr><tr><td class="code">#!BPY&#13;
<br/><br/>
""" &#13;
<br/>
Name: 'ASCII Scene (.ase) v0.12'&#13;
<br/>
Blender: 242&#13;
<br/>
Group: 'Import' &#13;
<br/>
Tooltip: 'ASCII Scene import (*.ase)' &#13;
<br/>
""" &#13;
<br/>
__author__ = "Goofos"&#13;
<br/>
__version__ = "0.12"&#13;
<br/><br/>
# goofos at epruegel.de &#13;
<br/>
# &#13;
<br/>
# ***** BEGIN GPL LICENSE BLOCK ***** &#13;
<br/>
#&#13;
<br/>
# This program is free software; you can redistribute it and/or&#13;
<br/>
# modify it under the terms of the GNU General Public License &#13;
<br/>
# as published by the Free Software Foundation; either version 2&#13;
<br/>
# of the License, or (at your option) any later version. &#13;
<br/>
# &#13;
<br/>
# This program is distributed in the hope that it will be useful, &#13;
<br/>
# but WITHOUT ANY WARRANTY; without even the implied warranty of &#13;
<br/>
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the &#13;
<br/>
# GNU General Public License for more details. &#13;
<br/>
# &#13;
<br/>
# You should have received a copy of the GNU General Public License &#13;
<br/>
# along with this program; if not, write to the Free Software Foundation, &#13;
<br/>
# Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. &#13;
<br/>
# &#13;
<br/>
# ***** END GPL LICENCE BLOCK ***** &#13;
<br/><br/>
import string, time, sys as osSys &#13;
<br/>
import Blender &#13;
<br/>
from Blender import Draw, Mesh, Window, Object, Scene &#13;
<br/>
#import meshtools &#13;
<br/><br/><br/>
def read_main(filename): &#13;
<br/><br/>
   global counts &#13;
<br/>
   counts = {'verts': 0, 'tris': 0} &#13;
<br/><br/>
   start = time.clock() &#13;
<br/>
   file = open(filename, "r") &#13;
<br/><br/>
   print_boxed("----------------start-----------------")&#13;
<br/>
   print 'Import Patch: ', filename &#13;
<br/><br/>
   editmode = Window.EditMode()    # are we in edit mode?  If so ... &#13;
<br/>
   if editmode: Window.EditMode(0) # leave edit mode before getting the mesh&#13;
<br/><br/>
   lines= file.readlines() &#13;
<br/>
   read_file(file, lines) &#13;
<br/><br/>
   Blender.Window.DrawProgressBar(1.0, '')  # clear progressbar&#13;
<br/>
   file.close() &#13;
<br/>
   print "----------------end-----------------" &#13;
<br/>
   end = time.clock() &#13;
<br/>
   seconds = " in %.2f %s" % (end-start, "seconds") &#13;
<br/>
   totals = "Verts: %i Tris: %i " % (counts['verts'], counts['tris']) &#13;
<br/>
   print_boxed(totals) &#13;
<br/>
   message = "Successfully imported " + Blender.sys.basename(filename) + seconds &#13;
<br/>
   #meshtools.print_boxed(message) &#13;
<br/>
   print_boxed(message) &#13;
<br/><br/><br/>
def print_boxed(text): #Copy/Paste from meshtools, only to remove the beep :) &#13;
<br/>
   lines = text.splitlines() &#13;
<br/>
   maxlinelen = max(map(len, lines)) &#13;
<br/>
   if osSys.platform[:3] == "win": &#13;
<br/>
      print chr(218)+chr(196) + chr(196)*maxlinelen + chr(196)+chr(191) &#13;
<br/>
      for line in lines: &#13;
<br/>
         print chr(179) + ' ' + line.ljust(maxlinelen) + ' ' + chr(179) &#13;
<br/>
      print chr(192)+chr(196) + chr(196)*maxlinelen + chr(196)+chr(217) &#13;
<br/>
   else: &#13;
<br/>
      print '+-' + '-'*maxlinelen + '-+' &#13;
<br/>
      for line in lines: print '| ' + line.ljust(maxlinelen) + ' |' &#13;
<br/>
      print '+-' + '-'*maxlinelen + '-+' &#13;
<br/>
   #print '\a\r', # beep when done &#13;
<br/><br/><br/>
class ase_obj: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.name = 'Name' &#13;
<br/>
      self.objType = None &#13;
<br/>
      self.row0x = None &#13;
<br/>
      self.row0y = None &#13;
<br/>
      self.row0z = None &#13;
<br/>
      self.row1x = None &#13;
<br/>
      self.row1y = None &#13;
<br/>
      self.row1z = None &#13;
<br/>
      self.row2x = None &#13;
<br/>
      self.row2y = None &#13;
<br/>
      self.row2z = None &#13;
<br/>
      self.row3x = None &#13;
<br/>
      self.row3y = None &#13;
<br/>
      self.row3z = None &#13;
<br/>
      self.parent = None &#13;
<br/>
      self.obj = None &#13;
<br/>
      self.objName = 'Name' &#13;
<br/><br/>
class ase_mesh: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.name = '' &#13;
<br/>
      self.vCount = 0 &#13;
<br/>
      self.fCount = 0 &#13;
<br/>
      self.uvVCount = 0 &#13;
<br/>
      self.uvFCount = 0 &#13;
<br/>
      self.vcVCount = 0 &#13;
<br/>
      self.vcFCount = 0 &#13;
<br/>
      self.meVerts = [] &#13;
<br/>
      self.meFaces = [] &#13;
<br/>
      self.uvVerts = [] &#13;
<br/>
      self.uvFaces = [] &#13;
<br/>
      self.vcVerts = [] &#13;
<br/>
      self.vcFaces = [] &#13;
<br/>
      self.hasFUV = 0 &#13;
<br/>
      self.hasVC = 0 &#13;
<br/><br/>
class mesh_face: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.v1 = 0 &#13;
<br/>
      self.v2 = 0 &#13;
<br/>
      self.v3 = 0 &#13;
<br/>
      self.mat = None &#13;
<br/>
       &#13;
<br/>
class mesh_vert: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.x = 0.0 &#13;
<br/>
      self.y = 0.0 &#13;
<br/>
      self.z = 0.0 &#13;
<br/><br/>
class mesh_uvVert: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.index = 0 &#13;
<br/>
      self.u = 0.0 &#13;
<br/>
      self.v = 0.0 &#13;
<br/>
      self.vec = Blender.Mathutils.Vector(self.u, self.v) &#13;
<br/><br/>
class mesh_uvFace: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.index = 0 &#13;
<br/>
      self.uv1 = 0 &#13;
<br/>
      self.uv2 = 0 &#13;
<br/>
      self.uv3 = 0 &#13;
<br/>
       &#13;
<br/>
class mesh_vcVert: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.index = 0 &#13;
<br/>
      self.r = 0 &#13;
<br/>
      self.g = 0 &#13;
<br/>
      self.b = 0 &#13;
<br/>
      self.a = 255 &#13;
<br/>
       &#13;
<br/>
class mesh_vcFace: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.index = 0 &#13;
<br/>
      self.c1 = 0 &#13;
<br/>
      self.c2 = 0 &#13;
<br/>
      self.c3 = 0 &#13;
<br/><br/><br/>
def read_file(file, lines): &#13;
<br/><br/>
   objects = [] &#13;
<br/>
   objIdx = 0 &#13;
<br/>
   objCheck = -1 #needed to skip helper objects &#13;
<br/>
   PBidx = 0.0 &#13;
<br/>
   lineCount = float(len(lines)) &#13;
<br/><br/>
   print 'Read file' &#13;
<br/>
   Blender.Window.DrawProgressBar(0.0, "Read File...") &#13;
<br/><br/>
   for line in lines: &#13;
<br/>
      words = string.split(line) &#13;
<br/><br/>
      if (PBidx % 10000) == 0.0: &#13;
<br/>
                   Blender.Window.DrawProgressBar(PBidx / lineCount, "Read File...") &#13;
<br/><br/>
      if not words: &#13;
<br/>
         continue &#13;
<br/>
      elif words[0] == '*GEOMOBJECT': &#13;
<br/>
         objCheck = 0 &#13;
<br/>
         newObj = ase_obj() &#13;
<br/>
         objects.append(newObj) &#13;
<br/>
         obj = objects[objIdx] &#13;
<br/>
         objIdx += 1 &#13;
<br/>
      elif words[0] == '*NODE_NAME' and objCheck != -1: &#13;
<br/>
         if objCheck == 0: &#13;
<br/>
            obj.name = words[1] &#13;
<br/>
            objCheck = 1 &#13;
<br/>
         elif objCheck == 1: &#13;
<br/>
            obj.objName = words[1] &#13;
<br/>
      elif words[0] == '*TM_ROW0' and objCheck != -1: &#13;
<br/>
         obj.row0x = float(words[1]) &#13;
<br/>
         obj.row0y = float(words[2]) &#13;
<br/>
         obj.row0z = float(words[3]) &#13;
<br/>
      elif words[0] == '*TM_ROW1' and objCheck != -1: &#13;
<br/>
         obj.row1x = float(words[1]) &#13;
<br/>
         obj.row1y = float(words[2]) &#13;
<br/>
         obj.row1z = float(words[3]) &#13;
<br/>
      elif words[0] == '*TM_ROW2' and objCheck != -1: &#13;
<br/>
         obj.row2x = float(words[1]) &#13;
<br/>
         obj.row2y = float(words[2]) &#13;
<br/>
         obj.row2z = float(words[3]) &#13;
<br/>
      elif words[0] == '*TM_ROW3' and objCheck != -1: &#13;
<br/>
         obj.row3x = float(words[1]) &#13;
<br/>
         obj.row3y = float(words[2]) &#13;
<br/>
         obj.row3z = float(words[3]) &#13;
<br/>
         objCheck = -1 &#13;
<br/>
      elif words[0] == '*MESH': &#13;
<br/>
         obj.objType = 'Mesh' &#13;
<br/>
         obj.obj = ase_mesh() &#13;
<br/>
         me = obj.obj &#13;
<br/>
      elif words[0] == '*MESH_NUMVERTEX': &#13;
<br/>
         me.vCount = int(words[1]) &#13;
<br/>
      elif words[0] == '*MESH_NUMFACES': &#13;
<br/>
         me.fCount = int(words[1]) &#13;
<br/>
      elif words[0] == '*MESH_VERTEX': &#13;
<br/>
         #v = mesh_vert() &#13;
<br/>
         v = [float(words[2]),float(words[3]),float(words[4])]&#13;
<br/>
         #v.x = float(words[2])&#13;
<br/>
         #v.y = float(words[3])&#13;
<br/>
         #v.z = float(words[4])&#13;
<br/>
         me.meVerts.append(v) &#13;
<br/>
      elif words[0] == '*MESH_FACE':&#13;
<br/>
         #f = mesh_face()&#13;
<br/>
         f = [int(words[3]),int(words[5]),int(words[7])]&#13;
<br/>
         #f.v1 = int(words[3])&#13;
<br/>
         #f.v2 = int(words[5])&#13;
<br/>
         #f.v3 = int(words[7])&#13;
<br/>
         me.meFaces.append(f) &#13;
<br/>
      elif words[0] == '*MESH_NUMTVERTEX': &#13;
<br/>
         me.uvVCount = int(words[1]) &#13;
<br/>
         if me.uvVCount &gt; 0: &#13;
<br/>
            me.hasFUV = 1 &#13;
<br/>
      elif words[0] == '*MESH_TVERT': &#13;
<br/>
         uv = mesh_uvVert() &#13;
<br/>
         uv.index = int(words[1]) &#13;
<br/>
         uv.u = float(words[2]) &#13;
<br/>
         uv.v = float(words[3]) &#13;
<br/>
         me.uvVerts.append(uv) &#13;
<br/>
      elif words[0] == '*MESH_NUMTVFACES': &#13;
<br/>
         me.uvFCount = int(words[1]) &#13;
<br/>
      elif words[0] == '*MESH_TFACE': &#13;
<br/>
         fUv = mesh_uvFace() &#13;
<br/>
         fUv.index = int(words[1]) &#13;
<br/>
         fUv.uv1 = int(words[2]) &#13;
<br/>
         fUv.uv2 = int(words[3]) &#13;
<br/>
         fUv.uv3 = int(words[4]) &#13;
<br/>
         me.uvFaces.append(fUv) &#13;
<br/>
      elif words[0] == '*MESH_NUMCVERTEX': &#13;
<br/>
         me.vcVCount = int(words[1]) &#13;
<br/>
         if me.uvVCount &gt; 0: &#13;
<br/>
            me.hasVC = 1 &#13;
<br/>
      elif words[0] == '*MESH_VERTCOL': &#13;
<br/>
         c = mesh_vcVert() &#13;
<br/>
         c.index = int(words[1]) &#13;
<br/>
         c.r = round(float(words[2])*256) &#13;
<br/>
         c.g = round(float(words[3])*256) &#13;
<br/>
         c.b = round(float(words[4])*256) &#13;
<br/>
         me.vcVerts.append(c) &#13;
<br/>
      elif words[0] == '*MESH_CFACE': &#13;
<br/>
         fc = mesh_vcFace() &#13;
<br/>
         fc.index = int(words[1]) &#13;
<br/>
         fc.c1 = int(words[2]) &#13;
<br/>
         fc.c2 = int(words[3]) &#13;
<br/>
         fc.c3 = int(words[4]) &#13;
<br/>
         me.vcFaces.append(fc) &#13;
<br/><br/>
      PBidx += 1.0 &#13;
<br/><br/>
   spawn_main(objects) &#13;
<br/><br/>
   Blender.Redraw() &#13;
<br/><br/>
def spawn_main(objects):&#13;
<br/><br/>
   PBidx = 0.0 &#13;
<br/>
   objCount = float(len(objects)) &#13;
<br/><br/>
   print 'Import Objects' &#13;
<br/>
   Blender.Window.DrawProgressBar(0.0, "Importing Objects...") &#13;
<br/><br/>
   for obj in objects: &#13;
<br/><br/>
      Blender.Window.DrawProgressBar(PBidx / objCount, "Importing Objects...") &#13;
<br/><br/>
      if obj.objType == 'Mesh': &#13;
<br/>
         spawn_mesh(obj) &#13;
<br/><br/>
      PBidx += 1.0 &#13;
<br/><br/><br/>
def spawn_mesh(obj):&#13;
<br/><br/>
   objMe = obj.obj&#13;
<br/>
   #normal_flag = 1&#13;
<br/><br/>
   row0 = obj.row0x, obj.row0y, obj.row0z&#13;
<br/>
   row1 = obj.row1x, obj.row1y, obj.row1z&#13;
<br/>
   row2 = obj.row2x, obj.row2y, obj.row2z&#13;
<br/>
   row3 = obj.row3x, obj.row3y, obj.row3z&#13;
<br/><br/>
   newMatrix = Blender.Mathutils.Matrix(row0, row1, row2, row3)&#13;
<br/>
   newMatrix.resize4x4()&#13;
<br/><br/>
   newObj = Blender.Object.New(obj.objType, obj.name)&#13;
<br/>
   newObj.setMatrix(newMatrix)&#13;
<br/>
   Blender.Scene.getCurrent().link(newObj) &#13;
<br/><br/><br/>
   newMesh = Blender.Mesh.New(obj.objName) &#13;
<br/>
   newMesh.getFromObject(newObj.name) &#13;
<br/><br/><br/>
   # Verts &#13;
<br/>
   newMesh.verts.extend(objMe.meVerts)&#13;
<br/><br/>
   # Faces &#13;
<br/>
   newMesh.faces.extend(objMe.meFaces)&#13;
<br/><br/>
   #VertCol &#13;
<br/>
   if guiTable['VC'] == 1 and objMe.hasVC == 1: &#13;
<br/>
      newMesh.vertexColors = 1 &#13;
<br/>
      for c in objMe.vcFaces: &#13;
<br/><br/>
         FCol0 = newMesh.faces[c.index].col[0] &#13;
<br/>
         FCol1 = newMesh.faces[c.index].col[1] &#13;
<br/>
         FCol2 = newMesh.faces[c.index].col[2] &#13;
<br/><br/>
         FCol0.r = int(objMe.vcVerts[c.c1].r) &#13;
<br/>
         FCol0.g = int(objMe.vcVerts[c.c1].g) &#13;
<br/>
         FCol0.b = int(objMe.vcVerts[c.c1].b) &#13;
<br/><br/>
         FCol1.r = int(objMe.vcVerts[c.c2].r) &#13;
<br/>
         FCol1.g = int(objMe.vcVerts[c.c2].g) &#13;
<br/>
         FCol1.b = int(objMe.vcVerts[c.c2].b) &#13;
<br/><br/>
         FCol2.r = int(objMe.vcVerts[c.c3].r) &#13;
<br/>
         FCol2.g = int(objMe.vcVerts[c.c3].g) &#13;
<br/>
         FCol2.b = int(objMe.vcVerts[c.c3].b) &#13;
<br/><br/>
   # UV &#13;
<br/>
   if guiTable['UV'] == 1 and objMe.hasFUV == 1: &#13;
<br/>
      newMesh.faceUV = 1 &#13;
<br/>
      for f in objMe.uvFaces: &#13;
<br/>
         uv1 = Blender.Mathutils.Vector(float(objMe.uvVerts[f.uv1].u), float(objMe.uvVerts[f.uv1].v)) &#13;
<br/>
         uv2 = Blender.Mathutils.Vector(float(objMe.uvVerts[f.uv2].u), float(objMe.uvVerts[f.uv2].v)) &#13;
<br/>
         uv3 = Blender.Mathutils.Vector(float(objMe.uvVerts[f.uv3].u), float(objMe.uvVerts[f.uv3].v)) &#13;
<br/>
         newMesh.faces[f.index].uv = [uv1, uv2, uv3] &#13;
<br/><br/>
   newMesh.transform((newObj.getMatrix('worldspace').invert()), 1) &#13;
<br/>
   newObj.link(newMesh) &#13;
<br/><br/>
   counts['verts'] += objMe.vCount &#13;
<br/>
   counts['tris'] += objMe.fCount &#13;
<br/>
   print 'Imported Mesh-Object: ', obj.name &#13;
<br/><br/><br/><br/>
def read_ui(filename): &#13;
<br/><br/>
   global guiTable, IMPORT_VC, IMPORT_UV &#13;
<br/>
   guiTable = {'VC': 1, 'UV': 1} &#13;
<br/><br/>
   for s in Window.GetScreenInfo(): &#13;
<br/>
      Window.QHandle(s['id']) &#13;
<br/><br/>
   IMPORT_VC = Draw.Create(guiTable['VC']) &#13;
<br/>
   IMPORT_UV = Draw.Create(guiTable['UV']) &#13;
<br/><br/>
   # Get USER Options &#13;
<br/>
   pup_block = [('Import Options'),('Vertex Color', IMPORT_VC, 'Import Vertex Colors if exist'),('UV', IMPORT_UV, 'Import UV if exist'),] &#13;
<br/><br/>
   if not Draw.PupBlock('Import...', pup_block): &#13;
<br/>
      return &#13;
<br/><br/>
   Window.WaitCursor(1)&#13;
<br/><br/>
   guiTable['VC'] = IMPORT_VC.val &#13;
<br/>
   guiTable['UV'] = IMPORT_UV.val &#13;
<br/><br/>
   read_main(filename) &#13;
<br/><br/>
   Window.WaitCursor(0) &#13;
<br/><br/><br/>
if __name__ == '__main__': &#13;
<br/>
   Window.FileSelector(read_ui, 'Import ASCII Scene', ('.ase'))</td>	</tr></table><span class="postbody"/><span class="gensmall"><br/><br/>Last edited by Goofos on Tue Aug 15, 2006 12:25 pm; edited 4 times in total</span></td>
			</tr>]]></body></post><post id="140320" date="Posted: Mon Apr 17, 2006 1:12 pm    Post subject: "><author>Bittoman</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Nice job, thanks Goofos!</span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="140355" date="Posted: Mon Apr 17, 2006 10:30 pm    Post subject: "><author>kat</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Not tried it yet but 'GG' on doing this one. Another step up the ladder for Blender!<br/>_________________<br/><a href="https://web.archive.org/web/20061012234650/http://www.doom3world.org/" target="_blank" class="postlink"><img src="https://web.archive.org/web/20061012234650im_/http://www.doom3world.org/site/img/d3w.gif" border="0"/>Co-Admin</a> - <a href="https://web.archive.org/web/20061012234650/http://www.quake3bits.com/" target="_blank" class="postlink">Modelling and modding tutorials and tips</a></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="143616" date="Posted: Fri May 19, 2006 8:04 pm    Post subject: "><author>kat</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Just tried this script for the 1st time and encountered the following error with Blender 2.41 when run as a script from the text window (Alt+P).&#13;
<br/></span><table width="90%" cellspacing="1" cellpadding="3" border="0" align="center"><tr><td><span class="genmed"><b>Code:</b></span></td>	</tr><tr><td class="code">IndentationError: unindent does not match any outer indentation level&#13;
<br/>
  File "goofosASE_import_17Ap", line 295&#13;
<br/>
    if obj.objType == 'Mesh':&#13;
<br/>
                             ^</td>	</tr></table><span class="postbody"><br/>_________________<br/><a href="https://web.archive.org/web/20061012234650/http://www.doom3world.org/" target="_blank" class="postlink"><img src="https://web.archive.org/web/20061012234650im_/http://www.doom3world.org/site/img/d3w.gif" border="0"/>Co-Admin</a> - <a href="https://web.archive.org/web/20061012234650/http://www.quake3bits.com/" target="_blank" class="postlink">Modelling and modding tutorials and tips</a></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="143762" date="Posted: Sun May 21, 2006 3:58 pm    Post subject: "><author>Goofos</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Should work now. Seems my OS is a bit more tollerant with format errors :&gt;</span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="144077" date="Posted: Fri May 26, 2006 10:43 am    Post subject: "><author>OrbWeaver</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">I haven't tried this but it sounds great. Until now ASE has been almost universally considered an "export-only" format.</span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="144120" date="Posted: Fri May 26, 2006 5:33 pm    Post subject: New error"><author>kat</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">New error when doing Ctrl+P to run the script</span><table width="90%" cellspacing="1" cellpadding="3" border="0" align="center"><tr><td><span class="genmed"><b>Code:</b></span></td>	</tr><tr><td class="code">SyntaxError: invalid token&#13;
<br/>
  File "goofosASE_import_26Ma", line 382&#13;
<br/>
    pup_block = [\&#13;
<br/>
                  ^</td>	</tr></table><span class="postbody"><br/>_________________<br/><a href="https://web.archive.org/web/20061012234650/http://www.doom3world.org/" target="_blank" class="postlink"><img src="https://web.archive.org/web/20061012234650im_/http://www.doom3world.org/site/img/d3w.gif" border="0"/>Co-Admin</a> - <a href="https://web.archive.org/web/20061012234650/http://www.quake3bits.com/" target="_blank" class="postlink">Modelling and modding tutorials and tips</a></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="144546" date="Posted: Wed May 31, 2006 3:07 pm    Post subject: "><author>Goofos</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">There was a space at end of the line if you copy/paste the script from the forum. I have put the array in one line, should work now.</span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="144572" date="Posted: Wed May 31, 2006 6:19 pm    Post subject: "><author>kat</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">DUDE!! sorted. Both vertex and UVW import work fine and dandy.<br/>_________________<br/><a href="https://web.archive.org/web/20061012234650/http://www.doom3world.org/" target="_blank" class="postlink"><img src="https://web.archive.org/web/20061012234650im_/http://www.doom3world.org/site/img/d3w.gif" border="0"/>Co-Admin</a> - <a href="https://web.archive.org/web/20061012234650/http://www.quake3bits.com/" target="_blank" class="postlink">Modelling and modding tutorials and tips</a></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="153676" date="Posted: Tue Aug 15, 2006 12:07 pm    Post subject: "><author>Goofos</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Fixed a problem with the matrices, dont know why this suddenly happened.&#13;
<br/><br/>
[edit]&#13;
<br/>
I quickly updated it again (to v0.12) <img src="https://web.archive.org/web/20061012234650im_/http://doom3world.org/phpbb2/images/smiles/icon_biggrin.gif" alt="Very Happy" border="0"/> to use some improvements of 2.42 (which doesn't worked with 2.40). Now it should import (big) meshes much faster.</span><span class="gensmall"><br/><br/>Last edited by Goofos on Tue Aug 15, 2006 12:34 pm; edited 1 time in total</span></td>
			</tr>]]></body></post><post id="154876" date="Posted: Fri Aug 25, 2006 2:29 am    Post subject: "><author>Tweaker</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Excellent, I was having problems importing with 2.42a, but this seems to have fixed it.  Thanks.   <img src="https://web.archive.org/web/20061012234650im_/http://doom3world.org/phpbb2/images/smiles/icon_biggrin.gif" alt="Very Happy" border="0"/></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="140291" date="Posted: Mon Apr 17, 2006 2:00 am    Post subject: ASE Importer"><author>Goofos</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">I made a first small script to import ASE meshes. Its not perfect and may a bit lame but should import correct meshes (from 3DS). Materials are currently not supported but UV coords and VertexColors. &#13;
<br/>
Note: Meshes from 3DS are very big in Blender <img src="https://web.archive.org/web/20061012234702im_/http://doom3world.org/phpbb2/images/smiles/icon_biggrin.gif" alt="Very Happy" border="0"/><br/><br/></span><table width="90%" cellspacing="1" cellpadding="3" border="0" align="center"><tr><td><span class="genmed"><b>Code:</b></span></td>	</tr><tr><td class="code">#!BPY&#13;
<br/><br/>
""" &#13;
<br/>
Name: 'ASCII Scene (.ase) v0.12'&#13;
<br/>
Blender: 242&#13;
<br/>
Group: 'Import' &#13;
<br/>
Tooltip: 'ASCII Scene import (*.ase)' &#13;
<br/>
""" &#13;
<br/>
__author__ = "Goofos"&#13;
<br/>
__version__ = "0.12"&#13;
<br/><br/>
# goofos at epruegel.de &#13;
<br/>
# &#13;
<br/>
# ***** BEGIN GPL LICENSE BLOCK ***** &#13;
<br/>
#&#13;
<br/>
# This program is free software; you can redistribute it and/or&#13;
<br/>
# modify it under the terms of the GNU General Public License &#13;
<br/>
# as published by the Free Software Foundation; either version 2&#13;
<br/>
# of the License, or (at your option) any later version. &#13;
<br/>
# &#13;
<br/>
# This program is distributed in the hope that it will be useful, &#13;
<br/>
# but WITHOUT ANY WARRANTY; without even the implied warranty of &#13;
<br/>
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the &#13;
<br/>
# GNU General Public License for more details. &#13;
<br/>
# &#13;
<br/>
# You should have received a copy of the GNU General Public License &#13;
<br/>
# along with this program; if not, write to the Free Software Foundation, &#13;
<br/>
# Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. &#13;
<br/>
# &#13;
<br/>
# ***** END GPL LICENCE BLOCK ***** &#13;
<br/><br/>
import string, time, sys as osSys &#13;
<br/>
import Blender &#13;
<br/>
from Blender import Draw, Mesh, Window, Object, Scene &#13;
<br/>
#import meshtools &#13;
<br/><br/><br/>
def read_main(filename): &#13;
<br/><br/>
   global counts &#13;
<br/>
   counts = {'verts': 0, 'tris': 0} &#13;
<br/><br/>
   start = time.clock() &#13;
<br/>
   file = open(filename, "r") &#13;
<br/><br/>
   print_boxed("----------------start-----------------")&#13;
<br/>
   print 'Import Patch: ', filename &#13;
<br/><br/>
   editmode = Window.EditMode()    # are we in edit mode?  If so ... &#13;
<br/>
   if editmode: Window.EditMode(0) # leave edit mode before getting the mesh&#13;
<br/><br/>
   lines= file.readlines() &#13;
<br/>
   read_file(file, lines) &#13;
<br/><br/>
   Blender.Window.DrawProgressBar(1.0, '')  # clear progressbar&#13;
<br/>
   file.close() &#13;
<br/>
   print "----------------end-----------------" &#13;
<br/>
   end = time.clock() &#13;
<br/>
   seconds = " in %.2f %s" % (end-start, "seconds") &#13;
<br/>
   totals = "Verts: %i Tris: %i " % (counts['verts'], counts['tris']) &#13;
<br/>
   print_boxed(totals) &#13;
<br/>
   message = "Successfully imported " + Blender.sys.basename(filename) + seconds &#13;
<br/>
   #meshtools.print_boxed(message) &#13;
<br/>
   print_boxed(message) &#13;
<br/><br/><br/>
def print_boxed(text): #Copy/Paste from meshtools, only to remove the beep :) &#13;
<br/>
   lines = text.splitlines() &#13;
<br/>
   maxlinelen = max(map(len, lines)) &#13;
<br/>
   if osSys.platform[:3] == "win": &#13;
<br/>
      print chr(218)+chr(196) + chr(196)*maxlinelen + chr(196)+chr(191) &#13;
<br/>
      for line in lines: &#13;
<br/>
         print chr(179) + ' ' + line.ljust(maxlinelen) + ' ' + chr(179) &#13;
<br/>
      print chr(192)+chr(196) + chr(196)*maxlinelen + chr(196)+chr(217) &#13;
<br/>
   else: &#13;
<br/>
      print '+-' + '-'*maxlinelen + '-+' &#13;
<br/>
      for line in lines: print '| ' + line.ljust(maxlinelen) + ' |' &#13;
<br/>
      print '+-' + '-'*maxlinelen + '-+' &#13;
<br/>
   #print '\a\r', # beep when done &#13;
<br/><br/><br/>
class ase_obj: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.name = 'Name' &#13;
<br/>
      self.objType = None &#13;
<br/>
      self.row0x = None &#13;
<br/>
      self.row0y = None &#13;
<br/>
      self.row0z = None &#13;
<br/>
      self.row1x = None &#13;
<br/>
      self.row1y = None &#13;
<br/>
      self.row1z = None &#13;
<br/>
      self.row2x = None &#13;
<br/>
      self.row2y = None &#13;
<br/>
      self.row2z = None &#13;
<br/>
      self.row3x = None &#13;
<br/>
      self.row3y = None &#13;
<br/>
      self.row3z = None &#13;
<br/>
      self.parent = None &#13;
<br/>
      self.obj = None &#13;
<br/>
      self.objName = 'Name' &#13;
<br/><br/>
class ase_mesh: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.name = '' &#13;
<br/>
      self.vCount = 0 &#13;
<br/>
      self.fCount = 0 &#13;
<br/>
      self.uvVCount = 0 &#13;
<br/>
      self.uvFCount = 0 &#13;
<br/>
      self.vcVCount = 0 &#13;
<br/>
      self.vcFCount = 0 &#13;
<br/>
      self.meVerts = [] &#13;
<br/>
      self.meFaces = [] &#13;
<br/>
      self.uvVerts = [] &#13;
<br/>
      self.uvFaces = [] &#13;
<br/>
      self.vcVerts = [] &#13;
<br/>
      self.vcFaces = [] &#13;
<br/>
      self.hasFUV = 0 &#13;
<br/>
      self.hasVC = 0 &#13;
<br/><br/>
class mesh_face: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.v1 = 0 &#13;
<br/>
      self.v2 = 0 &#13;
<br/>
      self.v3 = 0 &#13;
<br/>
      self.mat = None &#13;
<br/>
       &#13;
<br/>
class mesh_vert: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.x = 0.0 &#13;
<br/>
      self.y = 0.0 &#13;
<br/>
      self.z = 0.0 &#13;
<br/><br/>
class mesh_uvVert: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.index = 0 &#13;
<br/>
      self.u = 0.0 &#13;
<br/>
      self.v = 0.0 &#13;
<br/>
      self.vec = Blender.Mathutils.Vector(self.u, self.v) &#13;
<br/><br/>
class mesh_uvFace: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.index = 0 &#13;
<br/>
      self.uv1 = 0 &#13;
<br/>
      self.uv2 = 0 &#13;
<br/>
      self.uv3 = 0 &#13;
<br/>
       &#13;
<br/>
class mesh_vcVert: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.index = 0 &#13;
<br/>
      self.r = 0 &#13;
<br/>
      self.g = 0 &#13;
<br/>
      self.b = 0 &#13;
<br/>
      self.a = 255 &#13;
<br/>
       &#13;
<br/>
class mesh_vcFace: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.index = 0 &#13;
<br/>
      self.c1 = 0 &#13;
<br/>
      self.c2 = 0 &#13;
<br/>
      self.c3 = 0 &#13;
<br/><br/><br/>
def read_file(file, lines): &#13;
<br/><br/>
   objects = [] &#13;
<br/>
   objIdx = 0 &#13;
<br/>
   objCheck = -1 #needed to skip helper objects &#13;
<br/>
   PBidx = 0.0 &#13;
<br/>
   lineCount = float(len(lines)) &#13;
<br/><br/>
   print 'Read file' &#13;
<br/>
   Blender.Window.DrawProgressBar(0.0, "Read File...") &#13;
<br/><br/>
   for line in lines: &#13;
<br/>
      words = string.split(line) &#13;
<br/><br/>
      if (PBidx % 10000) == 0.0: &#13;
<br/>
                   Blender.Window.DrawProgressBar(PBidx / lineCount, "Read File...") &#13;
<br/><br/>
      if not words: &#13;
<br/>
         continue &#13;
<br/>
      elif words[0] == '*GEOMOBJECT': &#13;
<br/>
         objCheck = 0 &#13;
<br/>
         newObj = ase_obj() &#13;
<br/>
         objects.append(newObj) &#13;
<br/>
         obj = objects[objIdx] &#13;
<br/>
         objIdx += 1 &#13;
<br/>
      elif words[0] == '*NODE_NAME' and objCheck != -1: &#13;
<br/>
         if objCheck == 0: &#13;
<br/>
            obj.name = words[1] &#13;
<br/>
            objCheck = 1 &#13;
<br/>
         elif objCheck == 1: &#13;
<br/>
            obj.objName = words[1] &#13;
<br/>
      elif words[0] == '*TM_ROW0' and objCheck != -1: &#13;
<br/>
         obj.row0x = float(words[1]) &#13;
<br/>
         obj.row0y = float(words[2]) &#13;
<br/>
         obj.row0z = float(words[3]) &#13;
<br/>
      elif words[0] == '*TM_ROW1' and objCheck != -1: &#13;
<br/>
         obj.row1x = float(words[1]) &#13;
<br/>
         obj.row1y = float(words[2]) &#13;
<br/>
         obj.row1z = float(words[3]) &#13;
<br/>
      elif words[0] == '*TM_ROW2' and objCheck != -1: &#13;
<br/>
         obj.row2x = float(words[1]) &#13;
<br/>
         obj.row2y = float(words[2]) &#13;
<br/>
         obj.row2z = float(words[3]) &#13;
<br/>
      elif words[0] == '*TM_ROW3' and objCheck != -1: &#13;
<br/>
         obj.row3x = float(words[1]) &#13;
<br/>
         obj.row3y = float(words[2]) &#13;
<br/>
         obj.row3z = float(words[3]) &#13;
<br/>
         objCheck = -1 &#13;
<br/>
      elif words[0] == '*MESH': &#13;
<br/>
         obj.objType = 'Mesh' &#13;
<br/>
         obj.obj = ase_mesh() &#13;
<br/>
         me = obj.obj &#13;
<br/>
      elif words[0] == '*MESH_NUMVERTEX': &#13;
<br/>
         me.vCount = int(words[1]) &#13;
<br/>
      elif words[0] == '*MESH_NUMFACES': &#13;
<br/>
         me.fCount = int(words[1]) &#13;
<br/>
      elif words[0] == '*MESH_VERTEX': &#13;
<br/>
         #v = mesh_vert() &#13;
<br/>
         v = [float(words[2]),float(words[3]),float(words[4])]&#13;
<br/>
         #v.x = float(words[2])&#13;
<br/>
         #v.y = float(words[3])&#13;
<br/>
         #v.z = float(words[4])&#13;
<br/>
         me.meVerts.append(v) &#13;
<br/>
      elif words[0] == '*MESH_FACE':&#13;
<br/>
         #f = mesh_face()&#13;
<br/>
         f = [int(words[3]),int(words[5]),int(words[7])]&#13;
<br/>
         #f.v1 = int(words[3])&#13;
<br/>
         #f.v2 = int(words[5])&#13;
<br/>
         #f.v3 = int(words[7])&#13;
<br/>
         me.meFaces.append(f) &#13;
<br/>
      elif words[0] == '*MESH_NUMTVERTEX': &#13;
<br/>
         me.uvVCount = int(words[1]) &#13;
<br/>
         if me.uvVCount &gt; 0: &#13;
<br/>
            me.hasFUV = 1 &#13;
<br/>
      elif words[0] == '*MESH_TVERT': &#13;
<br/>
         uv = mesh_uvVert() &#13;
<br/>
         uv.index = int(words[1]) &#13;
<br/>
         uv.u = float(words[2]) &#13;
<br/>
         uv.v = float(words[3]) &#13;
<br/>
         me.uvVerts.append(uv) &#13;
<br/>
      elif words[0] == '*MESH_NUMTVFACES': &#13;
<br/>
         me.uvFCount = int(words[1]) &#13;
<br/>
      elif words[0] == '*MESH_TFACE': &#13;
<br/>
         fUv = mesh_uvFace() &#13;
<br/>
         fUv.index = int(words[1]) &#13;
<br/>
         fUv.uv1 = int(words[2]) &#13;
<br/>
         fUv.uv2 = int(words[3]) &#13;
<br/>
         fUv.uv3 = int(words[4]) &#13;
<br/>
         me.uvFaces.append(fUv) &#13;
<br/>
      elif words[0] == '*MESH_NUMCVERTEX': &#13;
<br/>
         me.vcVCount = int(words[1]) &#13;
<br/>
         if me.uvVCount &gt; 0: &#13;
<br/>
            me.hasVC = 1 &#13;
<br/>
      elif words[0] == '*MESH_VERTCOL': &#13;
<br/>
         c = mesh_vcVert() &#13;
<br/>
         c.index = int(words[1]) &#13;
<br/>
         c.r = round(float(words[2])*256) &#13;
<br/>
         c.g = round(float(words[3])*256) &#13;
<br/>
         c.b = round(float(words[4])*256) &#13;
<br/>
         me.vcVerts.append(c) &#13;
<br/>
      elif words[0] == '*MESH_CFACE': &#13;
<br/>
         fc = mesh_vcFace() &#13;
<br/>
         fc.index = int(words[1]) &#13;
<br/>
         fc.c1 = int(words[2]) &#13;
<br/>
         fc.c2 = int(words[3]) &#13;
<br/>
         fc.c3 = int(words[4]) &#13;
<br/>
         me.vcFaces.append(fc) &#13;
<br/><br/>
      PBidx += 1.0 &#13;
<br/><br/>
   spawn_main(objects) &#13;
<br/><br/>
   Blender.Redraw() &#13;
<br/><br/>
def spawn_main(objects):&#13;
<br/><br/>
   PBidx = 0.0 &#13;
<br/>
   objCount = float(len(objects)) &#13;
<br/><br/>
   print 'Import Objects' &#13;
<br/>
   Blender.Window.DrawProgressBar(0.0, "Importing Objects...") &#13;
<br/><br/>
   for obj in objects: &#13;
<br/><br/>
      Blender.Window.DrawProgressBar(PBidx / objCount, "Importing Objects...") &#13;
<br/><br/>
      if obj.objType == 'Mesh': &#13;
<br/>
         spawn_mesh(obj) &#13;
<br/><br/>
      PBidx += 1.0 &#13;
<br/><br/><br/>
def spawn_mesh(obj):&#13;
<br/><br/>
   objMe = obj.obj&#13;
<br/>
   #normal_flag = 1&#13;
<br/><br/>
   row0 = obj.row0x, obj.row0y, obj.row0z&#13;
<br/>
   row1 = obj.row1x, obj.row1y, obj.row1z&#13;
<br/>
   row2 = obj.row2x, obj.row2y, obj.row2z&#13;
<br/>
   row3 = obj.row3x, obj.row3y, obj.row3z&#13;
<br/><br/>
   newMatrix = Blender.Mathutils.Matrix(row0, row1, row2, row3)&#13;
<br/>
   newMatrix.resize4x4()&#13;
<br/><br/>
   newObj = Blender.Object.New(obj.objType, obj.name)&#13;
<br/>
   newObj.setMatrix(newMatrix)&#13;
<br/>
   Blender.Scene.getCurrent().link(newObj) &#13;
<br/><br/><br/>
   newMesh = Blender.Mesh.New(obj.objName) &#13;
<br/>
   newMesh.getFromObject(newObj.name) &#13;
<br/><br/><br/>
   # Verts &#13;
<br/>
   newMesh.verts.extend(objMe.meVerts)&#13;
<br/><br/>
   # Faces &#13;
<br/>
   newMesh.faces.extend(objMe.meFaces)&#13;
<br/><br/>
   #VertCol &#13;
<br/>
   if guiTable['VC'] == 1 and objMe.hasVC == 1: &#13;
<br/>
      newMesh.vertexColors = 1 &#13;
<br/>
      for c in objMe.vcFaces: &#13;
<br/><br/>
         FCol0 = newMesh.faces[c.index].col[0] &#13;
<br/>
         FCol1 = newMesh.faces[c.index].col[1] &#13;
<br/>
         FCol2 = newMesh.faces[c.index].col[2] &#13;
<br/><br/>
         FCol0.r = int(objMe.vcVerts[c.c1].r) &#13;
<br/>
         FCol0.g = int(objMe.vcVerts[c.c1].g) &#13;
<br/>
         FCol0.b = int(objMe.vcVerts[c.c1].b) &#13;
<br/><br/>
         FCol1.r = int(objMe.vcVerts[c.c2].r) &#13;
<br/>
         FCol1.g = int(objMe.vcVerts[c.c2].g) &#13;
<br/>
         FCol1.b = int(objMe.vcVerts[c.c2].b) &#13;
<br/><br/>
         FCol2.r = int(objMe.vcVerts[c.c3].r) &#13;
<br/>
         FCol2.g = int(objMe.vcVerts[c.c3].g) &#13;
<br/>
         FCol2.b = int(objMe.vcVerts[c.c3].b) &#13;
<br/><br/>
   # UV &#13;
<br/>
   if guiTable['UV'] == 1 and objMe.hasFUV == 1: &#13;
<br/>
      newMesh.faceUV = 1 &#13;
<br/>
      for f in objMe.uvFaces: &#13;
<br/>
         uv1 = Blender.Mathutils.Vector(float(objMe.uvVerts[f.uv1].u), float(objMe.uvVerts[f.uv1].v)) &#13;
<br/>
         uv2 = Blender.Mathutils.Vector(float(objMe.uvVerts[f.uv2].u), float(objMe.uvVerts[f.uv2].v)) &#13;
<br/>
         uv3 = Blender.Mathutils.Vector(float(objMe.uvVerts[f.uv3].u), float(objMe.uvVerts[f.uv3].v)) &#13;
<br/>
         newMesh.faces[f.index].uv = [uv1, uv2, uv3] &#13;
<br/><br/>
   newMesh.transform((newObj.getMatrix('worldspace').invert()), 1) &#13;
<br/>
   newObj.link(newMesh) &#13;
<br/><br/>
   counts['verts'] += objMe.vCount &#13;
<br/>
   counts['tris'] += objMe.fCount &#13;
<br/>
   print 'Imported Mesh-Object: ', obj.name &#13;
<br/><br/><br/><br/>
def read_ui(filename): &#13;
<br/><br/>
   global guiTable, IMPORT_VC, IMPORT_UV &#13;
<br/>
   guiTable = {'VC': 1, 'UV': 1} &#13;
<br/><br/>
   for s in Window.GetScreenInfo(): &#13;
<br/>
      Window.QHandle(s['id']) &#13;
<br/><br/>
   IMPORT_VC = Draw.Create(guiTable['VC']) &#13;
<br/>
   IMPORT_UV = Draw.Create(guiTable['UV']) &#13;
<br/><br/>
   # Get USER Options &#13;
<br/>
   pup_block = [('Import Options'),('Vertex Color', IMPORT_VC, 'Import Vertex Colors if exist'),('UV', IMPORT_UV, 'Import UV if exist'),] &#13;
<br/><br/>
   if not Draw.PupBlock('Import...', pup_block): &#13;
<br/>
      return &#13;
<br/><br/>
   Window.WaitCursor(1)&#13;
<br/><br/>
   guiTable['VC'] = IMPORT_VC.val &#13;
<br/>
   guiTable['UV'] = IMPORT_UV.val &#13;
<br/><br/>
   read_main(filename) &#13;
<br/><br/>
   Window.WaitCursor(0) &#13;
<br/><br/><br/>
if __name__ == '__main__': &#13;
<br/>
   Window.FileSelector(read_ui, 'Import ASCII Scene', ('.ase'))</td>	</tr></table><span class="postbody"/><span class="gensmall"><br/><br/>Last edited by Goofos on Tue Aug 15, 2006 12:25 pm; edited 4 times in total</span></td>
			</tr>]]></body></post><post id="140320" date="Posted: Mon Apr 17, 2006 1:12 pm    Post subject: "><author>Bittoman</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Nice job, thanks Goofos!</span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="140355" date="Posted: Mon Apr 17, 2006 10:30 pm    Post subject: "><author>kat</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Not tried it yet but 'GG' on doing this one. Another step up the ladder for Blender!<br/>_________________<br/><a href="https://web.archive.org/web/20061012234702/http://www.doom3world.org/" target="_blank" class="postlink"><img src="https://web.archive.org/web/20061012234702im_/http://www.doom3world.org/site/img/d3w.gif" border="0"/>Co-Admin</a> - <a href="https://web.archive.org/web/20061012234702/http://www.quake3bits.com/" target="_blank" class="postlink">Modelling and modding tutorials and tips</a></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="143616" date="Posted: Fri May 19, 2006 8:04 pm    Post subject: "><author>kat</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Just tried this script for the 1st time and encountered the following error with Blender 2.41 when run as a script from the text window (Alt+P).&#13;
<br/></span><table width="90%" cellspacing="1" cellpadding="3" border="0" align="center"><tr><td><span class="genmed"><b>Code:</b></span></td>	</tr><tr><td class="code">IndentationError: unindent does not match any outer indentation level&#13;
<br/>
  File "goofosASE_import_17Ap", line 295&#13;
<br/>
    if obj.objType == 'Mesh':&#13;
<br/>
                             ^</td>	</tr></table><span class="postbody"><br/>_________________<br/><a href="https://web.archive.org/web/20061012234702/http://www.doom3world.org/" target="_blank" class="postlink"><img src="https://web.archive.org/web/20061012234702im_/http://www.doom3world.org/site/img/d3w.gif" border="0"/>Co-Admin</a> - <a href="https://web.archive.org/web/20061012234702/http://www.quake3bits.com/" target="_blank" class="postlink">Modelling and modding tutorials and tips</a></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="143762" date="Posted: Sun May 21, 2006 3:58 pm    Post subject: "><author>Goofos</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Should work now. Seems my OS is a bit more tollerant with format errors :&gt;</span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="144077" date="Posted: Fri May 26, 2006 10:43 am    Post subject: "><author>OrbWeaver</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">I haven't tried this but it sounds great. Until now ASE has been almost universally considered an "export-only" format.</span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="144120" date="Posted: Fri May 26, 2006 5:33 pm    Post subject: New error"><author>kat</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">New error when doing Ctrl+P to run the script</span><table width="90%" cellspacing="1" cellpadding="3" border="0" align="center"><tr><td><span class="genmed"><b>Code:</b></span></td>	</tr><tr><td class="code">SyntaxError: invalid token&#13;
<br/>
  File "goofosASE_import_26Ma", line 382&#13;
<br/>
    pup_block = [\&#13;
<br/>
                  ^</td>	</tr></table><span class="postbody"><br/>_________________<br/><a href="https://web.archive.org/web/20061012234702/http://www.doom3world.org/" target="_blank" class="postlink"><img src="https://web.archive.org/web/20061012234702im_/http://www.doom3world.org/site/img/d3w.gif" border="0"/>Co-Admin</a> - <a href="https://web.archive.org/web/20061012234702/http://www.quake3bits.com/" target="_blank" class="postlink">Modelling and modding tutorials and tips</a></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="144546" date="Posted: Wed May 31, 2006 3:07 pm    Post subject: "><author>Goofos</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">There was a space at end of the line if you copy/paste the script from the forum. I have put the array in one line, should work now.</span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="144572" date="Posted: Wed May 31, 2006 6:19 pm    Post subject: "><author>kat</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">DUDE!! sorted. Both vertex and UVW import work fine and dandy.<br/>_________________<br/><a href="https://web.archive.org/web/20061012234702/http://www.doom3world.org/" target="_blank" class="postlink"><img src="https://web.archive.org/web/20061012234702im_/http://www.doom3world.org/site/img/d3w.gif" border="0"/>Co-Admin</a> - <a href="https://web.archive.org/web/20061012234702/http://www.quake3bits.com/" target="_blank" class="postlink">Modelling and modding tutorials and tips</a></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="153676" date="Posted: Tue Aug 15, 2006 12:07 pm    Post subject: "><author>Goofos</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Fixed a problem with the matrices, dont know why this suddenly happened.&#13;
<br/><br/>
[edit]&#13;
<br/>
I quickly updated it again (to v0.12) <img src="https://web.archive.org/web/20061012234702im_/http://doom3world.org/phpbb2/images/smiles/icon_biggrin.gif" alt="Very Happy" border="0"/> to use some improvements of 2.42 (which doesn't worked with 2.40). Now it should import (big) meshes much faster.</span><span class="gensmall"><br/><br/>Last edited by Goofos on Tue Aug 15, 2006 12:34 pm; edited 1 time in total</span></td>
			</tr>]]></body></post><post id="154876" date="Posted: Fri Aug 25, 2006 2:29 am    Post subject: "><author>Tweaker</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Excellent, I was having problems importing with 2.42a, but this seems to have fixed it.  Thanks.   <img src="https://web.archive.org/web/20061012234702im_/http://doom3world.org/phpbb2/images/smiles/icon_biggrin.gif" alt="Very Happy" border="0"/></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="140291" date="Posted: Mon Apr 17, 2006 2:00 am    Post subject: ASE Importer"><author>Goofos</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">I made a first small script to import ASE meshes. Its not perfect and may a bit lame but should import correct meshes (from 3DS). Materials are currently not supported but UV coords and VertexColors. &#13;
<br/>
Note: Meshes from 3DS are very big in Blender <img src="https://web.archive.org/web/20061012234322im_/http://doom3world.org/phpbb2/images/smiles/icon_biggrin.gif" alt="Very Happy" border="0"/><br/><br/></span><table width="90%" cellspacing="1" cellpadding="3" border="0" align="center"><tr><td><span class="genmed"><b>Code:</b></span></td>	</tr><tr><td class="code">#!BPY&#13;
<br/><br/>
""" &#13;
<br/>
Name: 'ASCII Scene (.ase) v0.12'&#13;
<br/>
Blender: 242&#13;
<br/>
Group: 'Import' &#13;
<br/>
Tooltip: 'ASCII Scene import (*.ase)' &#13;
<br/>
""" &#13;
<br/>
__author__ = "Goofos"&#13;
<br/>
__version__ = "0.12"&#13;
<br/><br/>
# goofos at epruegel.de &#13;
<br/>
# &#13;
<br/>
# ***** BEGIN GPL LICENSE BLOCK ***** &#13;
<br/>
#&#13;
<br/>
# This program is free software; you can redistribute it and/or&#13;
<br/>
# modify it under the terms of the GNU General Public License &#13;
<br/>
# as published by the Free Software Foundation; either version 2&#13;
<br/>
# of the License, or (at your option) any later version. &#13;
<br/>
# &#13;
<br/>
# This program is distributed in the hope that it will be useful, &#13;
<br/>
# but WITHOUT ANY WARRANTY; without even the implied warranty of &#13;
<br/>
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the &#13;
<br/>
# GNU General Public License for more details. &#13;
<br/>
# &#13;
<br/>
# You should have received a copy of the GNU General Public License &#13;
<br/>
# along with this program; if not, write to the Free Software Foundation, &#13;
<br/>
# Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. &#13;
<br/>
# &#13;
<br/>
# ***** END GPL LICENCE BLOCK ***** &#13;
<br/><br/>
import string, time, sys as osSys &#13;
<br/>
import Blender &#13;
<br/>
from Blender import Draw, Mesh, Window, Object, Scene &#13;
<br/>
#import meshtools &#13;
<br/><br/><br/>
def read_main(filename): &#13;
<br/><br/>
   global counts &#13;
<br/>
   counts = {'verts': 0, 'tris': 0} &#13;
<br/><br/>
   start = time.clock() &#13;
<br/>
   file = open(filename, "r") &#13;
<br/><br/>
   print_boxed("----------------start-----------------")&#13;
<br/>
   print 'Import Patch: ', filename &#13;
<br/><br/>
   editmode = Window.EditMode()    # are we in edit mode?  If so ... &#13;
<br/>
   if editmode: Window.EditMode(0) # leave edit mode before getting the mesh&#13;
<br/><br/>
   lines= file.readlines() &#13;
<br/>
   read_file(file, lines) &#13;
<br/><br/>
   Blender.Window.DrawProgressBar(1.0, '')  # clear progressbar&#13;
<br/>
   file.close() &#13;
<br/>
   print "----------------end-----------------" &#13;
<br/>
   end = time.clock() &#13;
<br/>
   seconds = " in %.2f %s" % (end-start, "seconds") &#13;
<br/>
   totals = "Verts: %i Tris: %i " % (counts['verts'], counts['tris']) &#13;
<br/>
   print_boxed(totals) &#13;
<br/>
   message = "Successfully imported " + Blender.sys.basename(filename) + seconds &#13;
<br/>
   #meshtools.print_boxed(message) &#13;
<br/>
   print_boxed(message) &#13;
<br/><br/><br/>
def print_boxed(text): #Copy/Paste from meshtools, only to remove the beep :) &#13;
<br/>
   lines = text.splitlines() &#13;
<br/>
   maxlinelen = max(map(len, lines)) &#13;
<br/>
   if osSys.platform[:3] == "win": &#13;
<br/>
      print chr(218)+chr(196) + chr(196)*maxlinelen + chr(196)+chr(191) &#13;
<br/>
      for line in lines: &#13;
<br/>
         print chr(179) + ' ' + line.ljust(maxlinelen) + ' ' + chr(179) &#13;
<br/>
      print chr(192)+chr(196) + chr(196)*maxlinelen + chr(196)+chr(217) &#13;
<br/>
   else: &#13;
<br/>
      print '+-' + '-'*maxlinelen + '-+' &#13;
<br/>
      for line in lines: print '| ' + line.ljust(maxlinelen) + ' |' &#13;
<br/>
      print '+-' + '-'*maxlinelen + '-+' &#13;
<br/>
   #print '\a\r', # beep when done &#13;
<br/><br/><br/>
class ase_obj: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.name = 'Name' &#13;
<br/>
      self.objType = None &#13;
<br/>
      self.row0x = None &#13;
<br/>
      self.row0y = None &#13;
<br/>
      self.row0z = None &#13;
<br/>
      self.row1x = None &#13;
<br/>
      self.row1y = None &#13;
<br/>
      self.row1z = None &#13;
<br/>
      self.row2x = None &#13;
<br/>
      self.row2y = None &#13;
<br/>
      self.row2z = None &#13;
<br/>
      self.row3x = None &#13;
<br/>
      self.row3y = None &#13;
<br/>
      self.row3z = None &#13;
<br/>
      self.parent = None &#13;
<br/>
      self.obj = None &#13;
<br/>
      self.objName = 'Name' &#13;
<br/><br/>
class ase_mesh: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.name = '' &#13;
<br/>
      self.vCount = 0 &#13;
<br/>
      self.fCount = 0 &#13;
<br/>
      self.uvVCount = 0 &#13;
<br/>
      self.uvFCount = 0 &#13;
<br/>
      self.vcVCount = 0 &#13;
<br/>
      self.vcFCount = 0 &#13;
<br/>
      self.meVerts = [] &#13;
<br/>
      self.meFaces = [] &#13;
<br/>
      self.uvVerts = [] &#13;
<br/>
      self.uvFaces = [] &#13;
<br/>
      self.vcVerts = [] &#13;
<br/>
      self.vcFaces = [] &#13;
<br/>
      self.hasFUV = 0 &#13;
<br/>
      self.hasVC = 0 &#13;
<br/><br/>
class mesh_face: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.v1 = 0 &#13;
<br/>
      self.v2 = 0 &#13;
<br/>
      self.v3 = 0 &#13;
<br/>
      self.mat = None &#13;
<br/>
       &#13;
<br/>
class mesh_vert: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.x = 0.0 &#13;
<br/>
      self.y = 0.0 &#13;
<br/>
      self.z = 0.0 &#13;
<br/><br/>
class mesh_uvVert: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.index = 0 &#13;
<br/>
      self.u = 0.0 &#13;
<br/>
      self.v = 0.0 &#13;
<br/>
      self.vec = Blender.Mathutils.Vector(self.u, self.v) &#13;
<br/><br/>
class mesh_uvFace: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.index = 0 &#13;
<br/>
      self.uv1 = 0 &#13;
<br/>
      self.uv2 = 0 &#13;
<br/>
      self.uv3 = 0 &#13;
<br/>
       &#13;
<br/>
class mesh_vcVert: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.index = 0 &#13;
<br/>
      self.r = 0 &#13;
<br/>
      self.g = 0 &#13;
<br/>
      self.b = 0 &#13;
<br/>
      self.a = 255 &#13;
<br/>
       &#13;
<br/>
class mesh_vcFace: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.index = 0 &#13;
<br/>
      self.c1 = 0 &#13;
<br/>
      self.c2 = 0 &#13;
<br/>
      self.c3 = 0 &#13;
<br/><br/><br/>
def read_file(file, lines): &#13;
<br/><br/>
   objects = [] &#13;
<br/>
   objIdx = 0 &#13;
<br/>
   objCheck = -1 #needed to skip helper objects &#13;
<br/>
   PBidx = 0.0 &#13;
<br/>
   lineCount = float(len(lines)) &#13;
<br/><br/>
   print 'Read file' &#13;
<br/>
   Blender.Window.DrawProgressBar(0.0, "Read File...") &#13;
<br/><br/>
   for line in lines: &#13;
<br/>
      words = string.split(line) &#13;
<br/><br/>
      if (PBidx % 10000) == 0.0: &#13;
<br/>
                   Blender.Window.DrawProgressBar(PBidx / lineCount, "Read File...") &#13;
<br/><br/>
      if not words: &#13;
<br/>
         continue &#13;
<br/>
      elif words[0] == '*GEOMOBJECT': &#13;
<br/>
         objCheck = 0 &#13;
<br/>
         newObj = ase_obj() &#13;
<br/>
         objects.append(newObj) &#13;
<br/>
         obj = objects[objIdx] &#13;
<br/>
         objIdx += 1 &#13;
<br/>
      elif words[0] == '*NODE_NAME' and objCheck != -1: &#13;
<br/>
         if objCheck == 0: &#13;
<br/>
            obj.name = words[1] &#13;
<br/>
            objCheck = 1 &#13;
<br/>
         elif objCheck == 1: &#13;
<br/>
            obj.objName = words[1] &#13;
<br/>
      elif words[0] == '*TM_ROW0' and objCheck != -1: &#13;
<br/>
         obj.row0x = float(words[1]) &#13;
<br/>
         obj.row0y = float(words[2]) &#13;
<br/>
         obj.row0z = float(words[3]) &#13;
<br/>
      elif words[0] == '*TM_ROW1' and objCheck != -1: &#13;
<br/>
         obj.row1x = float(words[1]) &#13;
<br/>
         obj.row1y = float(words[2]) &#13;
<br/>
         obj.row1z = float(words[3]) &#13;
<br/>
      elif words[0] == '*TM_ROW2' and objCheck != -1: &#13;
<br/>
         obj.row2x = float(words[1]) &#13;
<br/>
         obj.row2y = float(words[2]) &#13;
<br/>
         obj.row2z = float(words[3]) &#13;
<br/>
      elif words[0] == '*TM_ROW3' and objCheck != -1: &#13;
<br/>
         obj.row3x = float(words[1]) &#13;
<br/>
         obj.row3y = float(words[2]) &#13;
<br/>
         obj.row3z = float(words[3]) &#13;
<br/>
         objCheck = -1 &#13;
<br/>
      elif words[0] == '*MESH': &#13;
<br/>
         obj.objType = 'Mesh' &#13;
<br/>
         obj.obj = ase_mesh() &#13;
<br/>
         me = obj.obj &#13;
<br/>
      elif words[0] == '*MESH_NUMVERTEX': &#13;
<br/>
         me.vCount = int(words[1]) &#13;
<br/>
      elif words[0] == '*MESH_NUMFACES': &#13;
<br/>
         me.fCount = int(words[1]) &#13;
<br/>
      elif words[0] == '*MESH_VERTEX': &#13;
<br/>
         #v = mesh_vert() &#13;
<br/>
         v = [float(words[2]),float(words[3]),float(words[4])]&#13;
<br/>
         #v.x = float(words[2])&#13;
<br/>
         #v.y = float(words[3])&#13;
<br/>
         #v.z = float(words[4])&#13;
<br/>
         me.meVerts.append(v) &#13;
<br/>
      elif words[0] == '*MESH_FACE':&#13;
<br/>
         #f = mesh_face()&#13;
<br/>
         f = [int(words[3]),int(words[5]),int(words[7])]&#13;
<br/>
         #f.v1 = int(words[3])&#13;
<br/>
         #f.v2 = int(words[5])&#13;
<br/>
         #f.v3 = int(words[7])&#13;
<br/>
         me.meFaces.append(f) &#13;
<br/>
      elif words[0] == '*MESH_NUMTVERTEX': &#13;
<br/>
         me.uvVCount = int(words[1]) &#13;
<br/>
         if me.uvVCount &gt; 0: &#13;
<br/>
            me.hasFUV = 1 &#13;
<br/>
      elif words[0] == '*MESH_TVERT': &#13;
<br/>
         uv = mesh_uvVert() &#13;
<br/>
         uv.index = int(words[1]) &#13;
<br/>
         uv.u = float(words[2]) &#13;
<br/>
         uv.v = float(words[3]) &#13;
<br/>
         me.uvVerts.append(uv) &#13;
<br/>
      elif words[0] == '*MESH_NUMTVFACES': &#13;
<br/>
         me.uvFCount = int(words[1]) &#13;
<br/>
      elif words[0] == '*MESH_TFACE': &#13;
<br/>
         fUv = mesh_uvFace() &#13;
<br/>
         fUv.index = int(words[1]) &#13;
<br/>
         fUv.uv1 = int(words[2]) &#13;
<br/>
         fUv.uv2 = int(words[3]) &#13;
<br/>
         fUv.uv3 = int(words[4]) &#13;
<br/>
         me.uvFaces.append(fUv) &#13;
<br/>
      elif words[0] == '*MESH_NUMCVERTEX': &#13;
<br/>
         me.vcVCount = int(words[1]) &#13;
<br/>
         if me.uvVCount &gt; 0: &#13;
<br/>
            me.hasVC = 1 &#13;
<br/>
      elif words[0] == '*MESH_VERTCOL': &#13;
<br/>
         c = mesh_vcVert() &#13;
<br/>
         c.index = int(words[1]) &#13;
<br/>
         c.r = round(float(words[2])*256) &#13;
<br/>
         c.g = round(float(words[3])*256) &#13;
<br/>
         c.b = round(float(words[4])*256) &#13;
<br/>
         me.vcVerts.append(c) &#13;
<br/>
      elif words[0] == '*MESH_CFACE': &#13;
<br/>
         fc = mesh_vcFace() &#13;
<br/>
         fc.index = int(words[1]) &#13;
<br/>
         fc.c1 = int(words[2]) &#13;
<br/>
         fc.c2 = int(words[3]) &#13;
<br/>
         fc.c3 = int(words[4]) &#13;
<br/>
         me.vcFaces.append(fc) &#13;
<br/><br/>
      PBidx += 1.0 &#13;
<br/><br/>
   spawn_main(objects) &#13;
<br/><br/>
   Blender.Redraw() &#13;
<br/><br/>
def spawn_main(objects):&#13;
<br/><br/>
   PBidx = 0.0 &#13;
<br/>
   objCount = float(len(objects)) &#13;
<br/><br/>
   print 'Import Objects' &#13;
<br/>
   Blender.Window.DrawProgressBar(0.0, "Importing Objects...") &#13;
<br/><br/>
   for obj in objects: &#13;
<br/><br/>
      Blender.Window.DrawProgressBar(PBidx / objCount, "Importing Objects...") &#13;
<br/><br/>
      if obj.objType == 'Mesh': &#13;
<br/>
         spawn_mesh(obj) &#13;
<br/><br/>
      PBidx += 1.0 &#13;
<br/><br/><br/>
def spawn_mesh(obj):&#13;
<br/><br/>
   objMe = obj.obj&#13;
<br/>
   #normal_flag = 1&#13;
<br/><br/>
   row0 = obj.row0x, obj.row0y, obj.row0z&#13;
<br/>
   row1 = obj.row1x, obj.row1y, obj.row1z&#13;
<br/>
   row2 = obj.row2x, obj.row2y, obj.row2z&#13;
<br/>
   row3 = obj.row3x, obj.row3y, obj.row3z&#13;
<br/><br/>
   newMatrix = Blender.Mathutils.Matrix(row0, row1, row2, row3)&#13;
<br/>
   newMatrix.resize4x4()&#13;
<br/><br/>
   newObj = Blender.Object.New(obj.objType, obj.name)&#13;
<br/>
   newObj.setMatrix(newMatrix)&#13;
<br/>
   Blender.Scene.getCurrent().link(newObj) &#13;
<br/><br/><br/>
   newMesh = Blender.Mesh.New(obj.objName) &#13;
<br/>
   newMesh.getFromObject(newObj.name) &#13;
<br/><br/><br/>
   # Verts &#13;
<br/>
   newMesh.verts.extend(objMe.meVerts)&#13;
<br/><br/>
   # Faces &#13;
<br/>
   newMesh.faces.extend(objMe.meFaces)&#13;
<br/><br/>
   #VertCol &#13;
<br/>
   if guiTable['VC'] == 1 and objMe.hasVC == 1: &#13;
<br/>
      newMesh.vertexColors = 1 &#13;
<br/>
      for c in objMe.vcFaces: &#13;
<br/><br/>
         FCol0 = newMesh.faces[c.index].col[0] &#13;
<br/>
         FCol1 = newMesh.faces[c.index].col[1] &#13;
<br/>
         FCol2 = newMesh.faces[c.index].col[2] &#13;
<br/><br/>
         FCol0.r = int(objMe.vcVerts[c.c1].r) &#13;
<br/>
         FCol0.g = int(objMe.vcVerts[c.c1].g) &#13;
<br/>
         FCol0.b = int(objMe.vcVerts[c.c1].b) &#13;
<br/><br/>
         FCol1.r = int(objMe.vcVerts[c.c2].r) &#13;
<br/>
         FCol1.g = int(objMe.vcVerts[c.c2].g) &#13;
<br/>
         FCol1.b = int(objMe.vcVerts[c.c2].b) &#13;
<br/><br/>
         FCol2.r = int(objMe.vcVerts[c.c3].r) &#13;
<br/>
         FCol2.g = int(objMe.vcVerts[c.c3].g) &#13;
<br/>
         FCol2.b = int(objMe.vcVerts[c.c3].b) &#13;
<br/><br/>
   # UV &#13;
<br/>
   if guiTable['UV'] == 1 and objMe.hasFUV == 1: &#13;
<br/>
      newMesh.faceUV = 1 &#13;
<br/>
      for f in objMe.uvFaces: &#13;
<br/>
         uv1 = Blender.Mathutils.Vector(float(objMe.uvVerts[f.uv1].u), float(objMe.uvVerts[f.uv1].v)) &#13;
<br/>
         uv2 = Blender.Mathutils.Vector(float(objMe.uvVerts[f.uv2].u), float(objMe.uvVerts[f.uv2].v)) &#13;
<br/>
         uv3 = Blender.Mathutils.Vector(float(objMe.uvVerts[f.uv3].u), float(objMe.uvVerts[f.uv3].v)) &#13;
<br/>
         newMesh.faces[f.index].uv = [uv1, uv2, uv3] &#13;
<br/><br/>
   newMesh.transform((newObj.getMatrix('worldspace').invert()), 1) &#13;
<br/>
   newObj.link(newMesh) &#13;
<br/><br/>
   counts['verts'] += objMe.vCount &#13;
<br/>
   counts['tris'] += objMe.fCount &#13;
<br/>
   print 'Imported Mesh-Object: ', obj.name &#13;
<br/><br/><br/><br/>
def read_ui(filename): &#13;
<br/><br/>
   global guiTable, IMPORT_VC, IMPORT_UV &#13;
<br/>
   guiTable = {'VC': 1, 'UV': 1} &#13;
<br/><br/>
   for s in Window.GetScreenInfo(): &#13;
<br/>
      Window.QHandle(s['id']) &#13;
<br/><br/>
   IMPORT_VC = Draw.Create(guiTable['VC']) &#13;
<br/>
   IMPORT_UV = Draw.Create(guiTable['UV']) &#13;
<br/><br/>
   # Get USER Options &#13;
<br/>
   pup_block = [('Import Options'),('Vertex Color', IMPORT_VC, 'Import Vertex Colors if exist'),('UV', IMPORT_UV, 'Import UV if exist'),] &#13;
<br/><br/>
   if not Draw.PupBlock('Import...', pup_block): &#13;
<br/>
      return &#13;
<br/><br/>
   Window.WaitCursor(1)&#13;
<br/><br/>
   guiTable['VC'] = IMPORT_VC.val &#13;
<br/>
   guiTable['UV'] = IMPORT_UV.val &#13;
<br/><br/>
   read_main(filename) &#13;
<br/><br/>
   Window.WaitCursor(0) &#13;
<br/><br/><br/>
if __name__ == '__main__': &#13;
<br/>
   Window.FileSelector(read_ui, 'Import ASCII Scene', ('.ase'))</td>	</tr></table><span class="postbody"/><span class="gensmall"><br/><br/>Last edited by Goofos on Tue Aug 15, 2006 12:25 pm; edited 4 times in total</span></td>
			</tr>]]></body></post><post id="140320" date="Posted: Mon Apr 17, 2006 1:12 pm    Post subject: "><author>Bittoman</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Nice job, thanks Goofos!</span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="140355" date="Posted: Mon Apr 17, 2006 10:30 pm    Post subject: "><author>kat</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Not tried it yet but 'GG' on doing this one. Another step up the ladder for Blender!<br/>_________________<br/><a href="https://web.archive.org/web/20061012234322/http://www.doom3world.org/" target="_blank" class="postlink"><img src="https://web.archive.org/web/20061012234322im_/http://www.doom3world.org/site/img/d3w.gif" border="0"/>Co-Admin</a> - <a href="https://web.archive.org/web/20061012234322/http://www.quake3bits.com/" target="_blank" class="postlink">Modelling and modding tutorials and tips</a></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="143616" date="Posted: Fri May 19, 2006 8:04 pm    Post subject: "><author>kat</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Just tried this script for the 1st time and encountered the following error with Blender 2.41 when run as a script from the text window (Alt+P).&#13;
<br/></span><table width="90%" cellspacing="1" cellpadding="3" border="0" align="center"><tr><td><span class="genmed"><b>Code:</b></span></td>	</tr><tr><td class="code">IndentationError: unindent does not match any outer indentation level&#13;
<br/>
  File "goofosASE_import_17Ap", line 295&#13;
<br/>
    if obj.objType == 'Mesh':&#13;
<br/>
                             ^</td>	</tr></table><span class="postbody"><br/>_________________<br/><a href="https://web.archive.org/web/20061012234322/http://www.doom3world.org/" target="_blank" class="postlink"><img src="https://web.archive.org/web/20061012234322im_/http://www.doom3world.org/site/img/d3w.gif" border="0"/>Co-Admin</a> - <a href="https://web.archive.org/web/20061012234322/http://www.quake3bits.com/" target="_blank" class="postlink">Modelling and modding tutorials and tips</a></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="143762" date="Posted: Sun May 21, 2006 3:58 pm    Post subject: "><author>Goofos</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Should work now. Seems my OS is a bit more tollerant with format errors :&gt;</span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="144077" date="Posted: Fri May 26, 2006 10:43 am    Post subject: "><author>OrbWeaver</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">I haven't tried this but it sounds great. Until now ASE has been almost universally considered an "export-only" format.</span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="144120" date="Posted: Fri May 26, 2006 5:33 pm    Post subject: New error"><author>kat</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">New error when doing Ctrl+P to run the script</span><table width="90%" cellspacing="1" cellpadding="3" border="0" align="center"><tr><td><span class="genmed"><b>Code:</b></span></td>	</tr><tr><td class="code">SyntaxError: invalid token&#13;
<br/>
  File "goofosASE_import_26Ma", line 382&#13;
<br/>
    pup_block = [\&#13;
<br/>
                  ^</td>	</tr></table><span class="postbody"><br/>_________________<br/><a href="https://web.archive.org/web/20061012234322/http://www.doom3world.org/" target="_blank" class="postlink"><img src="https://web.archive.org/web/20061012234322im_/http://www.doom3world.org/site/img/d3w.gif" border="0"/>Co-Admin</a> - <a href="https://web.archive.org/web/20061012234322/http://www.quake3bits.com/" target="_blank" class="postlink">Modelling and modding tutorials and tips</a></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="144546" date="Posted: Wed May 31, 2006 3:07 pm    Post subject: "><author>Goofos</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">There was a space at end of the line if you copy/paste the script from the forum. I have put the array in one line, should work now.</span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="144572" date="Posted: Wed May 31, 2006 6:19 pm    Post subject: "><author>kat</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">DUDE!! sorted. Both vertex and UVW import work fine and dandy.<br/>_________________<br/><a href="https://web.archive.org/web/20061012234322/http://www.doom3world.org/" target="_blank" class="postlink"><img src="https://web.archive.org/web/20061012234322im_/http://www.doom3world.org/site/img/d3w.gif" border="0"/>Co-Admin</a> - <a href="https://web.archive.org/web/20061012234322/http://www.quake3bits.com/" target="_blank" class="postlink">Modelling and modding tutorials and tips</a></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="153676" date="Posted: Tue Aug 15, 2006 12:07 pm    Post subject: "><author>Goofos</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Fixed a problem with the matrices, dont know why this suddenly happened.&#13;
<br/><br/>
[edit]&#13;
<br/>
I quickly updated it again (to v0.12) <img src="https://web.archive.org/web/20061012234322im_/http://doom3world.org/phpbb2/images/smiles/icon_biggrin.gif" alt="Very Happy" border="0"/> to use some improvements of 2.42 (which doesn't worked with 2.40). Now it should import (big) meshes much faster.</span><span class="gensmall"><br/><br/>Last edited by Goofos on Tue Aug 15, 2006 12:34 pm; edited 1 time in total</span></td>
			</tr>]]></body></post><post id="154876" date="Posted: Fri Aug 25, 2006 2:29 am    Post subject: "><author>Tweaker</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Excellent, I was having problems importing with 2.42a, but this seems to have fixed it.  Thanks.   <img src="https://web.archive.org/web/20061012234322im_/http://doom3world.org/phpbb2/images/smiles/icon_biggrin.gif" alt="Very Happy" border="0"/></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="140291" date="Posted: Mon Apr 17, 2006 2:00 am    Post subject: ASE Importer"><author>Goofos</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">I made a first small script to import ASE meshes. Its not perfect and may a bit lame but should import correct meshes (from 3DS). Materials are currently not supported but UV coords and VertexColors. &#13;
<br/>
Note: Meshes from 3DS are very big in Blender <img src="https://web.archive.org/web/20070509181516im_/http://doom3world.org/phpbb2/images/smiles/icon_biggrin.gif" alt="Very Happy" border="0"/><br/><br/></span><table width="90%" cellspacing="1" cellpadding="3" border="0" align="center"><tr><td><span class="genmed"><b>Code:</b></span></td>	</tr><tr><td class="code">#!BPY&#13;
<br/><br/>
""" &#13;
<br/>
Name: 'ASCII Scene (.ase) v0.12'&#13;
<br/>
Blender: 242&#13;
<br/>
Group: 'Import' &#13;
<br/>
Tooltip: 'ASCII Scene import (*.ase)' &#13;
<br/>
""" &#13;
<br/>
__author__ = "Goofos"&#13;
<br/>
__version__ = "0.12"&#13;
<br/><br/>
# goofos at epruegel.de &#13;
<br/>
# &#13;
<br/>
# ***** BEGIN GPL LICENSE BLOCK ***** &#13;
<br/>
#&#13;
<br/>
# This program is free software; you can redistribute it and/or&#13;
<br/>
# modify it under the terms of the GNU General Public License &#13;
<br/>
# as published by the Free Software Foundation; either version 2&#13;
<br/>
# of the License, or (at your option) any later version. &#13;
<br/>
# &#13;
<br/>
# This program is distributed in the hope that it will be useful, &#13;
<br/>
# but WITHOUT ANY WARRANTY; without even the implied warranty of &#13;
<br/>
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the &#13;
<br/>
# GNU General Public License for more details. &#13;
<br/>
# &#13;
<br/>
# You should have received a copy of the GNU General Public License &#13;
<br/>
# along with this program; if not, write to the Free Software Foundation, &#13;
<br/>
# Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. &#13;
<br/>
# &#13;
<br/>
# ***** END GPL LICENCE BLOCK ***** &#13;
<br/><br/>
import string, time, sys as osSys &#13;
<br/>
import Blender &#13;
<br/>
from Blender import Draw, Mesh, Window, Object, Scene &#13;
<br/>
#import meshtools &#13;
<br/><br/><br/>
def read_main(filename): &#13;
<br/><br/>
   global counts &#13;
<br/>
   counts = {'verts': 0, 'tris': 0} &#13;
<br/><br/>
   start = time.clock() &#13;
<br/>
   file = open(filename, "r") &#13;
<br/><br/>
   print_boxed("----------------start-----------------")&#13;
<br/>
   print 'Import Patch: ', filename &#13;
<br/><br/>
   editmode = Window.EditMode()    # are we in edit mode?  If so ... &#13;
<br/>
   if editmode: Window.EditMode(0) # leave edit mode before getting the mesh&#13;
<br/><br/>
   lines= file.readlines() &#13;
<br/>
   read_file(file, lines) &#13;
<br/><br/>
   Blender.Window.DrawProgressBar(1.0, '')  # clear progressbar&#13;
<br/>
   file.close() &#13;
<br/>
   print "----------------end-----------------" &#13;
<br/>
   end = time.clock() &#13;
<br/>
   seconds = " in %.2f %s" % (end-start, "seconds") &#13;
<br/>
   totals = "Verts: %i Tris: %i " % (counts['verts'], counts['tris']) &#13;
<br/>
   print_boxed(totals) &#13;
<br/>
   message = "Successfully imported " + Blender.sys.basename(filename) + seconds &#13;
<br/>
   #meshtools.print_boxed(message) &#13;
<br/>
   print_boxed(message) &#13;
<br/><br/><br/>
def print_boxed(text): #Copy/Paste from meshtools, only to remove the beep :) &#13;
<br/>
   lines = text.splitlines() &#13;
<br/>
   maxlinelen = max(map(len, lines)) &#13;
<br/>
   if osSys.platform[:3] == "win": &#13;
<br/>
      print chr(218)+chr(196) + chr(196)*maxlinelen + chr(196)+chr(191) &#13;
<br/>
      for line in lines: &#13;
<br/>
         print chr(179) + ' ' + line.ljust(maxlinelen) + ' ' + chr(179) &#13;
<br/>
      print chr(192)+chr(196) + chr(196)*maxlinelen + chr(196)+chr(217) &#13;
<br/>
   else: &#13;
<br/>
      print '+-' + '-'*maxlinelen + '-+' &#13;
<br/>
      for line in lines: print '| ' + line.ljust(maxlinelen) + ' |' &#13;
<br/>
      print '+-' + '-'*maxlinelen + '-+' &#13;
<br/>
   #print '\a\r', # beep when done &#13;
<br/><br/><br/>
class ase_obj: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.name = 'Name' &#13;
<br/>
      self.objType = None &#13;
<br/>
      self.row0x = None &#13;
<br/>
      self.row0y = None &#13;
<br/>
      self.row0z = None &#13;
<br/>
      self.row1x = None &#13;
<br/>
      self.row1y = None &#13;
<br/>
      self.row1z = None &#13;
<br/>
      self.row2x = None &#13;
<br/>
      self.row2y = None &#13;
<br/>
      self.row2z = None &#13;
<br/>
      self.row3x = None &#13;
<br/>
      self.row3y = None &#13;
<br/>
      self.row3z = None &#13;
<br/>
      self.parent = None &#13;
<br/>
      self.obj = None &#13;
<br/>
      self.objName = 'Name' &#13;
<br/><br/>
class ase_mesh: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.name = '' &#13;
<br/>
      self.vCount = 0 &#13;
<br/>
      self.fCount = 0 &#13;
<br/>
      self.uvVCount = 0 &#13;
<br/>
      self.uvFCount = 0 &#13;
<br/>
      self.vcVCount = 0 &#13;
<br/>
      self.vcFCount = 0 &#13;
<br/>
      self.meVerts = [] &#13;
<br/>
      self.meFaces = [] &#13;
<br/>
      self.uvVerts = [] &#13;
<br/>
      self.uvFaces = [] &#13;
<br/>
      self.vcVerts = [] &#13;
<br/>
      self.vcFaces = [] &#13;
<br/>
      self.hasFUV = 0 &#13;
<br/>
      self.hasVC = 0 &#13;
<br/><br/>
class mesh_face: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.v1 = 0 &#13;
<br/>
      self.v2 = 0 &#13;
<br/>
      self.v3 = 0 &#13;
<br/>
      self.mat = None &#13;
<br/>
       &#13;
<br/>
class mesh_vert: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.x = 0.0 &#13;
<br/>
      self.y = 0.0 &#13;
<br/>
      self.z = 0.0 &#13;
<br/><br/>
class mesh_uvVert: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.index = 0 &#13;
<br/>
      self.u = 0.0 &#13;
<br/>
      self.v = 0.0 &#13;
<br/>
      self.vec = Blender.Mathutils.Vector(self.u, self.v) &#13;
<br/><br/>
class mesh_uvFace: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.index = 0 &#13;
<br/>
      self.uv1 = 0 &#13;
<br/>
      self.uv2 = 0 &#13;
<br/>
      self.uv3 = 0 &#13;
<br/>
       &#13;
<br/>
class mesh_vcVert: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.index = 0 &#13;
<br/>
      self.r = 0 &#13;
<br/>
      self.g = 0 &#13;
<br/>
      self.b = 0 &#13;
<br/>
      self.a = 255 &#13;
<br/>
       &#13;
<br/>
class mesh_vcFace: &#13;
<br/><br/>
   def __init__(self): &#13;
<br/>
      self.index = 0 &#13;
<br/>
      self.c1 = 0 &#13;
<br/>
      self.c2 = 0 &#13;
<br/>
      self.c3 = 0 &#13;
<br/><br/><br/>
def read_file(file, lines): &#13;
<br/><br/>
   objects = [] &#13;
<br/>
   objIdx = 0 &#13;
<br/>
   objCheck = -1 #needed to skip helper objects &#13;
<br/>
   PBidx = 0.0 &#13;
<br/>
   lineCount = float(len(lines)) &#13;
<br/><br/>
   print 'Read file' &#13;
<br/>
   Blender.Window.DrawProgressBar(0.0, "Read File...") &#13;
<br/><br/>
   for line in lines: &#13;
<br/>
      words = string.split(line) &#13;
<br/><br/>
      if (PBidx % 10000) == 0.0: &#13;
<br/>
                   Blender.Window.DrawProgressBar(PBidx / lineCount, "Read File...") &#13;
<br/><br/>
      if not words: &#13;
<br/>
         continue &#13;
<br/>
      elif words[0] == '*GEOMOBJECT': &#13;
<br/>
         objCheck = 0 &#13;
<br/>
         newObj = ase_obj() &#13;
<br/>
         objects.append(newObj) &#13;
<br/>
         obj = objects[objIdx] &#13;
<br/>
         objIdx += 1 &#13;
<br/>
      elif words[0] == '*NODE_NAME' and objCheck != -1: &#13;
<br/>
         if objCheck == 0: &#13;
<br/>
            obj.name = words[1] &#13;
<br/>
            objCheck = 1 &#13;
<br/>
         elif objCheck == 1: &#13;
<br/>
            obj.objName = words[1] &#13;
<br/>
      elif words[0] == '*TM_ROW0' and objCheck != -1: &#13;
<br/>
         obj.row0x = float(words[1]) &#13;
<br/>
         obj.row0y = float(words[2]) &#13;
<br/>
         obj.row0z = float(words[3]) &#13;
<br/>
      elif words[0] == '*TM_ROW1' and objCheck != -1: &#13;
<br/>
         obj.row1x = float(words[1]) &#13;
<br/>
         obj.row1y = float(words[2]) &#13;
<br/>
         obj.row1z = float(words[3]) &#13;
<br/>
      elif words[0] == '*TM_ROW2' and objCheck != -1: &#13;
<br/>
         obj.row2x = float(words[1]) &#13;
<br/>
         obj.row2y = float(words[2]) &#13;
<br/>
         obj.row2z = float(words[3]) &#13;
<br/>
      elif words[0] == '*TM_ROW3' and objCheck != -1: &#13;
<br/>
         obj.row3x = float(words[1]) &#13;
<br/>
         obj.row3y = float(words[2]) &#13;
<br/>
         obj.row3z = float(words[3]) &#13;
<br/>
         objCheck = -1 &#13;
<br/>
      elif words[0] == '*MESH': &#13;
<br/>
         obj.objType = 'Mesh' &#13;
<br/>
         obj.obj = ase_mesh() &#13;
<br/>
         me = obj.obj &#13;
<br/>
      elif words[0] == '*MESH_NUMVERTEX': &#13;
<br/>
         me.vCount = int(words[1]) &#13;
<br/>
      elif words[0] == '*MESH_NUMFACES': &#13;
<br/>
         me.fCount = int(words[1]) &#13;
<br/>
      elif words[0] == '*MESH_VERTEX': &#13;
<br/>
         #v = mesh_vert() &#13;
<br/>
         v = [float(words[2]),float(words[3]),float(words[4])]&#13;
<br/>
         #v.x = float(words[2])&#13;
<br/>
         #v.y = float(words[3])&#13;
<br/>
         #v.z = float(words[4])&#13;
<br/>
         me.meVerts.append(v) &#13;
<br/>
      elif words[0] == '*MESH_FACE':&#13;
<br/>
         #f = mesh_face()&#13;
<br/>
         f = [int(words[3]),int(words[5]),int(words[7])]&#13;
<br/>
         #f.v1 = int(words[3])&#13;
<br/>
         #f.v2 = int(words[5])&#13;
<br/>
         #f.v3 = int(words[7])&#13;
<br/>
         me.meFaces.append(f) &#13;
<br/>
      elif words[0] == '*MESH_NUMTVERTEX': &#13;
<br/>
         me.uvVCount = int(words[1]) &#13;
<br/>
         if me.uvVCount &gt; 0: &#13;
<br/>
            me.hasFUV = 1 &#13;
<br/>
      elif words[0] == '*MESH_TVERT': &#13;
<br/>
         uv = mesh_uvVert() &#13;
<br/>
         uv.index = int(words[1]) &#13;
<br/>
         uv.u = float(words[2]) &#13;
<br/>
         uv.v = float(words[3]) &#13;
<br/>
         me.uvVerts.append(uv) &#13;
<br/>
      elif words[0] == '*MESH_NUMTVFACES': &#13;
<br/>
         me.uvFCount = int(words[1]) &#13;
<br/>
      elif words[0] == '*MESH_TFACE': &#13;
<br/>
         fUv = mesh_uvFace() &#13;
<br/>
         fUv.index = int(words[1]) &#13;
<br/>
         fUv.uv1 = int(words[2]) &#13;
<br/>
         fUv.uv2 = int(words[3]) &#13;
<br/>
         fUv.uv3 = int(words[4]) &#13;
<br/>
         me.uvFaces.append(fUv) &#13;
<br/>
      elif words[0] == '*MESH_NUMCVERTEX': &#13;
<br/>
         me.vcVCount = int(words[1]) &#13;
<br/>
         if me.uvVCount &gt; 0: &#13;
<br/>
            me.hasVC = 1 &#13;
<br/>
      elif words[0] == '*MESH_VERTCOL': &#13;
<br/>
         c = mesh_vcVert() &#13;
<br/>
         c.index = int(words[1]) &#13;
<br/>
         c.r = round(float(words[2])*256) &#13;
<br/>
         c.g = round(float(words[3])*256) &#13;
<br/>
         c.b = round(float(words[4])*256) &#13;
<br/>
         me.vcVerts.append(c) &#13;
<br/>
      elif words[0] == '*MESH_CFACE': &#13;
<br/>
         fc = mesh_vcFace() &#13;
<br/>
         fc.index = int(words[1]) &#13;
<br/>
         fc.c1 = int(words[2]) &#13;
<br/>
         fc.c2 = int(words[3]) &#13;
<br/>
         fc.c3 = int(words[4]) &#13;
<br/>
         me.vcFaces.append(fc) &#13;
<br/><br/>
      PBidx += 1.0 &#13;
<br/><br/>
   spawn_main(objects) &#13;
<br/><br/>
   Blender.Redraw() &#13;
<br/><br/>
def spawn_main(objects):&#13;
<br/><br/>
   PBidx = 0.0 &#13;
<br/>
   objCount = float(len(objects)) &#13;
<br/><br/>
   print 'Import Objects' &#13;
<br/>
   Blender.Window.DrawProgressBar(0.0, "Importing Objects...") &#13;
<br/><br/>
   for obj in objects: &#13;
<br/><br/>
      Blender.Window.DrawProgressBar(PBidx / objCount, "Importing Objects...") &#13;
<br/><br/>
      if obj.objType == 'Mesh': &#13;
<br/>
         spawn_mesh(obj) &#13;
<br/><br/>
      PBidx += 1.0 &#13;
<br/><br/><br/>
def spawn_mesh(obj):&#13;
<br/><br/>
   objMe = obj.obj&#13;
<br/>
   #normal_flag = 1&#13;
<br/><br/>
   row0 = obj.row0x, obj.row0y, obj.row0z&#13;
<br/>
   row1 = obj.row1x, obj.row1y, obj.row1z&#13;
<br/>
   row2 = obj.row2x, obj.row2y, obj.row2z&#13;
<br/>
   row3 = obj.row3x, obj.row3y, obj.row3z&#13;
<br/><br/>
   newMatrix = Blender.Mathutils.Matrix(row0, row1, row2, row3)&#13;
<br/>
   newMatrix.resize4x4()&#13;
<br/><br/>
   newObj = Blender.Object.New(obj.objType, obj.name)&#13;
<br/>
   newObj.setMatrix(newMatrix)&#13;
<br/>
   Blender.Scene.getCurrent().link(newObj) &#13;
<br/><br/><br/>
   newMesh = Blender.Mesh.New(obj.objName) &#13;
<br/>
   newMesh.getFromObject(newObj.name) &#13;
<br/><br/><br/>
   # Verts &#13;
<br/>
   newMesh.verts.extend(objMe.meVerts)&#13;
<br/><br/>
   # Faces &#13;
<br/>
   newMesh.faces.extend(objMe.meFaces)&#13;
<br/><br/>
   #VertCol &#13;
<br/>
   if guiTable['VC'] == 1 and objMe.hasVC == 1: &#13;
<br/>
      newMesh.vertexColors = 1 &#13;
<br/>
      for c in objMe.vcFaces: &#13;
<br/><br/>
         FCol0 = newMesh.faces[c.index].col[0] &#13;
<br/>
         FCol1 = newMesh.faces[c.index].col[1] &#13;
<br/>
         FCol2 = newMesh.faces[c.index].col[2] &#13;
<br/><br/>
         FCol0.r = int(objMe.vcVerts[c.c1].r) &#13;
<br/>
         FCol0.g = int(objMe.vcVerts[c.c1].g) &#13;
<br/>
         FCol0.b = int(objMe.vcVerts[c.c1].b) &#13;
<br/><br/>
         FCol1.r = int(objMe.vcVerts[c.c2].r) &#13;
<br/>
         FCol1.g = int(objMe.vcVerts[c.c2].g) &#13;
<br/>
         FCol1.b = int(objMe.vcVerts[c.c2].b) &#13;
<br/><br/>
         FCol2.r = int(objMe.vcVerts[c.c3].r) &#13;
<br/>
         FCol2.g = int(objMe.vcVerts[c.c3].g) &#13;
<br/>
         FCol2.b = int(objMe.vcVerts[c.c3].b) &#13;
<br/><br/>
   # UV &#13;
<br/>
   if guiTable['UV'] == 1 and objMe.hasFUV == 1: &#13;
<br/>
      newMesh.faceUV = 1 &#13;
<br/>
      for f in objMe.uvFaces: &#13;
<br/>
         uv1 = Blender.Mathutils.Vector(float(objMe.uvVerts[f.uv1].u), float(objMe.uvVerts[f.uv1].v)) &#13;
<br/>
         uv2 = Blender.Mathutils.Vector(float(objMe.uvVerts[f.uv2].u), float(objMe.uvVerts[f.uv2].v)) &#13;
<br/>
         uv3 = Blender.Mathutils.Vector(float(objMe.uvVerts[f.uv3].u), float(objMe.uvVerts[f.uv3].v)) &#13;
<br/>
         newMesh.faces[f.index].uv = [uv1, uv2, uv3] &#13;
<br/><br/>
   newMesh.transform((newObj.getMatrix('worldspace').invert()), 1) &#13;
<br/>
   newObj.link(newMesh) &#13;
<br/><br/>
   counts['verts'] += objMe.vCount &#13;
<br/>
   counts['tris'] += objMe.fCount &#13;
<br/>
   print 'Imported Mesh-Object: ', obj.name &#13;
<br/><br/><br/><br/>
def read_ui(filename): &#13;
<br/><br/>
   global guiTable, IMPORT_VC, IMPORT_UV &#13;
<br/>
   guiTable = {'VC': 1, 'UV': 1} &#13;
<br/><br/>
   for s in Window.GetScreenInfo(): &#13;
<br/>
      Window.QHandle(s['id']) &#13;
<br/><br/>
   IMPORT_VC = Draw.Create(guiTable['VC']) &#13;
<br/>
   IMPORT_UV = Draw.Create(guiTable['UV']) &#13;
<br/><br/>
   # Get USER Options &#13;
<br/>
   pup_block = [('Import Options'),('Vertex Color', IMPORT_VC, 'Import Vertex Colors if exist'),('UV', IMPORT_UV, 'Import UV if exist'),] &#13;
<br/><br/>
   if not Draw.PupBlock('Import...', pup_block): &#13;
<br/>
      return &#13;
<br/><br/>
   Window.WaitCursor(1)&#13;
<br/><br/>
   guiTable['VC'] = IMPORT_VC.val &#13;
<br/>
   guiTable['UV'] = IMPORT_UV.val &#13;
<br/><br/>
   read_main(filename) &#13;
<br/><br/>
   Window.WaitCursor(0) &#13;
<br/><br/><br/>
if __name__ == '__main__': &#13;
<br/>
   Window.FileSelector(read_ui, 'Import ASCII Scene', ('.ase'))</td>	</tr></table><span class="postbody"/><span class="gensmall"><br/><br/>Last edited by Goofos on Tue Aug 15, 2006 12:25 pm; edited 4 times in total</span></td>
			</tr>]]></body></post><post id="140320" date="Posted: Mon Apr 17, 2006 1:12 pm    Post subject: "><author>Bittoman</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Nice job, thanks Goofos!</span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="140355" date="Posted: Mon Apr 17, 2006 10:30 pm    Post subject: "><author>kat</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Not tried it yet but 'GG' on doing this one. Another step up the ladder for Blender!<br/>_________________<br/><a href="https://web.archive.org/web/20070509181516/http://www.doom3world.org/" target="_blank" class="postlink"><img src="https://web.archive.org/web/20070509181516im_/http://www.doom3world.org/site/img/d3w.gif" border="0"/>Co-Admin</a> - <a href="https://web.archive.org/web/20070509181516/http://www.katsbits.com/" target="_blank" class="postlink">Modelling and modding tutorials and tips</a></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="143616" date="Posted: Fri May 19, 2006 8:04 pm    Post subject: "><author>kat</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Just tried this script for the 1st time and encountered the following error with Blender 2.41 when run as a script from the text window (Alt+P).&#13;
<br/></span><table width="90%" cellspacing="1" cellpadding="3" border="0" align="center"><tr><td><span class="genmed"><b>Code:</b></span></td>	</tr><tr><td class="code">IndentationError: unindent does not match any outer indentation level&#13;
<br/>
  File "goofosASE_import_17Ap", line 295&#13;
<br/>
    if obj.objType == 'Mesh':&#13;
<br/>
                             ^</td>	</tr></table><span class="postbody"><br/>_________________<br/><a href="https://web.archive.org/web/20070509181516/http://www.doom3world.org/" target="_blank" class="postlink"><img src="https://web.archive.org/web/20070509181516im_/http://www.doom3world.org/site/img/d3w.gif" border="0"/>Co-Admin</a> - <a href="https://web.archive.org/web/20070509181516/http://www.katsbits.com/" target="_blank" class="postlink">Modelling and modding tutorials and tips</a></span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="143762" date="Posted: Sun May 21, 2006 3:58 pm    Post subject: "><author>Goofos</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">Should work now. Seems my OS is a bit more tollerant with format errors :&gt;</span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="144077" date="Posted: Fri May 26, 2006 10:43 am    Post subject: "><author>OrbWeaver</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">I haven't tried this but it sounds great. Until now ASE has been almost universally considered an "export-only" format.</span><span class="gensmall"/></td>
			</tr>]]></body></post><post id="144120" date="Posted: Fri May 26, 2006 5:33 pm    Post subject: New error"><author>kat</author><body><![CDATA[<tr><td colspan="2"><span class="postbody">New error when doing Ctrl+P to run the script</span><table width="90%" cellspacing="1" cellpadding="3" border="0" align="center"><tr><td><span class="genmed"><b>Code:</b></span></td>	</tr><tr><td class="code">SyntaxError: invalid token&#13;
<br/>
  File "goofosASE_import_26Ma", line 382&#13;
<br/>
    pup_block = [\&#13;
<br/>
                  ^</td>	</tr></table><span class="postbody"><br/>_________________<br/><a href="https://web.archive.org/web/20070509181516/http://www.doom3world.org/" target="_blank" class="postlink"><img src="https://web.archive.org/web/20070509181516im_/http://www.doom3world.org/site/img/d3w.gif" border="0"/>Co-Admin</a> - <a href="https://web.archive.org/web/20070509181516/http://www.katsbits.com/" target="_blank" class="postlink">Modelling and modding tutorials and tips</a></span><span class="gensmall"/></td>
			</tr>]]></body></post></posts></thread></xml>
