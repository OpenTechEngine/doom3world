<?xml version="1.0" encoding="UTF-8"?>
<xml><thread id="1969"><title>some details about md5anim</title><posts><post id="p18588" date="Posted: Fri Feb 13, 2004 10:21 pm "><author>der_ton</author><body><![CDATA[<div class="postbody">In the past months, I got several emails with technical questions about the modelviewer, mostly regarding the md5anim files and how to use the information they contain. So I guess it´s time to have that covered in a little post here.
<br /><br />This is interesting if you want to make a program that shows md5 models, or if you want to understand the md5anim format a little better. This is not so interesting if you are an artist and want to make md5 models or anims.
<br /><br />I assume that you know how to deal with the information in the md5mesh file, and that you´re able to see the character in it´s un-animated "bind pose", as it is stored in the md5mesh.
<br /><br />The md5anim contains only information on the skeleton (and, less important for our context here, the boundingbox).
<br />How the animation data is stored is not a big secret I think: every bone has a (x,y,z) translation and (yaw, pitch, roll) rotation that´s stored for each frame. This is the data we have, and what we want to get is the 4x4 matrix of the bone in <span style="font-weight: bold">absolute</span> coordinates, much like the info that is stored with the bones in the md5mesh. This way, you don´t even have to change any code that you´ve already written to get the "bind-pose" model on the screen. You just have to use the bone transformation matríx extracted from the md5anim for a given moment.
<br /><br />The information in the md5anim is stored <span style="font-weight: bold">relative</span> to the parent bone. So the algorithm that evaluates the data and calculates the matrix for a bone has to start at the bones with no parents, and then go through the bones, processing only those whose parent bone already was processed. This is actually not a problem at all, since the order of the bones as stored in the md5mesh file is a valid order in that respect. The order of the channels in the md5anim <span style="font-weight: bold">is not</span> (at least not always).
<br /><br />To extract the right values for a given moment is not a big problem I hope. It can be puzzling at first, to see a channel contain less keyframes than it should, but that simply means that the channel´s value doesn´t change at the beginning or the end (or both). To see what´s going on and what the range means, just study several different md5anims, and you should be able to figure out this stuff. It´s easier to understand it with your own mind than having me explain it.
<br /><br /><br />Then when you´re at the point where you extracted the right data, you have x, y, z, pitch, yaw, roll for each bone. Now here´s how this is used to get the absolute transformation matrix for each bone:
<br /><br />Note that this algorithm requires that you go through the bones in a
<br />certain order, because the matrix of a bone´s parent is required. The
<br />bones in the md5mesh has the right order, the md5anim´s channels do not necessarily have that.
<br /><br />Start with an empty "identity" matrix if the bone has no parent,
<br />or start with the already calculated bone´s parent´s transformation matrix
<br /><br />1. translate by the x,y,z values from the animation channels
<br />2. apply "yaw" rotation (which is rotation around the Z axis)
<br />3. apply "pitch" rotation (around the Y axis)
<br />4. apply "roll" rotation (around the X axis)
<br />the result is "this" bone´s matrix, which will have to be used when
<br />calculating its childrens´ matrices, and which will ultimately be used for skinning (calculating the final vertex coordinates for the mesh).
<br /><br />The transformation column represents the transformation in the same way as the "bindpos" numbers do in the md5mesh file, and the 3x3 rotation submatrix of the matrix represents the rotation in the same way as the "bindmat" numbers do in the md5mesh file.
<br /><br /><br />For a little advanced viewer, interpolation has to be used, which would best be done with quaternions, which I won´t explain here. You can get good info here instead:
<br /><!-- m --><a class="postlink" href="https://web.archive.org/web/20100522175552/http://www.j3d.org/matrix_faq/matrfaq_latest.html">http://www.j3d.org/matrix_faq/matrfaq_latest.html</a><!-- m -->
<br /><br />A viewer with sourcecode, made by Sébastien Kuntz:
<br /><!-- m --><a class="postlink" href="https://web.archive.org/web/20100522175552/http://www.nowan.net/cb/3d">http://www.nowan.net/cb/3d</a><!-- m --></div>]]></body></post><post id="p24916" date="Posted: Mon Jun 28, 2004 11:32 am "><author>pinkie</author><body><![CDATA[<div class="postbody">I thought this is probably a better thread to talk about my anim issues, anyway I am still at a loss, i am sure it is something small i just cannot see myself. I have now changed my code around a bit to look like this:
<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">    for (int i = 0; i &lt; skeleton.length; i++)<br />    {<br />      Bone bone = skeleton[i];<br /><br />      // new matrix is identity if has no parents or parents bind matrix<br />      bone.bindMatrix = (bone.parentId &lt; 0) ?<br />        Matrix4f.createIdentity() : new Matrix4f(skeleton[bone.parentId].bindMatrix);<br /><br />      // 1. translate by the x,y,z values from the animation channels<br />      bone.bindMatrix.translate(<br />        bone.attribute[Md5AnimAttribute.X],<br />        bone.attribute[Md5AnimAttribute.Y],<br />        bone.attribute[Md5AnimAttribute.Z]);<br />      <br />      //  2. apply "yaw" rotation (which is rotation around the Z axis)<br />      bone.bindMatrix.rotateAroundZ(bone.attribute[Md5AnimAttribute.YAW]);<br />      //  3. apply "pitch" rotation (around the Y axis)<br />      bone.bindMatrix.rotateAroundY(bone.attribute[Md5AnimAttribute.PITCH]);<br />      //  4. apply "roll" rotation (around the X axis)<br />      bone.bindMatrix.rotateAroundX(bone.attribute[Md5AnimAttribute.ROLL]);<br />    }<br /></div><br /><br />This looks very much like the pseudo code you give above, so I am very confused as to what I am doing wrong.<br /><br />I know the channels are set up correctly and if the code above is correct, process of elimination leaves me to think it is the rotation code - so here is a snippet of "rotateAroundX":<br /><br /><br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">  public void rotateAroundX(float angle)<br />  {<br />    //   Use the 4x4 matrix:<br />    //<br />    //      |  1  0       0       0 |<br />    //   M = |  0  cos(A) -sin(A)  0 |<br />    //      |  0  sin(A)  cos(A)  0 |<br />    //      |  0  0       0       1 |<br />      angle = (float)Math.toRadians(angle);<br /><br />    Matrix4f mat = new Matrix4f();<br />    mat.data[0] = 1.0f;<br />    mat.data[1] = 0.0f;<br />    mat.data[2] = 0.0f;<br />    mat.data[3] = 0.0f;<br />    mat.data[4] = 0.0f;<br />    mat.data[5] = (float)Math.cos(angle);<br />    mat.data[6] = (float)Math.sin(angle);<br />    mat.data[7] = 0.0f;<br />    mat.data[8] = 0.0f;<br />    mat.data[9] = (float) -Math.sin(angle);<br />    mat.data[10] = (float)Math.cos(angle);<br />    mat.data[11] = 0.0f;<br />    mat.data[12] = 0.0f;<br />    mat.data[13] = 0.0f;<br />    mat.data[14] = 0.0f;<br />    mat.data[15] = 1.0f;<br />    mat.mul(this);<br />    this.set(mat);<br />  }<br /></div>
<br /><br />The two main things im not 100% about here are the +ve's and -ve's for the sin values (left handed or right handed notation?) and the multiplication at the end, any ideas?
<br /><br />Simon.</div>]]></body></post><post id="p24920" date="Posted: Mon Jun 28, 2004 12:27 pm "><author>der_ton</author><body><![CDATA[<div class="postbody">Angles in the md5anim are in degrees, in your code they are passed to sin() and cos(), so they have to be in radians. Do you convert somewhere inbetween?</div>]]></body></post><post id="p24940" date="Posted: Mon Jun 28, 2004 9:38 pm "><author>pinkie</author><body><![CDATA[<div class="postbody">Thanks again for the prompt reply der_ton.
<br /><br />The angles are converted to radians in the rotation methods, i.e.:
<br />"angle = (float)Math.toRadians(angle);"
<br /><br />It's a bit ugly as it gets done every time, but plenty of time for optimising once it's going <img src="https://web.archive.org/web/20100522175552im_/http://www.doom3world.org/phpbb2/images/smilies/icon_smile.gif" alt=":)" title="Smile" />.
<br /><br />Simon.</div>]]></body></post><post id="p24942" date="Posted: Mon Jun 28, 2004 10:58 pm "><author>pinkie</author><body><![CDATA[<div class="postbody">Actually, what co-ord system do you use? Do you use ID's version where up is -Z, or do you use the "normal" version where Y is up (right handed)? This would probably influence the order of rotation I guess.
<br /><br />Simon.</div>]]></body></post><post id="p24974" date="Posted: Tue Jun 29, 2004 8:13 am "><author>der_ton</author><body><![CDATA[<div class="postbody"><div class="quotetitle">pinkie wrote:</div><div class="quotecontent">Actually, what co-ord system do you use? Do you use ID's version where up is -Z, or do you use the "normal" version where Y is up (right handed)? This would probably influence the order of rotation I guess.</div>
<br />Yes I think it would. I'm using a righthanded coord system, like OpenGL. In fact, I let OpenGL do the matrix rotations and multiplications, much like in Sebastien Kuntz's viewer. This might be slower (I haven't done any speed comparisons though), but it's much less confusing, and is always consistent with OpenGL's matrix implementation, no matter what they might change about it in the future.</div>]]></body></post><post id="p25038" date="Posted: Wed Jun 30, 2004 12:33 am "><author>pinkie</author><body><![CDATA[<div class="postbody">Hmm, after saying "it is not a swizzling issue" I have realised that is most likely what it is!
<br /><br />I have now made a method in my matrix4f class named rotate that takes a angle and a arbituary vector to rotate around (e.g. like glRotatef(trans[YAW]  , 0,0,1 )) , but I am still getting the same result : /.
<br /><br />I have a feeling that in your GL code you use the right handed co ord system but set the up vector to -Z (0,0,-1), this is what ID uses (John Carmack if your listening WHY!!!) : ). For our game we use the "standard" up vector of (0,1,0), so y is up.
<br /><br />As for speed, the matrix calculations will be much faster in openGL as it uses hardware to do the math, but as there are a shite load of bones all the pushing an popping may slow it down - basically I'm not sure what would be quicker eitheir, any one out there know? Could likely mix the two up and get best of both worlds, Hmmm....
<br /><br />As the rotations are now around an arbitary vector, I think it is most likely just my translations that need swizzling. I will keep hacking and post code when i get it to go.
<br /><br />Anyway, hope all this babbling may be useful for other people, don't mean to post whore the forum's!
<br /><br />Simon.</div>]]></body></post><post id="p25074" date="Posted: Wed Jun 30, 2004 4:42 pm "><author>bozo</author><body><![CDATA[<div class="postbody">my tip is that your combination of the parentmatrix, translation and rotations are wrong, maybe the sequence or the kind of matrix mul (mul the new matrix from the left or right side to the existing matrix)
<br /><br />ie. i do the following (but maybe does not apply to your setting/coordsys) in pseudocode:
<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">QuaternionFromAngles(q1, keyframe1_angles);<br />QuaternionFromAngles(q2, keyframe2_angles);<br />QuaternionSlerp(q1, q2, keyframe_delta, orient);<br />QuaternionToMatrix(orient, rotmat);<br />Interpolate(keyframe1_pos, keyframe2_pos, keyframe_delta, trans);<br />TranslationMatrix(trans, tmat);<br />Matrix_Multiply(rotmat, tmat, transmat);<br />if no parent_bone<br />   Matrix_Copy(transmat, bone-&gt;transmat);<br />else<br />   Matrix_Multiply(transmat, parent_bone-&gt;transmat, bone-&gt;transmat);<br /></div>
<br /><br /><br />(also i had some problems when i try to interpolate between two frames with the rotationangles, sometimes the euler's goes wrong, so i changed to quaternions)</div>]]></body></post><post id="p25267" date="Posted: Mon Jul 05, 2004 8:23 am "><author>pinkie</author><body><![CDATA[<div class="postbody">Thanks bozo, I think I will stick with standard matrices for now, quaternians seem like another level of complexity I don't need right now - will have a look into applying them once my code is a bit more "tuned".
<br /><br />Anyway, I have finally got animations going, and it was indeed due to swizzling - of some sort! (<a href="https://web.archive.org/web/20100522175552/http://www.doom3world.org/phpbb2/viewtopic.php?p=25266#25266" class="postlink">http://www.doom3world.org/phpbb2/viewtopic.php?p=25266#25266</a>) for more details on co-ord system/mesh probs.
<br /><br />And as for the code I promised:
<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">    yaw = new Vector3f(0.0f, 0.0f, 1.0f);<br />    pitch = new Vector3f(0.0f, 1.0f, 0.0f);<br />    roll = new Vector3f(1.0f, 0.0f, 0.0f);<br /><br />    for (int i = 0; i &lt; skeleton.length; i++)<br />    {<br />        Bone bone = skeleton[i];<br />        <br />        // new matrix is identity if has no parents or parents bind<br />        bone.bindMatrix = (bone.parentId &lt; 0) ? <br />               Matrix4f.createIdentity() : new Matrix4f(skeleton[bone.parentId].bindMatrix);<br />        <br />        // 1. translate by the x,y,z values from the animation channels<br />        bone.bindMatrix.translate(<br />               bone.attribute[Md5AnimAttribute.X], <br />               bone.attribute[Md5AnimAttribute.Y], <br />               bone.attribute[Md5AnimAttribute.Z]);<br />        // 2. apply "yaw" rotation (which is rotation around the Z axis)<br />        bone.bindMatrix.rotate(bone.attribute[Md5AnimAttribute.YAW], yaw);<br />        // 3. apply "pitch" rotation (around the Y axis)<br />        bone.bindMatrix.rotate(bone.attribute[Md5AnimAttribute.PITCH], pitch);<br />        // 4. apply "roll" rotation (around the X axis)<br />        bone.bindMatrix.rotate(bone.attribute[Md5AnimAttribute.ROLL], roll);<br />    }<br /></div>
<br /><br />Thats the guts of the animation code (java based), obviously heavily based on the pseudo from der_ton (thanks!!!). I would post the timing code for setting attribs, but it is only really specfic to what I am trying to do, if you have any questions feel free to ask.
<br /><br />And so no-one falls in the same trap I did, my models looked fine loading straight from mesh HOWEVER they were on their side, but I assumed it was because of a funky co-ord system, I also assumed the animation file would be in same system so I figured it would be fine, and I could deal with orientation later.
<br /><br />I WAS WRONG!!  <img src="https://web.archive.org/web/20100522175552im_/http://www.doom3world.org/phpbb2/images/smilies/icon_eek.gif" alt=":shock:" title="Shocked" /> they looked gammy when animated and I couldn't figue out why, many many useless hours later, my friend and I came across these lines in Sébastien Kuntz code which I had missed earlier:
<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">            v.x += (b.rot[0] * w.x + b.rot[3] * w.y + b.rot[6] * w.z + b.pos[0]) * w.t;<br />            v.z += (b.rot[1] * w.x + b.rot[4] * w.y + b.rot[7] * w.z + b.pos[1]) * w.t;<br />            v.y += (b.rot[2] * w.x + b.rot[5] * w.y + b.rot[8] * w.z + b.pos[2]) * w.t;<br /></div>
<br /><br />We tried swapping the z and the y and walla! it worked! who knows why but it worked! normally y becomes z and z becomes -ve y, but hey if it works it works <img src="https://web.archive.org/web/20100522175552im_/http://www.doom3world.org/phpbb2/images/smilies/icon_smile.gif" alt=":)" title="Smile" />.
<br /><br />Thanks for your time and patience der_ton, and your code to look at Sébastien Kuntz (whoever you may be:) ). I expect any code or helpful tips for anything doom 3 related to be used for research only - as I have done for learning about skeletal animation.
<br /><br />Well, of to tune code...</div>]]></body></post><post id="p195833" date="Posted: Sat Mar 01, 2008 11:08 pm "><author>neakor</author><body><![CDATA[<div class="postbody">sry to bring this up. but im having problems on animation.<br /><br />im writing the md5importer for java monkey engine. i loaded the mesh and texture successfully but i cant seem to get the animation right.<br /><br />this is how i read the flags<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">      flag = (int)this.reader.nval;<br />      for(int i = 0; i &lt; 6; i++)<br />      {<br />            this.frameflags.set(joint * 6 + i, (flag &amp; (1 &lt;&lt; i)) != 0);<br />      }<br /></div><br /><br />so heres what i did for reading in the data.<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">      float[] values = new float[6];<br />      for(int i = 0; i &lt; this.parentHierarchy.length; i++)<br />      {<br />         for(int j = 0; j &lt; values.length; j++)<br />         {<br />            if(this.frameflags.get(i * 6 + j))<br />            {<br />               while(this.reader.nextToken() != StreamTokenizer.TT_NUMBER);<br />               values[j] = (float)this.reader.nval;<br />            }<br />            else<br />            {<br />               values[j] = this.baseframe.getTransformValue(i, j);<br />            }<br />         }<br />         for(int t = 0; t &lt; values.length; t++)<br />         {<br />            this.frames[index].setTransform(i, t, values[t]);<br />         }<br />      }<br />      this.frames[index].processTransform();<br /></div><br /><br />im not sure if im doing the right thing here but hopefully i am.<br /><br />and the real question is how do i translate the translation and orientation i read in into bone's local transforms.</div>]]></body></post></posts></thread></xml>
