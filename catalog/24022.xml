<?xml version="1.0" encoding="UTF-8"?>
<xml><thread id="24022"><title>Need help with jumppads</title><posts><post id="p228108" date="Posted: Sun Oct 31, 2010 7:00 am "><author>zhakal</author><body><![CDATA[<div class="postbody">When I fall down onto a jumppad from solid ground the jumppad sound and fx get triggered.<br />But if i jump up and down on the jumppad i will after the first hit, suddenly start to land on the ground, trigger the crashland animation and sound before the jumppad gets triggered and throws me back up. So every second jump is a land.<br /><br />So basically what i need help with is how to jump up and down on a jumppad without triggering a landing (crashland in player.cpp).<br /><br />I can alter the fall deltas but then normal landing sound won't play when you jump.</div>]]></body></post><post id="p228155" date="Posted: Tue Nov 02, 2010 11:24 pm "><author>zhakal</author><body><![CDATA[<div class="postbody">First part shows the move () and second crashland ()<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">void idPlayer::Move( void ) {<br />   float newEyeOffset;<br />   idVec3 oldOrigin;<br />   idVec3 oldVelocity;<br />   idVec3 pushVelocity;<br /><br />   // save old origin and velocity for crashlanding<br />   oldOrigin = physicsObj.GetOrigin();<br />   oldVelocity = physicsObj.GetLinearVelocity();<br />   pushVelocity = physicsObj.GetPushedLinearVelocity();<br /><br />   // set physics variables<br />   physicsObj.SetMaxStepHeight( pm_stepsize.GetFloat() );<br />   physicsObj.SetMaxJumpHeight( pm_jumpheight.GetFloat() );<br /><br />   if ( noclip ) {<br />      physicsObj.SetContents( 0 );<br />      physicsObj.SetMovementType( PM_NOCLIP );<br />   } else if ( spectating || ( gameLocal.isClient &amp;&amp; gameLocal.GetLocalPlayer() &amp;&amp; gameLocal.GetLocalPlayer()-&gt;GetInstance() != instance ) ) {<br />      physicsObj.SetContents( 0 );<br />      physicsObj.SetMovementType( PM_SPECTATOR );<br />   } else if ( health &lt;= 0 ) {<br />      physicsObj.SetContents( CONTENTS_CORPSE | CONTENTS_MONSTERCLIP );<br />      physicsObj.SetMovementType( PM_DEAD );<br />    } else if ( gameLocal.GetCamera() || gameLocal.timeoutData.isTimeout ) { // XBM: timeout stuff (kaffeedoktor)<br />      physicsObj.SetContents( CONTENTS_BODY | CONTENTS_SOLID );<br />      physicsObj.SetMovementType( PM_FREEZE );<br />   } else {<br />      physicsObj.SetContents( CONTENTS_BODY | CONTENTS_SOLID );<br />      physicsObj.SetMovementType( PM_NORMAL );<br />   }<br /><br />   if ( spectating || ( gameLocal.isClient &amp;&amp; gameLocal.GetLocalPlayer() &amp;&amp; gameLocal.GetLocalPlayer()-&gt;GetInstance() != instance ) ) {<br />      physicsObj.SetClipMask( MASK_DEADSOLID );<br />   } else if ( health &lt;= 0 ) {<br />      physicsObj.SetClipMask( MASK_DEADSOLID );<br />   } else {<br />      physicsObj.SetClipMask( MASK_PLAYERSOLID );<br />   }<br /><br />   physicsObj.SetPlayerInput( usercmd, viewAngles );<br /><br />   // FIXME: physics gets disabled somehow<br />   BecomeActive( TH_PHYSICS );<br /><br />   // If the player is dead then only run physics on new<br />   // frames since articulated figures are not synchronized over the network<br />   if ( health &lt;= 0 ) {<br />      if ( gameLocal.isNewFrame ) {<br />         DeathPush();<br />         RunPhysics();<br />      }<br />   } else {<br />      RunPhysics();<br />   }<br /><br />    // update our last valid AAS location for the AI<br />   // sb - AAS always on Fake Clients for TargetFilter - lets talk about how to eliminate the need for this, i don't want to leave it<br />   SetAASLocation();<br /><br />   if ( gameLocal.isNewFrame ) {<br />      if ( spectating ) {<br />         newEyeOffset = 0.0f;<br />      } else if ( health &lt;= 0 ) {<br />         newEyeOffset = pm_deadviewheight.GetFloat();<br />      } else if ( physicsObj.IsCrouching() ) {<br />         newEyeOffset = pm_crouchviewheight.GetFloat();<br />      }<br />      else {<br />         newEyeOffset = pm_normalviewheight.GetFloat();<br />      }<br /><br />      if ( EyeHeight() != newEyeOffset ) {<br />         if ( spectating ) {<br />            SetEyeHeight( newEyeOffset );<br />         } else {<br />            // smooth out duck height changes<br />            SetEyeHeight( EyeHeight() * pm_crouchrate.GetFloat() + newEyeOffset * ( 1.0f - pm_crouchrate.GetFloat() ) );<br />         }<br />      }<br />   }<br />   if ( noclip ) {<br />      pfl.crouch      = false;<br />       pfl.onGround   = false;<br />      pfl.jump      = false;<br />   } else {<br />      pfl.onGround   = physicsObj.HasGroundContacts();<br />      pfl.crouch   = physicsObj.IsCrouching();<br />      pfl.jump      = physicsObj.HasJumped();<br />   }<br /><br />   if ( pfl.jump ) {<br />      loggedAccel_t   *acc = &amp;loggedAccel[currentLoggedAccel&amp;(NUM_LOGGED_ACCELS-1)];<br />      currentLoggedAccel++;<br />      acc-&gt;time = gameLocal.time;<br />      acc-&gt;dir[2] = 200;<br />      acc-&gt;dir[0] = acc-&gt;dir[1] = 0;<br />   }<br /><br />   BobCycle( pushVelocity );<br /><br />   if( !noclip) {<br />      CrashLand( oldOrigin, oldVelocity );<br />   }<br />}<br /></div><br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">void idPlayer::CrashLand( const idVec3 &amp;oldOrigin, const idVec3 &amp;oldVelocity ) {<br />   idVec3      origin, velocity;<br />   idVec3      gravityVector, gravityNormal;<br />   float      delta;<br />   float      dist;<br />   float      vel, acc;<br />   float      t;<br />   float      a, b, c, den;<br />   waterLevel_t waterLevel;<br />    bool      noDamage;<br /><br />   pfl.softLanding = false;<br />   pfl.hardLanding = false;<br /><br />   // if the player is not on the ground<br />   if ( !physicsObj.HasGroundContacts() ) {<br />      return;<br />   }<br /><br />   gravityNormal = physicsObj.GetGravityNormal();<br /><br />   // if the player wasn't going down<br />   if ( ( oldVelocity * -gravityNormal ) &gt;= 0.0f ) {<br />      return;<br />   }<br /><br />   waterLevel = physicsObj.GetWaterLevel();<br /><br />   // never take falling damage if completely underwater<br />   if ( waterLevel == WATERLEVEL_HEAD ) {<br />      return;<br />   }<br /><br /><br />   // no falling damage if touching a nodamage surface<br />    noDamage = false;<br />   for ( int i = 0; i &lt; physicsObj.GetNumContacts(); i++ ) {<br />      const contactInfo_t &amp;contact = physicsObj.GetContact( i );<br />      if ( contact.material-&gt;GetSurfaceFlags() &amp; SURF_NODAMAGE ) {<br />         noDamage = true;<br />          break;<br />      }<br />   }<br /><br />   origin = GetPhysics()-&gt;GetOrigin();<br />   gravityVector = physicsObj.GetGravity();<br /><br />   // calculate the exact velocity on landing<br />   dist = ( origin - oldOrigin ) * -gravityNormal;<br />   vel = oldVelocity * -gravityNormal;<br />   acc = -gravityVector.Length();<br /><br />   a = acc / 2.0f;<br />   b = vel;<br />   c = -dist;<br /><br />   den = b * b - 4.0f * a * c;<br />   if ( den &lt; 0 ) {<br />      return;<br />   }<br />   t = ( -b - idMath::Sqrt( den ) ) / ( 2.0f * a );<br /><br />   delta = vel + t * acc;<br />   delta = delta * delta * 0.0001;<br /><br />   // reduce falling damage if there is standing water<br />   if ( waterLevel == WATERLEVEL_WAIST ) {<br />      delta *= 0.25f;<br />   }<br />   if ( waterLevel == WATERLEVEL_FEET ) {<br />      delta *= 0.5f;<br />   }<br /><br />   if ( delta &lt; 1.0f ) {<br />      return;<br />   }<br /><br />   if ( gameLocal.time - lastFallDmgTime &lt; 100 )<br />      return;<br /><br />   lastFallDmgTime = gameLocal.time;<br /><br />   // ddynerman: moved height delta selection to player def<br />   if ( delta &gt; playerCfg.fatalFallDelta &amp;&amp; playerCfg.fatalFallDelta &gt; 0.0f ) {<br />      pfl.hardLanding = true;<br />      landChange = -32;<br />      landTime = gameLocal.time;<br />       if ( !noDamage ) {<br />          pain_debounce_time = gameLocal.time + pain_delay + 1;  // ignore pain since we'll play our landing anim<br />          Damage( NULL, NULL, idVec3( 0, 0, -1 ), "damage_fatalfall", 1.0f );<br />       }<br />   } else if ( delta &gt; playerCfg.hardFallDelta &amp;&amp; playerCfg.hardFallDelta &gt; 0.0f ) {<br />      pfl.hardLanding = true;<br />      landChange   = -24;<br />      landTime   = gameLocal.time;<br />       if ( !noDamage ) {<br />          pain_debounce_time = gameLocal.time + pain_delay + 1;  // ignore pain since we'll play our landing anim<br />          Damage( NULL, NULL, idVec3( 0, 0, -1 ), "damage_hardfall", 1.0f );<br />       }<br />   } else if ( delta &gt; playerCfg.softFallDelta &amp;&amp; playerCfg.softFallDelta &gt; 0.0f ) {<br />      pfl.softLanding = true;<br />      landChange   = -16;<br />      landTime   = gameLocal.time;<br />       if ( !noDamage ) {<br />          pain_debounce_time = gameLocal.time + pain_delay + 1;  // ignore pain since we'll play our landing anim<br />          Damage( NULL, NULL, idVec3( 0, 0, -1 ), "damage_softfall", 1.0f );<br />      }<br />   } else if ( delta &gt; playerCfg.noFallDelta  &amp;&amp; playerCfg.noFallDelta &gt; 0.0f ) {<br />      pfl.softLanding = true;<br />      landChange   = -8;<br />      landTime   = gameLocal.time;<br />   } else {<br />      return;<br />   }<br />}<br /></div></div>]]></body></post><post id="p228108" date="Posted: Sun Oct 31, 2010 7:00 am "><author>zhakal</author><body><![CDATA[<div class="postbody">When I fall down onto a jumppad from solid ground the jumppad sound and fx get triggered.<br />But if i jump up and down on the jumppad i will after the first hit, suddenly start to land on the ground, trigger the crashland animation and sound before the jumppad gets triggered and throws me back up. So every second jump is a land.<br /><br />So basically what i need help with is how to jump up and down on a jumppad without triggering a landing (crashland in player.cpp).<br /><br />I can alter the fall deltas but then normal landing sound won't play when you jump.</div>]]></body></post><post id="p228155" date="Posted: Tue Nov 02, 2010 11:24 pm "><author>zhakal</author><body><![CDATA[<div class="postbody">First part shows the move () and second crashland ()<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">void idPlayer::Move( void ) {<br />   float newEyeOffset;<br />   idVec3 oldOrigin;<br />   idVec3 oldVelocity;<br />   idVec3 pushVelocity;<br /><br />   // save old origin and velocity for crashlanding<br />   oldOrigin = physicsObj.GetOrigin();<br />   oldVelocity = physicsObj.GetLinearVelocity();<br />   pushVelocity = physicsObj.GetPushedLinearVelocity();<br /><br />   // set physics variables<br />   physicsObj.SetMaxStepHeight( pm_stepsize.GetFloat() );<br />   physicsObj.SetMaxJumpHeight( pm_jumpheight.GetFloat() );<br /><br />   if ( noclip ) {<br />      physicsObj.SetContents( 0 );<br />      physicsObj.SetMovementType( PM_NOCLIP );<br />   } else if ( spectating || ( gameLocal.isClient &amp;&amp; gameLocal.GetLocalPlayer() &amp;&amp; gameLocal.GetLocalPlayer()-&gt;GetInstance() != instance ) ) {<br />      physicsObj.SetContents( 0 );<br />      physicsObj.SetMovementType( PM_SPECTATOR );<br />   } else if ( health &lt;= 0 ) {<br />      physicsObj.SetContents( CONTENTS_CORPSE | CONTENTS_MONSTERCLIP );<br />      physicsObj.SetMovementType( PM_DEAD );<br />    } else if ( gameLocal.GetCamera() || gameLocal.timeoutData.isTimeout ) { // XBM: timeout stuff (kaffeedoktor)<br />      physicsObj.SetContents( CONTENTS_BODY | CONTENTS_SOLID );<br />      physicsObj.SetMovementType( PM_FREEZE );<br />   } else {<br />      physicsObj.SetContents( CONTENTS_BODY | CONTENTS_SOLID );<br />      physicsObj.SetMovementType( PM_NORMAL );<br />   }<br /><br />   if ( spectating || ( gameLocal.isClient &amp;&amp; gameLocal.GetLocalPlayer() &amp;&amp; gameLocal.GetLocalPlayer()-&gt;GetInstance() != instance ) ) {<br />      physicsObj.SetClipMask( MASK_DEADSOLID );<br />   } else if ( health &lt;= 0 ) {<br />      physicsObj.SetClipMask( MASK_DEADSOLID );<br />   } else {<br />      physicsObj.SetClipMask( MASK_PLAYERSOLID );<br />   }<br /><br />   physicsObj.SetPlayerInput( usercmd, viewAngles );<br /><br />   // FIXME: physics gets disabled somehow<br />   BecomeActive( TH_PHYSICS );<br /><br />   // If the player is dead then only run physics on new<br />   // frames since articulated figures are not synchronized over the network<br />   if ( health &lt;= 0 ) {<br />      if ( gameLocal.isNewFrame ) {<br />         DeathPush();<br />         RunPhysics();<br />      }<br />   } else {<br />      RunPhysics();<br />   }<br /><br />    // update our last valid AAS location for the AI<br />   // sb - AAS always on Fake Clients for TargetFilter - lets talk about how to eliminate the need for this, i don't want to leave it<br />   SetAASLocation();<br /><br />   if ( gameLocal.isNewFrame ) {<br />      if ( spectating ) {<br />         newEyeOffset = 0.0f;<br />      } else if ( health &lt;= 0 ) {<br />         newEyeOffset = pm_deadviewheight.GetFloat();<br />      } else if ( physicsObj.IsCrouching() ) {<br />         newEyeOffset = pm_crouchviewheight.GetFloat();<br />      }<br />      else {<br />         newEyeOffset = pm_normalviewheight.GetFloat();<br />      }<br /><br />      if ( EyeHeight() != newEyeOffset ) {<br />         if ( spectating ) {<br />            SetEyeHeight( newEyeOffset );<br />         } else {<br />            // smooth out duck height changes<br />            SetEyeHeight( EyeHeight() * pm_crouchrate.GetFloat() + newEyeOffset * ( 1.0f - pm_crouchrate.GetFloat() ) );<br />         }<br />      }<br />   }<br />   if ( noclip ) {<br />      pfl.crouch      = false;<br />       pfl.onGround   = false;<br />      pfl.jump      = false;<br />   } else {<br />      pfl.onGround   = physicsObj.HasGroundContacts();<br />      pfl.crouch   = physicsObj.IsCrouching();<br />      pfl.jump      = physicsObj.HasJumped();<br />   }<br /><br />   if ( pfl.jump ) {<br />      loggedAccel_t   *acc = &amp;loggedAccel[currentLoggedAccel&amp;(NUM_LOGGED_ACCELS-1)];<br />      currentLoggedAccel++;<br />      acc-&gt;time = gameLocal.time;<br />      acc-&gt;dir[2] = 200;<br />      acc-&gt;dir[0] = acc-&gt;dir[1] = 0;<br />   }<br /><br />   BobCycle( pushVelocity );<br /><br />   if( !noclip) {<br />      CrashLand( oldOrigin, oldVelocity );<br />   }<br />}<br /></div><br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">void idPlayer::CrashLand( const idVec3 &amp;oldOrigin, const idVec3 &amp;oldVelocity ) {<br />   idVec3      origin, velocity;<br />   idVec3      gravityVector, gravityNormal;<br />   float      delta;<br />   float      dist;<br />   float      vel, acc;<br />   float      t;<br />   float      a, b, c, den;<br />   waterLevel_t waterLevel;<br />    bool      noDamage;<br /><br />   pfl.softLanding = false;<br />   pfl.hardLanding = false;<br /><br />   // if the player is not on the ground<br />   if ( !physicsObj.HasGroundContacts() ) {<br />      return;<br />   }<br /><br />   gravityNormal = physicsObj.GetGravityNormal();<br /><br />   // if the player wasn't going down<br />   if ( ( oldVelocity * -gravityNormal ) &gt;= 0.0f ) {<br />      return;<br />   }<br /><br />   waterLevel = physicsObj.GetWaterLevel();<br /><br />   // never take falling damage if completely underwater<br />   if ( waterLevel == WATERLEVEL_HEAD ) {<br />      return;<br />   }<br /><br /><br />   // no falling damage if touching a nodamage surface<br />    noDamage = false;<br />   for ( int i = 0; i &lt; physicsObj.GetNumContacts(); i++ ) {<br />      const contactInfo_t &amp;contact = physicsObj.GetContact( i );<br />      if ( contact.material-&gt;GetSurfaceFlags() &amp; SURF_NODAMAGE ) {<br />         noDamage = true;<br />          break;<br />      }<br />   }<br /><br />   origin = GetPhysics()-&gt;GetOrigin();<br />   gravityVector = physicsObj.GetGravity();<br /><br />   // calculate the exact velocity on landing<br />   dist = ( origin - oldOrigin ) * -gravityNormal;<br />   vel = oldVelocity * -gravityNormal;<br />   acc = -gravityVector.Length();<br /><br />   a = acc / 2.0f;<br />   b = vel;<br />   c = -dist;<br /><br />   den = b * b - 4.0f * a * c;<br />   if ( den &lt; 0 ) {<br />      return;<br />   }<br />   t = ( -b - idMath::Sqrt( den ) ) / ( 2.0f * a );<br /><br />   delta = vel + t * acc;<br />   delta = delta * delta * 0.0001;<br /><br />   // reduce falling damage if there is standing water<br />   if ( waterLevel == WATERLEVEL_WAIST ) {<br />      delta *= 0.25f;<br />   }<br />   if ( waterLevel == WATERLEVEL_FEET ) {<br />      delta *= 0.5f;<br />   }<br /><br />   if ( delta &lt; 1.0f ) {<br />      return;<br />   }<br /><br />   if ( gameLocal.time - lastFallDmgTime &lt; 100 )<br />      return;<br /><br />   lastFallDmgTime = gameLocal.time;<br /><br />   // ddynerman: moved height delta selection to player def<br />   if ( delta &gt; playerCfg.fatalFallDelta &amp;&amp; playerCfg.fatalFallDelta &gt; 0.0f ) {<br />      pfl.hardLanding = true;<br />      landChange = -32;<br />      landTime = gameLocal.time;<br />       if ( !noDamage ) {<br />          pain_debounce_time = gameLocal.time + pain_delay + 1;  // ignore pain since we'll play our landing anim<br />          Damage( NULL, NULL, idVec3( 0, 0, -1 ), "damage_fatalfall", 1.0f );<br />       }<br />   } else if ( delta &gt; playerCfg.hardFallDelta &amp;&amp; playerCfg.hardFallDelta &gt; 0.0f ) {<br />      pfl.hardLanding = true;<br />      landChange   = -24;<br />      landTime   = gameLocal.time;<br />       if ( !noDamage ) {<br />          pain_debounce_time = gameLocal.time + pain_delay + 1;  // ignore pain since we'll play our landing anim<br />          Damage( NULL, NULL, idVec3( 0, 0, -1 ), "damage_hardfall", 1.0f );<br />       }<br />   } else if ( delta &gt; playerCfg.softFallDelta &amp;&amp; playerCfg.softFallDelta &gt; 0.0f ) {<br />      pfl.softLanding = true;<br />      landChange   = -16;<br />      landTime   = gameLocal.time;<br />       if ( !noDamage ) {<br />          pain_debounce_time = gameLocal.time + pain_delay + 1;  // ignore pain since we'll play our landing anim<br />          Damage( NULL, NULL, idVec3( 0, 0, -1 ), "damage_softfall", 1.0f );<br />      }<br />   } else if ( delta &gt; playerCfg.noFallDelta  &amp;&amp; playerCfg.noFallDelta &gt; 0.0f ) {<br />      pfl.softLanding = true;<br />      landChange   = -8;<br />      landTime   = gameLocal.time;<br />   } else {<br />      return;<br />   }<br />}<br /></div></div>]]></body></post><post id="p228108" date="Posted: Sun Oct 31, 2010 7:00 am "><author>zhakal</author><body><![CDATA[<div class="postbody">When I fall down onto a jumppad from solid ground the jumppad sound and fx get triggered.<br />But if i jump up and down on the jumppad i will after the first hit, suddenly start to land on the ground, trigger the crashland animation and sound before the jumppad gets triggered and throws me back up. So every second jump is a land.<br /><br />So basically what i need help with is how to jump up and down on a jumppad without triggering a landing (crashland in player.cpp).<br /><br />I can alter the fall deltas but then normal landing sound won't play when you jump.</div>]]></body></post><post id="p228155" date="Posted: Tue Nov 02, 2010 11:24 pm "><author>zhakal</author><body><![CDATA[<div class="postbody">First part shows the move () and second crashland ()<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">void idPlayer::Move( void ) {<br />   float newEyeOffset;<br />   idVec3 oldOrigin;<br />   idVec3 oldVelocity;<br />   idVec3 pushVelocity;<br /><br />   // save old origin and velocity for crashlanding<br />   oldOrigin = physicsObj.GetOrigin();<br />   oldVelocity = physicsObj.GetLinearVelocity();<br />   pushVelocity = physicsObj.GetPushedLinearVelocity();<br /><br />   // set physics variables<br />   physicsObj.SetMaxStepHeight( pm_stepsize.GetFloat() );<br />   physicsObj.SetMaxJumpHeight( pm_jumpheight.GetFloat() );<br /><br />   if ( noclip ) {<br />      physicsObj.SetContents( 0 );<br />      physicsObj.SetMovementType( PM_NOCLIP );<br />   } else if ( spectating || ( gameLocal.isClient &amp;&amp; gameLocal.GetLocalPlayer() &amp;&amp; gameLocal.GetLocalPlayer()-&gt;GetInstance() != instance ) ) {<br />      physicsObj.SetContents( 0 );<br />      physicsObj.SetMovementType( PM_SPECTATOR );<br />   } else if ( health &lt;= 0 ) {<br />      physicsObj.SetContents( CONTENTS_CORPSE | CONTENTS_MONSTERCLIP );<br />      physicsObj.SetMovementType( PM_DEAD );<br />    } else if ( gameLocal.GetCamera() || gameLocal.timeoutData.isTimeout ) { // XBM: timeout stuff (kaffeedoktor)<br />      physicsObj.SetContents( CONTENTS_BODY | CONTENTS_SOLID );<br />      physicsObj.SetMovementType( PM_FREEZE );<br />   } else {<br />      physicsObj.SetContents( CONTENTS_BODY | CONTENTS_SOLID );<br />      physicsObj.SetMovementType( PM_NORMAL );<br />   }<br /><br />   if ( spectating || ( gameLocal.isClient &amp;&amp; gameLocal.GetLocalPlayer() &amp;&amp; gameLocal.GetLocalPlayer()-&gt;GetInstance() != instance ) ) {<br />      physicsObj.SetClipMask( MASK_DEADSOLID );<br />   } else if ( health &lt;= 0 ) {<br />      physicsObj.SetClipMask( MASK_DEADSOLID );<br />   } else {<br />      physicsObj.SetClipMask( MASK_PLAYERSOLID );<br />   }<br /><br />   physicsObj.SetPlayerInput( usercmd, viewAngles );<br /><br />   // FIXME: physics gets disabled somehow<br />   BecomeActive( TH_PHYSICS );<br /><br />   // If the player is dead then only run physics on new<br />   // frames since articulated figures are not synchronized over the network<br />   if ( health &lt;= 0 ) {<br />      if ( gameLocal.isNewFrame ) {<br />         DeathPush();<br />         RunPhysics();<br />      }<br />   } else {<br />      RunPhysics();<br />   }<br /><br />    // update our last valid AAS location for the AI<br />   // sb - AAS always on Fake Clients for TargetFilter - lets talk about how to eliminate the need for this, i don't want to leave it<br />   SetAASLocation();<br /><br />   if ( gameLocal.isNewFrame ) {<br />      if ( spectating ) {<br />         newEyeOffset = 0.0f;<br />      } else if ( health &lt;= 0 ) {<br />         newEyeOffset = pm_deadviewheight.GetFloat();<br />      } else if ( physicsObj.IsCrouching() ) {<br />         newEyeOffset = pm_crouchviewheight.GetFloat();<br />      }<br />      else {<br />         newEyeOffset = pm_normalviewheight.GetFloat();<br />      }<br /><br />      if ( EyeHeight() != newEyeOffset ) {<br />         if ( spectating ) {<br />            SetEyeHeight( newEyeOffset );<br />         } else {<br />            // smooth out duck height changes<br />            SetEyeHeight( EyeHeight() * pm_crouchrate.GetFloat() + newEyeOffset * ( 1.0f - pm_crouchrate.GetFloat() ) );<br />         }<br />      }<br />   }<br />   if ( noclip ) {<br />      pfl.crouch      = false;<br />       pfl.onGround   = false;<br />      pfl.jump      = false;<br />   } else {<br />      pfl.onGround   = physicsObj.HasGroundContacts();<br />      pfl.crouch   = physicsObj.IsCrouching();<br />      pfl.jump      = physicsObj.HasJumped();<br />   }<br /><br />   if ( pfl.jump ) {<br />      loggedAccel_t   *acc = &amp;loggedAccel[currentLoggedAccel&amp;(NUM_LOGGED_ACCELS-1)];<br />      currentLoggedAccel++;<br />      acc-&gt;time = gameLocal.time;<br />      acc-&gt;dir[2] = 200;<br />      acc-&gt;dir[0] = acc-&gt;dir[1] = 0;<br />   }<br /><br />   BobCycle( pushVelocity );<br /><br />   if( !noclip) {<br />      CrashLand( oldOrigin, oldVelocity );<br />   }<br />}<br /></div><br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">void idPlayer::CrashLand( const idVec3 &amp;oldOrigin, const idVec3 &amp;oldVelocity ) {<br />   idVec3      origin, velocity;<br />   idVec3      gravityVector, gravityNormal;<br />   float      delta;<br />   float      dist;<br />   float      vel, acc;<br />   float      t;<br />   float      a, b, c, den;<br />   waterLevel_t waterLevel;<br />    bool      noDamage;<br /><br />   pfl.softLanding = false;<br />   pfl.hardLanding = false;<br /><br />   // if the player is not on the ground<br />   if ( !physicsObj.HasGroundContacts() ) {<br />      return;<br />   }<br /><br />   gravityNormal = physicsObj.GetGravityNormal();<br /><br />   // if the player wasn't going down<br />   if ( ( oldVelocity * -gravityNormal ) &gt;= 0.0f ) {<br />      return;<br />   }<br /><br />   waterLevel = physicsObj.GetWaterLevel();<br /><br />   // never take falling damage if completely underwater<br />   if ( waterLevel == WATERLEVEL_HEAD ) {<br />      return;<br />   }<br /><br /><br />   // no falling damage if touching a nodamage surface<br />    noDamage = false;<br />   for ( int i = 0; i &lt; physicsObj.GetNumContacts(); i++ ) {<br />      const contactInfo_t &amp;contact = physicsObj.GetContact( i );<br />      if ( contact.material-&gt;GetSurfaceFlags() &amp; SURF_NODAMAGE ) {<br />         noDamage = true;<br />          break;<br />      }<br />   }<br /><br />   origin = GetPhysics()-&gt;GetOrigin();<br />   gravityVector = physicsObj.GetGravity();<br /><br />   // calculate the exact velocity on landing<br />   dist = ( origin - oldOrigin ) * -gravityNormal;<br />   vel = oldVelocity * -gravityNormal;<br />   acc = -gravityVector.Length();<br /><br />   a = acc / 2.0f;<br />   b = vel;<br />   c = -dist;<br /><br />   den = b * b - 4.0f * a * c;<br />   if ( den &lt; 0 ) {<br />      return;<br />   }<br />   t = ( -b - idMath::Sqrt( den ) ) / ( 2.0f * a );<br /><br />   delta = vel + t * acc;<br />   delta = delta * delta * 0.0001;<br /><br />   // reduce falling damage if there is standing water<br />   if ( waterLevel == WATERLEVEL_WAIST ) {<br />      delta *= 0.25f;<br />   }<br />   if ( waterLevel == WATERLEVEL_FEET ) {<br />      delta *= 0.5f;<br />   }<br /><br />   if ( delta &lt; 1.0f ) {<br />      return;<br />   }<br /><br />   if ( gameLocal.time - lastFallDmgTime &lt; 100 )<br />      return;<br /><br />   lastFallDmgTime = gameLocal.time;<br /><br />   // ddynerman: moved height delta selection to player def<br />   if ( delta &gt; playerCfg.fatalFallDelta &amp;&amp; playerCfg.fatalFallDelta &gt; 0.0f ) {<br />      pfl.hardLanding = true;<br />      landChange = -32;<br />      landTime = gameLocal.time;<br />       if ( !noDamage ) {<br />          pain_debounce_time = gameLocal.time + pain_delay + 1;  // ignore pain since we'll play our landing anim<br />          Damage( NULL, NULL, idVec3( 0, 0, -1 ), "damage_fatalfall", 1.0f );<br />       }<br />   } else if ( delta &gt; playerCfg.hardFallDelta &amp;&amp; playerCfg.hardFallDelta &gt; 0.0f ) {<br />      pfl.hardLanding = true;<br />      landChange   = -24;<br />      landTime   = gameLocal.time;<br />       if ( !noDamage ) {<br />          pain_debounce_time = gameLocal.time + pain_delay + 1;  // ignore pain since we'll play our landing anim<br />          Damage( NULL, NULL, idVec3( 0, 0, -1 ), "damage_hardfall", 1.0f );<br />       }<br />   } else if ( delta &gt; playerCfg.softFallDelta &amp;&amp; playerCfg.softFallDelta &gt; 0.0f ) {<br />      pfl.softLanding = true;<br />      landChange   = -16;<br />      landTime   = gameLocal.time;<br />       if ( !noDamage ) {<br />          pain_debounce_time = gameLocal.time + pain_delay + 1;  // ignore pain since we'll play our landing anim<br />          Damage( NULL, NULL, idVec3( 0, 0, -1 ), "damage_softfall", 1.0f );<br />      }<br />   } else if ( delta &gt; playerCfg.noFallDelta  &amp;&amp; playerCfg.noFallDelta &gt; 0.0f ) {<br />      pfl.softLanding = true;<br />      landChange   = -8;<br />      landTime   = gameLocal.time;<br />   } else {<br />      return;<br />   }<br />}<br /></div></div>]]></body></post></posts></thread></xml>
