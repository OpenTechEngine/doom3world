<?xml version="1.0" encoding="UTF-8"?>
<xml><thread id="26127"><title>Grimm techdemo video: Painting the world!</title><posts><post id="p245042" date="Posted: Sat Dec 29, 2012 1:36 pm "><author>BloodRayne</author><body><![CDATA[<div class="postbody">I've implemented a new feature into Grimm:Quest for the Gatherer's key that I'm very excited about. It's simply called 'spray painting' and what it does is allow for mappers to run their map and spray paint the world with decals. No more tedious placing of single plane decals to create static blood, but 'real' painting of the world with decals. I can now run a map, think <span style="font-style: italic">'I'd like to have some blood spray there'</span>, paint the world with a single click, issue the command 'saveDecals' when I am happy with the result and the paint will be there permanently in the map.<br /><br />To make this happen I have exposed a new script command via the SDK that calls 'projectDecalOntoWorld'.<br />I use this routine in a very simple entity called 'grimm_spray' which has several advantages over the regular func_spray.<br />The first advantage is that I can now use random paint decals, allowing for randomly looking worlds (which is what Grimm is all about).<br />The second is that players can turn the feature off, meaning that they can remove these decals for performance reasons, something that's not possible in a static map.<br /><br />There's no real way to describe it unless you see it in action, so I've created a nice video to show off the effect!<br /><br /><span style="font-weight: bold">Click image to play video</span><br /><a href="https://web.archive.org/web/20130319220200/http://www.youtube.com/watch?v=QeYBKp2nnCQ&amp;hd=1" class="postlink"><img src="https://web.archive.org/web/20130319220200im_/http://i48.tinypic.com/34jbry1.jpg" alt="Image" /></a><br /><br />When painting mode is not set, the spray entities spawn during mapload and paint the world, after which they are automatically removed, this will leave only the paint decal.<br />Players can set paint density, to have either more or less paint in the world.<br /><br />I'm pretty excited about this, I've managed to go over 6 maps in a matter of several hours and completely detailed them to taste with decals. This would have normally taken more than a week of careful placing of single decals by hand in the editor, with the added disadvantage of blood not spraying onto nearby objects and such.</div>]]></body></post><post id="p245050" date="Posted: Sun Dec 30, 2012 2:23 am "><author>Tron</author><body><![CDATA[<div class="postbody">Nice!  How many of these decals can you throw around until it starts impacting performance?</div>]]></body></post><post id="p245052" date="Posted: Sun Dec 30, 2012 3:21 am "><author>bladeghost</author><body><![CDATA[<div class="postbody">That's very interesting, can the same be done with grass,rocks and dirt?<br />you have some great talent there rayne.<br />good stuff!</div>]]></body></post><post id="p245054" date="Posted: Sun Dec 30, 2012 4:48 am "><author>BNA!</author><body><![CDATA[<div class="postbody">Oh that's nice!</div>]]></body></post><post id="p245055" date="Posted: Sun Dec 30, 2012 4:56 am "><author>The Happy Friar</author><body><![CDATA[<div class="postbody">That's VERY cool.  I always wondered why id didn't have that built in to D3.  Was there any special hurdles you had to jump over to get this working?</div>]]></body></post><post id="p245057" date="Posted: Sun Dec 30, 2012 7:22 am "><author>motorsep</author><body><![CDATA[<div class="postbody">Aren't those decals dynamic? (meaning you can only have so many of those on the level)</div>]]></body></post><post id="p245067" date="Posted: Sun Dec 30, 2012 10:33 am "><author>BloodRayne</author><body><![CDATA[<div class="postbody"><div class="quotetitle">Tron wrote:</div><div class="quotecontent">Nice!  How many of these decals can you throw around until it starts impacting performance?</div><br /><div class="quotetitle">motorsep wrote:</div><div class="quotecontent">Aren't those decals dynamic? (meaning you can only have so many of those on the level)</div><br />Numbers I'm not sure about, it's just a sprite so there's many. Performance starts to hurt when the decals overlap intersecting lights, so the challenge there is to minimize overlap, try to see them as lights and how lights hurt performance. So you quickly learn what works and what doesn't.<br />There is no hard set limit in my version of the engine.<br /><br /><div class="quotetitle">bladeghost wrote:</div><div class="quotecontent">That's very interesting, can the same be done with grass,rocks and dirt?<br />you have some great talent there rayne.<br />good stuff!</div><br />Any texture. But you can do random grass, rock and dirt model using the func_clutter entity that I made for Grimm which does random models. <img src="https://web.archive.org/web/20130319220200im_/http://www.doom3world.org/phpbb2/images/smilies/icon_smile.gif" alt=":)" title="Smile" /><br /><br /><div class="quotetitle">The Happy Friar wrote:</div><div class="quotecontent">That's VERY cool.  I always wondered why id didn't have that built in to D3.  Was there any special hurdles you had to jump over to get this working?</div><br />Yes, I'm working on making the decals save persistent, which they aren't now. When I quicksave/load the decals disappear, but that's easily fixable. Another hurdle was the angle. It just didn't want to spray in the correct angles, giving lots of stretches and other issues. I've manage to solve most of that but flukes still happen, in that case I simply undo the spray. The eventual code looks really simple, but it took me some time to get there..<img src="https://web.archive.org/web/20130319220200im_/http://www.doom3world.org/phpbb2/images/smilies/icon_smile.gif" alt=":)" title="Smile" /><br /><br />Code is work in progress, still some changes and cleanouts to be done.<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">/* grimm --&gt; spraydecal<br />================<br />idEntity::Event_SprayDecal<br />================<br />*/<br />void idEntity::Event_SprayDecal( idVec3 *spray_origin, const char *mtr_decal, idVec3 *spray_angle, float size ) {<br /><br />   //srpay something<br />   idVec3 newangle = *spray_angle;   <br />   //gameLocal.Printf( "%s &lt;--current vector\n", spray_angle-&gt;ToString() );<br />   <br />   if ( spray_angle-&gt;x &lt;= -45 ) {<br />      newangle.z = 90;<br />   }<br />   if ( spray_angle-&gt;x &gt;= 45 ) {<br />      newangle.z = -90;<br />   }<br /><br />   gameLocal.ProjectDecal( *spray_origin, newangle, 256.0f, true, size, mtr_decal, 0, true );    <br />}<br /></div><br /><br />And I changed gameLocal.ProjectDecal somewhat:<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent"><br />/*<br />===============<br />idGameLocal::ProjectDecal<br />===============<br />*/<br />void idGameLocal::ProjectDecal( const idVec3 &amp;origin, const idVec3 &amp;dir, float depth, bool parallel, float size, const char *material, float angle, bool forever ) {<br />   float s, c;<br />   idMat3 axis, axistemp;<br />   idFixedWinding winding;<br />   idVec3 windingOrigin, projectionOrigin;<br /><br />   static idVec3 decalWinding[4] = {<br />      idVec3(  1.0f,  1.0f, 0.0f ),<br />      idVec3( -1.0f,  1.0f, 0.0f ),<br />      idVec3( -1.0f, -1.0f, 0.0f ),<br />      idVec3(  1.0f, -1.0f, 0.0f )<br />   };<br /><br />   if ( !g_decals.GetBool() ) {<br />      return;<br />   }<br /><br />   // randomly rotate the decal winding<br />   idMath::SinCos16( ( angle ) ? angle : random.RandomFloat() * idMath::TWO_PI, s, c );<br /><br />   // winding orientation<br />   axis[2] = dir;<br />   axis[2].Normalize();<br />   axis[2].NormalVectors( axistemp[0], axistemp[1] );<br />   axis[0] = axistemp[ 0 ] * c + axistemp[ 1 ] * -s;<br />   axis[1] = axistemp[ 0 ] * -s + axistemp[ 1 ] * -c;<br /><br />   windingOrigin = origin + depth * axis[2];<br />   if ( parallel ) {<br />      projectionOrigin = origin - depth * axis[2];<br />   } else {<br />      projectionOrigin = origin;<br />   }<br /><br />   size *= 0.5f;<br /><br />   winding.Clear();<br />   winding += idVec5( windingOrigin + ( axis * decalWinding[0] ) * size, idVec2( 1, 1 ) );<br />   winding += idVec5( windingOrigin + ( axis * decalWinding[1] ) * size, idVec2( 0, 1 ) );<br />   winding += idVec5( windingOrigin + ( axis * decalWinding[2] ) * size, idVec2( 0, 0 ) );<br />   winding += idVec5( windingOrigin + ( axis * decalWinding[3] ) * size, idVec2( 1, 0 ) );<br />   if ( forever ) {<br />      //27 hrs = 'forever' in game time..<br />      //gameLocal.Printf( "Project decal forever\n");<br />      gameRenderWorld-&gt;ProjectDecalOntoWorld( winding, projectionOrigin, parallel, depth * 0.5f, declManager-&gt;FindMaterial( material ), time + SEC2MS( 999999 ) );<br />   } else {<br />      //gameLocal.Printf( "Project decal for decalStay time\n");<br />      gameRenderWorld-&gt;ProjectDecalOntoWorld( winding, projectionOrigin, parallel, depth * 0.5f, declManager-&gt;FindMaterial( material ), time + SEC2MS( g_decalStay.GetFloat() ) );<br />   }<br />   <br />}<br /></div></div>]]></body></post><post id="p245072" date="Posted: Sun Dec 30, 2012 12:05 pm "><author>7318</author><body><![CDATA[<div class="postbody">that's awesome! <br />but with this you could easily surpass the entity limit, isn't it? we have to find a way to get a much bigger entity limit without affecting anything else, just have the capacity to have more stuff in the maps.</div>]]></body></post><post id="p245073" date="Posted: Sun Dec 30, 2012 12:16 pm "><author>BloodRayne</author><body><![CDATA[<div class="postbody"><div class="quotetitle">7318 wrote:</div><div class="quotecontent">that's awesome! <br />but with this you could easily surpass the entity limit, isn't it? we have to find a way to get a much bigger entity limit without affecting anything else, just have the capacity to have more stuff in the maps.</div><br />I currently have a 8192 entity limit. There's around 20-30 spray entities per map so that's no more than about 300 polygons max and 30 entities that are removed upon mapload. I could make it so that it doesn't use entities, but I want them to be available for tweaking afterwards in the editor, where you can give them specific sizes and paint materials etc..</div>]]></body></post><post id="p245080" date="Posted: Sun Dec 30, 2012 8:49 pm "><author>7318</author><body><![CDATA[<div class="postbody">what did you do in order to increase the max entity limit?</div>]]></body></post><post id="p245081" date="Posted: Mon Dec 31, 2012 6:13 am "><author>bkt</author><body><![CDATA[<div class="postbody">What would be great would be if when you 'savedecals' it would write the decals to the mapfile as func_statics (or regular brushes), which you could then finetune in the editor.</div>]]></body></post><post id="p245083" date="Posted: Mon Dec 31, 2012 8:31 am "><author>BloodRayne</author><body><![CDATA[<div class="postbody"><div class="quotetitle">7318 wrote:</div><div class="quotecontent">what did you do in order to increase the max entity limit?</div><br />Simply raised it (it's a variable gameLocal), I searched D3World for it actually, there's a post on it somewhere. <img src="https://web.archive.org/web/20130319220200im_/http://www.doom3world.org/phpbb2/images/smilies/icon_smile.gif" alt=":)" title="Smile" /><br /><br /><div class="quotetitle">bkt wrote:</div><div class="quotecontent">What would be great would be if when you 'savedecals' it would write the decals to the mapfile as func_statics (or regular brushes), which you could then finetune in the editor.</div><br />I actually didn't want to do that because I want to be able to quickly change the decals (and randomly change them).<br />Also, one spray can have multiple decals as it sprays on different objects at once.</div>]]></body></post><post id="p245084" date="Posted: Mon Dec 31, 2012 8:36 am "><author>motorsep</author><body><![CDATA[<div class="postbody">How would you do such decaling in DarkRadiant (so decals end up projected on any kind of curvature in-game) ?<br /><br />Do those decals work the same way as blood / burn marks in-game? If so, I encountered huge fps drop when I shop my player's model to turn it black (~5 decals will kill performance).</div>]]></body></post><post id="p245085" date="Posted: Mon Dec 31, 2012 8:41 am "><author>BloodRayne</author><body><![CDATA[<div class="postbody"><div class="quotetitle">motorsep wrote:</div><div class="quotecontent">How would you do such decaling in DarkRadiant (so decals end up projected on any kind of curvature in-game) ?</div><br />I don't use DarkRadiant so I have no idea, I guess the same as I would do them in DoomEdit, e.g. place a square and texture it?<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Do those decals work the same way as blood / burn marks in-game? If so, I encountered huge fps drop when I shop my player's model to turn it black (~5 decals will kill performance).</div><br />They use ProjectDecal and there are the same performance issues there as with regular burn marks. This is a mapper's tool, to be used by a mapper that has knowledge of where to place these decals. The performance issues come from overlapping lights, creating draws and depend on which texture you use. As long as you stick with 1-2 decals per surface performance is fine.</div>]]></body></post><post id="p245086" date="Posted: Mon Dec 31, 2012 8:46 am "><author>motorsep</author><body><![CDATA[<div class="postbody">Ahh, gotcha <img src="https://web.archive.org/web/20130319220200im_/http://www.doom3world.org/phpbb2/images/smilies/icon_sad.gif" alt=":(" title="Sad" /> I thought you are using something else to project decals. That's why maybe idSoftware did use that method because it's limiting. I wonder how to resolve this issue with performance (make decals not interact with lights?).</div>]]></body></post><post id="p245088" date="Posted: Mon Dec 31, 2012 8:50 am "><author>BloodRayne</author><body><![CDATA[<div class="postbody"><div class="quotetitle">motorsep wrote:</div><div class="quotecontent">Ahh, gotcha <img src="https://web.archive.org/web/20130319220200im_/http://www.doom3world.org/phpbb2/images/smilies/icon_sad.gif" alt=":(" title="Sad" /> I thought you are using something else to project decals. That's why maybe idSoftware did use that method because it's limiting. I wonder how to resolve this issue with performance (make decals not interact with lights?).</div><br />I am developing Grimm in two phases.<br /><br />Phase 1 consists only of source-code fixes that are SDK related. ProjectDecalOntoWorld is a function that's available from inside the GPL code base, Phase 2 will consist of all those changes I couldn't make via the SDK.  It's my plan to look into this again in phase 2 and perhaps create my own routine for it. My knowledge concerning the codebase is growing by the day and I'm nearly at the point where I can start feeling comfortable in calling myself an 'idtech 4' programmer.. Not there yet.. but getting there!</div>]]></body></post><post id="p245089" date="Posted: Mon Dec 31, 2012 8:55 am "><author>motorsep</author><body><![CDATA[<div class="postbody">cool stuff!</div>]]></body></post><post id="p245090" date="Posted: Mon Dec 31, 2012 9:02 am "><author>jmarshall23</author><body><![CDATA[<div class="postbody">Very nice now just put it in the editor : ).</div>]]></body></post><post id="p245105" date="Posted: Mon Dec 31, 2012 8:56 pm "><author>nbohr1more</author><body><![CDATA[<div class="postbody">Dark Radiant has an auto decal feature:<br /><br /><br /><!-- m --><a class="postlink" href="https://web.archive.org/web/20130319220200/http://wiki.thedarkmod.com/index.php?title=Decals">http://wiki.thedarkmod.com/index.php?title=Decals</a><!-- m --><br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">To create decals, select the surface you want to make a decal for (in <span style="font-weight: bold">select face mode</span> or with SHIFT+CTRL+Click the left mouse button). Press the “create Decals for selected Faces” button, it will create a patch for each selected face, which will be exactly in the same plane. Another way to create a decal is create patch yourself and place it were you want. Assign a texture to it from the Media browser, the texture browser or with the surface inspector. <br /></div><br /><br />It doesn't look as fun as this though...</div>]]></body></post><post id="p245110" date="Posted: Mon Dec 31, 2012 11:59 pm "><author>motorsep</author><body><![CDATA[<div class="postbody">How does it get projected though? On runtime ?</div>]]></body></post><post id="p245124" date="Posted: Tue Jan 01, 2013 7:39 am "><author>Serpentine</author><body><![CDATA[<div class="postbody"><div class="quotetitle">motorsep wrote:</div><div class="quotecontent">How does it get projected though? On runtime ?</div><br />This question makes very little sense. wat.</div>]]></body></post><post id="p245126" date="Posted: Tue Jan 01, 2013 7:46 am "><author>BloodRayne</author><body><![CDATA[<div class="postbody"><div class="quotetitle">Serpentine wrote:</div><div class="quotecontent"><div class="quotetitle">motorsep wrote:</div><div class="quotecontent">How does it get projected though? On runtime ?</div><br />This question makes very little sense. wat.</div><br />I think he missed the part where I actually posed source code.  <img src="https://web.archive.org/web/20130319221022im_/http://www.doom3world.org/phpbb2/images/smilies/icon_mrgreen.gif" alt=":mrgreen:" title="Mr. Green" /><br /><br /><div class="quotetitle">nbohr1more wrote:</div><div class="quotecontent">Dark Radiant has an auto decal feature:<br /><br /><br /><!-- m --><a class="postlink" href="https://web.archive.org/web/20130319221022/http://wiki.thedarkmod.com/index.php?title=Decals">http://wiki.thedarkmod.com/index.php?title=Decals</a><!-- m --><br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">To create decals, select the surface you want to make a decal for (in <span style="font-weight: bold">select face mode</span> or with SHIFT+CTRL+Click the left mouse button). Press the “create Decals for selected Faces” button, it will create a patch for each selected face, which will be exactly in the same plane. Another way to create a decal is create patch yourself and place it were you want. Assign a texture to it from the Media browser, the texture browser or with the surface inspector. <br /></div><br /><br />It doesn't look as fun as this though...</div><br /><br />This does seem like a robust way to handle things as well. But it makes things static and give you much less control than in my current setup, which is basically like hanging spraycans in the world which spray their stuff upon mapload and restore, no editing of any kind, no offsetting or texturing needed.</div>]]></body></post><post id="p245128" date="Posted: Tue Jan 01, 2013 7:52 am "><author>motorsep</author><body><![CDATA[<div class="postbody">No, I was asking about DarkRadiant's method. How does flat patch with decal material get projected onto the world?</div>]]></body></post><post id="p245185" date="Posted: Tue Jan 01, 2013 6:02 pm "><author>nbohr1more</author><body><![CDATA[<div class="postbody">The patches are created as any other patches would be. They are map geometry rather than<br />generated entities. (Though you could use the SEED system to generate a bunch of patch models<br />randomly if you wanted.) The only thing special is that you don't need to meticulously create and align<br />the patches (and move them into position) yourself. <br />You just select the surfaces and Dark Radiant creates the patches for you with the right size and alignment.<br /><br />As far as entity usage. One trick that we tend to advise for decorative grime patches is to merge them into<br />a single func_static entity. You could also do this with BloodRayne's method since it looks like you are saving <br />the decals to the map via a console action. You'd just need to crack open the editor, find the decal patches and mark them<br />as part of the same func_static entity. Though it would kinda defeat the purpose of having an easy free-form<br />workflow...</div>]]></body></post><post id="p245186" date="Posted: Tue Jan 01, 2013 6:45 pm "><author>BloodRayne</author><body><![CDATA[<div class="postbody"><div class="quotetitle">nbohr1more wrote:</div><div class="quotecontent">As far as entity usage. One trick that we tend to advise for decorative grime patches is to merge them into<br />a single func_static entity. You could also do this with BloodRayne's method since it looks like you are saving <br />the decals to the map via a console action. You'd just need to crack open the editor, find the decal patches and mark them<br />as part of the same func_static entity. Though it would kinda defeat the purpose of having an easy free-form<br />workflow...</div><br />Actually, they are func_static entities that project a decal, nothing more.<br />They do it upon map load/restore. (Meaning that if you do a 'reloadModels' or 'vid_restart' the decals disappear), but will fix that soon as well. There's nothing in the editor but these entities to see/edit. You can give their projected decal an angle, set a mtr_decal key (or have it choose a random decal for you) and set spray size. These entities don't create map geometry other than the decals needed.</div>]]></body></post><post id="p245187" date="Posted: Tue Jan 01, 2013 8:53 pm "><author>nbohr1more</author><body><![CDATA[<div class="postbody">OK. So they are like SEED entities or Particle emitters then.<br /><br />This might come in handy for TDM after all... Especially since distributing SEED entities on anything other than<br />a gravity-based orientation has proven a challenge. If these emitters project spherically then this would solve<br />issues like spawning rocks or vegetation in a cylindrical cave area.</div>]]></body></post><post id="p245188" date="Posted: Tue Jan 01, 2013 8:59 pm "><author>BloodRayne</author><body><![CDATA[<div class="postbody"><div class="quotetitle">nbohr1more wrote:</div><div class="quotecontent">OK. So they are like SEED entities or Particle emitters then.<br /><br />This might come in handy for TDM after all... Especially since distributing SEED entities on anything other than<br />a gravity-based orientation has proven a challenge. If these emitters project spherically then this would solve<br />issues like spawning rocks or vegetation in a cylindrical cave area.</div><br />The engine can do that, look into ProjectDecalOntoWorld in RenderWorld.cpp and modelDecal.cpp.<br />Mind you, that's just a starting point, I haven't done anything with these. My changes were made solely in entity.cpp. <img src="https://web.archive.org/web/20130319221022im_/http://www.doom3world.org/phpbb2/images/smilies/icon_smile.gif" alt=":)" title="Smile" /><br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">/*<br />================<br />idRenderWorldLocal::ProjectDecalOntoWorld<br />================<br />*/<br />void idRenderWorldLocal::ProjectDecalOntoWorld(const idFixedWinding &amp;winding, const idVec3 &amp;projectionOrigin, const bool parallel, const float fadeDepth, const idMaterial *material, const int startTime)<br />{<br />    int i, areas[10], numAreas;<br />    const areaReference_t *ref;<br />    const portalArea_t *area;<br />    const idRenderModel *model;<br />    idRenderEntityLocal *def;<br />    decalProjectionInfo_t info, localInfo;<br /><br />    if (!idRenderModelDecal::CreateProjectionInfo(info, winding, projectionOrigin, parallel, fadeDepth, material, startTime))<br />    {<br />        return;<br />    }<br /><br />    // get the world areas touched by the projection volume<br />    numAreas = BoundsInAreas(info.projectionBounds, areas, 10);<br /><br />    // check all areas for models<br />    for (i = 0; i &lt; numAreas; i++)<br />    {<br /><br />        area = &amp;portalAreas[ areas[i] ];<br /><br />        // check all models in this area<br />        for (ref = area-&gt;entityRefs.areaNext; ref != &amp;area-&gt;entityRefs; ref = ref-&gt;areaNext)<br />        {<br />            def = ref-&gt;entity;<br /><br />            // completely ignore any dynamic or callback models<br />            model = def-&gt;parms.hModel;<br /><br />            if (model == NULL || model-&gt;IsDynamicModel() != DM_STATIC || def-&gt;parms.callback)<br />            {<br />                continue;<br />            }<br /><br />            if (def-&gt;parms.customShader != NULL &amp;&amp; !def-&gt;parms.customShader-&gt;AllowOverlays())<br />            {<br />                continue;<br />            }<br /><br />            idBounds bounds;<br />            bounds.FromTransformedBounds(model-&gt;Bounds(&amp;def-&gt;parms), def-&gt;parms.origin, def-&gt;parms.axis);<br /><br />            // if the model bounds do not overlap with the projection bounds<br />            if (!info.projectionBounds.IntersectsBounds(bounds))<br />            {<br />                continue;<br />            }<br /><br />            // transform the bounding planes, fade planes and texture axis into local space<br />            idRenderModelDecal::GlobalProjectionInfoToLocal(localInfo, info, def-&gt;parms.origin, def-&gt;parms.axis);<br />            localInfo.force = (def-&gt;parms.customShader != NULL);<br /><br />            if (!def-&gt;decals)<br />            {<br />                def-&gt;decals = idRenderModelDecal::Alloc();<br />            }<br /><br />            def-&gt;decals-&gt;CreateDecal(model, localInfo);<br />        }<br />    }<br />}<br /><br />/*<br />====================<br />idRenderWorldLocal::ProjectDecal<br />====================<br />*/<br />void idRenderWorldLocal::ProjectDecal(qhandle_t entityHandle, const idFixedWinding &amp;winding, const idVec3 &amp;projectionOrigin, const bool parallel, const float fadeDepth, const idMaterial *material, const int startTime)<br />{<br />    decalProjectionInfo_t info, localInfo;<br /><br />    if (entityHandle &lt; 0 || entityHandle &gt;= entityDefs.Num())<br />    {<br />        common-&gt;Error("idRenderWorld::ProjectOverlay: index = %i", entityHandle);<br />        return;<br />    }<br /><br />    idRenderEntityLocal   *def = entityDefs[ entityHandle ];<br /><br />    if (!def)<br />    {<br />        return;<br />    }<br /><br />    const idRenderModel *model = def-&gt;parms.hModel;<br /><br />    if (model == NULL || model-&gt;IsDynamicModel() != DM_STATIC || def-&gt;parms.callback)<br />    {<br />        return;<br />    }<br /><br />    if (!idRenderModelDecal::CreateProjectionInfo(info, winding, projectionOrigin, parallel, fadeDepth, material, startTime))<br />    {<br />        return;<br />    }<br /><br />    idBounds bounds;<br />    bounds.FromTransformedBounds(model-&gt;Bounds(&amp;def-&gt;parms), def-&gt;parms.origin, def-&gt;parms.axis);<br /><br />    // if the model bounds do not overlap with the projection bounds<br />    if (!info.projectionBounds.IntersectsBounds(bounds))<br />    {<br />        return;<br />    }<br /><br />    // transform the bounding planes, fade planes and texture axis into local space<br />    idRenderModelDecal::GlobalProjectionInfoToLocal(localInfo, info, def-&gt;parms.origin, def-&gt;parms.axis);<br />    localInfo.force = (def-&gt;parms.customShader != NULL);<br /><br />    if (def-&gt;decals == NULL)<br />    {<br />        def-&gt;decals = idRenderModelDecal::Alloc();<br />    }<br /><br />    def-&gt;decals-&gt;CreateDecal(model, localInfo);<br />}<br /><br />/*<br />====================<br />idRenderWorldLocal::ProjectOverlay<br />====================<br />*/<br />void idRenderWorldLocal::ProjectOverlay(qhandle_t entityHandle, const idPlane localTextureAxis[2], const idMaterial *material)<br />{<br /><br />    if (entityHandle &lt; 0 || entityHandle &gt;= entityDefs.Num())<br />    {<br />        common-&gt;Error("idRenderWorld::ProjectOverlay: index = %i", entityHandle);<br />        return;<br />    }<br /><br />    idRenderEntityLocal   *def = entityDefs[ entityHandle ];<br /><br />    if (!def)<br />    {<br />        return;<br />    }<br /><br />    const renderEntity_t *refEnt = &amp;def-&gt;parms;<br /><br />    idRenderModel *model = refEnt-&gt;hModel;<br /><br />    if (model-&gt;IsDynamicModel() != DM_CACHED)     // FIXME: probably should be MD5 only<br />    {<br />        return;<br />    }<br /><br />    model = R_EntityDefDynamicModel(def);<br /><br />    if (def-&gt;overlay == NULL)<br />    {<br />        def-&gt;overlay = idRenderModelOverlay::Alloc();<br />    }<br /><br />    def-&gt;overlay-&gt;CreateOverlay(model, localTextureAxis, material);<br />}<br /></div><br /><br />And ModelDecl.cpp<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">/*<br />=================<br />idRenderModelDecal::CreateProjectionInfo<br />=================<br />*/<br />bool idRenderModelDecal::CreateProjectionInfo(decalProjectionInfo_t &amp;info, const idFixedWinding &amp;winding, const idVec3 &amp;projectionOrigin, const bool parallel, const float fadeDepth, const idMaterial *material, const int startTime)<br />{<br /><br />    if (winding.GetNumPoints() != NUM_DECAL_BOUNDING_PLANES - 2)<br />    {<br />        common-&gt;Printf("idRenderModelDecal::CreateProjectionInfo: winding must have %d points\n", NUM_DECAL_BOUNDING_PLANES - 2);<br />        return false;<br />    }<br /><br />    assert(material != NULL);<br /><br />    info.projectionOrigin = projectionOrigin;<br />    info.material = material;<br />    info.parallel = parallel;<br />    info.fadeDepth = fadeDepth;<br />    info.startTime = startTime;<br />    info.force = false;<br /><br />    // get the winding plane and the depth of the projection volume<br />    idPlane windingPlane;<br />    winding.GetPlane(windingPlane);<br />    float depth = windingPlane.Distance(projectionOrigin);<br /><br />    // find the bounds for the projection<br />    winding.GetBounds(info.projectionBounds);<br /><br />    if (parallel)<br />    {<br />        info.projectionBounds.ExpandSelf(depth);<br />    }<br />    else<br />    {<br />        info.projectionBounds.AddPoint(projectionOrigin);<br />    }<br /><br />    // calculate the world space projection volume bounding planes, positive sides face outside the decal<br />    if (parallel)<br />    {<br />        for (int i = 0; i &lt; winding.GetNumPoints(); i++)<br />        {<br />            idVec3 edge = winding[(i + 1) % winding.GetNumPoints()].ToVec3() - winding[i].ToVec3();<br />            info.boundingPlanes[i].Normal().Cross(windingPlane.Normal(), edge);<br />            info.boundingPlanes[i].Normalize();<br />            info.boundingPlanes[i].FitThroughPoint(winding[i].ToVec3());<br />        }<br />    }<br />    else<br />    {<br />        for (int i = 0; i &lt; winding.GetNumPoints(); i++)<br />        {<br />            info.boundingPlanes[i].FromPoints(projectionOrigin, winding[i].ToVec3(), winding[(i + 1) % winding.GetNumPoints()].ToVec3());<br />        }<br />    }<br /><br />    info.boundingPlanes[NUM_DECAL_BOUNDING_PLANES - 2] = windingPlane;<br />    info.boundingPlanes[NUM_DECAL_BOUNDING_PLANES - 2][3] -= depth;<br />    info.boundingPlanes[NUM_DECAL_BOUNDING_PLANES - 1] = -windingPlane;<br /><br />    // fades will be from these plane<br />    info.fadePlanes[0] = windingPlane;<br />    info.fadePlanes[0][3] -= fadeDepth;<br />    info.fadePlanes[1] = -windingPlane;<br />    info.fadePlanes[1][3] += depth - fadeDepth;<br /><br />    // calculate the texture vectors for the winding<br />    float   len, texArea, inva;<br />    idVec3   temp;<br />    idVec5   d0, d1;<br /><br />    const idVec5 &amp;a = winding[0];<br />    const idVec5 &amp;b = winding[1];<br />    const idVec5 &amp;c = winding[2];<br /><br />    d0 = b.ToVec3() - a.ToVec3();<br />    d0.s = b.s - a.s;<br />    d0.t = b.t - a.t;<br />    d1 = c.ToVec3() - a.ToVec3();<br />    d1.s = c.s - a.s;<br />    d1.t = c.t - a.t;<br /><br />    texArea = (d0[3] * d1[4]) - (d0[4] * d1[3]);<br />    inva = 1.0f / texArea;<br /><br />    temp[0] = (d0[0] * d1[4] - d0[4] * d1[0]) * inva;<br />    temp[1] = (d0[1] * d1[4] - d0[4] * d1[1]) * inva;<br />    temp[2] = (d0[2] * d1[4] - d0[4] * d1[2]) * inva;<br />    len = temp.Normalize();<br />    info.textureAxis[0].Normal() = temp * (1.0f / len);<br />    info.textureAxis[0][3] = winding[0].s - (winding[0].ToVec3() * info.textureAxis[0].Normal());<br /><br />    temp[0] = (d0[3] * d1[0] - d0[0] * d1[3]) * inva;<br />    temp[1] = (d0[3] * d1[1] - d0[1] * d1[3]) * inva;<br />    temp[2] = (d0[3] * d1[2] - d0[2] * d1[3]) * inva;<br />    len = temp.Normalize();<br />    info.textureAxis[1].Normal() = temp * (1.0f / len);<br />    info.textureAxis[1][3] = winding[0].t - (winding[0].ToVec3() * info.textureAxis[1].Normal());<br /><br />    return true;<br />}<br /><br />/*<br />=================<br />idRenderModelDecal::CreateProjectionInfo<br />=================<br />*/<br />void idRenderModelDecal::GlobalProjectionInfoToLocal(decalProjectionInfo_t &amp;localInfo, const decalProjectionInfo_t &amp;info, const idVec3 &amp;origin, const idMat3 &amp;axis)<br />{<br />    float modelMatrix[16];<br /><br />    R_AxisToModelMatrix(axis, origin, modelMatrix);<br /><br />    for (int j = 0; j &lt; NUM_DECAL_BOUNDING_PLANES; j++)<br />    {<br />        R_GlobalPlaneToLocal(modelMatrix, info.boundingPlanes[j], localInfo.boundingPlanes[j]);<br />    }<br /><br />    R_GlobalPlaneToLocal(modelMatrix, info.fadePlanes[0], localInfo.fadePlanes[0]);<br />    R_GlobalPlaneToLocal(modelMatrix, info.fadePlanes[1], localInfo.fadePlanes[1]);<br />    R_GlobalPlaneToLocal(modelMatrix, info.textureAxis[0], localInfo.textureAxis[0]);<br />    R_GlobalPlaneToLocal(modelMatrix, info.textureAxis[1], localInfo.textureAxis[1]);<br />    R_GlobalPointToLocal(modelMatrix, info.projectionOrigin, localInfo.projectionOrigin);<br />    localInfo.projectionBounds = info.projectionBounds;<br />    localInfo.projectionBounds.TranslateSelf(-origin);<br />    localInfo.projectionBounds.RotateSelf(axis.Transpose());<br />    localInfo.material = info.material;<br />    localInfo.parallel = info.parallel;<br />    localInfo.fadeDepth = info.fadeDepth;<br />    localInfo.startTime = info.startTime;<br />    localInfo.force = info.force;<br />}<br /><br />/*<br />=================<br />idRenderModelDecal::AddWinding<br />=================<br />*/<br />void idRenderModelDecal::AddWinding(const idWinding &amp;w, const idMaterial *decalMaterial, const idPlane fadePlanes[2], float fadeDepth, int startTime)<br />{<br />    int i;<br />    float invFadeDepth, fade;<br />    decalInfo_t   decalInfo;<br /><br />    if ((material == NULL || material == decalMaterial) &amp;&amp;<br />        tri.numVerts + w.GetNumPoints() &lt; MAX_DECAL_VERTS &amp;&amp;<br />        tri.numIndexes + (w.GetNumPoints() - 2) * 3 &lt; MAX_DECAL_INDEXES)<br />    {<br /><br />        material = decalMaterial;<br /><br />        // add to this decal<br />        decalInfo = material-&gt;GetDecalInfo();<br />        invFadeDepth = -1.0f / fadeDepth;<br /><br />        for (i = 0; i &lt; w.GetNumPoints(); i++)<br />        {<br />            fade = fadePlanes[0].Distance(w[i].ToVec3()) * invFadeDepth;<br /><br />            if (fade &lt; 0.0f)<br />            {<br />                fade = fadePlanes[1].Distance(w[i].ToVec3()) * invFadeDepth;<br />            }<br /><br />            if (fade &lt; 0.0f)<br />            {<br />                fade = 0.0f;<br />            }<br />            else if (fade &gt; 0.99f)<br />            {<br />                fade = 1.0f;<br />            }<br /><br />            fade = 1.0f - fade;<br />            vertDepthFade[tri.numVerts + i] = fade;<br />            tri.verts[tri.numVerts + i].xyz = w[i].ToVec3();<br />            tri.verts[tri.numVerts + i].st[0] = w[i].s;<br />            tri.verts[tri.numVerts + i].st[1] = w[i].t;<br /><br />            for (int k = 0; k &lt; 4; k++)<br />            {<br />                int icolor = idMath::FtoiFast(decalInfo.start[k] * fade * 255.0f);<br /><br />                if (icolor &lt; 0)<br />                {<br />                    icolor = 0;<br />                }<br />                else if (icolor &gt; 255)<br />                {<br />                    icolor = 255;<br />                }<br /><br />                tri.verts[tri.numVerts + i].color[k] = icolor;<br />            }<br />        }<br /><br />        for (i = 2; i &lt; w.GetNumPoints(); i++)<br />        {<br />            tri.indexes[tri.numIndexes + 0] = tri.numVerts;<br />            tri.indexes[tri.numIndexes + 1] = tri.numVerts + i - 1;<br />            tri.indexes[tri.numIndexes + 2] = tri.numVerts + i;<br />            indexStartTime[tri.numIndexes] =<br />                indexStartTime[tri.numIndexes + 1] =<br />                    indexStartTime[tri.numIndexes + 2] = startTime;<br />            tri.numIndexes += 3;<br />        }<br /><br />        tri.numVerts += w.GetNumPoints();<br />        return;<br />    }<br /><br />    // if we are at the end of the list, create a new decal<br />    if (!nextDecal)<br />    {<br />        nextDecal = idRenderModelDecal::Alloc();<br />    }<br /><br />    // let the next decal on the chain take a look<br />    nextDecal-&gt;AddWinding(w, decalMaterial, fadePlanes, fadeDepth, startTime);<br />}<br /><br />/*<br />=================<br />idRenderModelDecal::AddDepthFadedWinding<br />=================<br />*/<br />void idRenderModelDecal::AddDepthFadedWinding(const idWinding &amp;w, const idMaterial *decalMaterial, const idPlane fadePlanes[2], float fadeDepth, int startTime)<br />{<br />    idFixedWinding front, back;<br /><br />    front = w;<br /><br />    if (front.Split(&amp;back, fadePlanes[0], 0.1f) == SIDE_CROSS)<br />    {<br />        AddWinding(back, decalMaterial, fadePlanes, fadeDepth, startTime);<br />    }<br /><br />    if (front.Split(&amp;back, fadePlanes[1], 0.1f) == SIDE_CROSS)<br />    {<br />        AddWinding(back, decalMaterial, fadePlanes, fadeDepth, startTime);<br />    }<br /><br />    AddWinding(front, decalMaterial, fadePlanes, fadeDepth, startTime);<br />}<br /><br />/*<br />=================<br />idRenderModelDecal::CreateDecal<br />=================<br />*/<br />void idRenderModelDecal::CreateDecal(const idRenderModel *model, const decalProjectionInfo_t &amp;localInfo)<br />{<br /><br />    // check all model surfaces<br />    for (int surfNum = 0; surfNum &lt; model-&gt;NumSurfaces(); surfNum++)<br />    {<br />        const modelSurface_t *surf = model-&gt;Surface(surfNum);<br /><br />        // if no geometry or no shader<br />        if (!surf-&gt;geometry || !surf-&gt;shader)<br />        {<br />            continue;<br />        }<br /><br />        // decals and overlays use the same rules<br />        if (!localInfo.force &amp;&amp; !surf-&gt;shader-&gt;AllowOverlays())<br />        {<br />            continue;<br />        }<br /><br />        srfTriangles_t *stri = surf-&gt;geometry;<br /><br />        // if the triangle bounds do not overlap with projection bounds<br />        if (!localInfo.projectionBounds.IntersectsBounds(stri-&gt;bounds))<br />        {<br />            continue;<br />        }<br /><br />        // allocate memory for the cull bits<br />        byte *cullBits = (byte *) _alloca16(stri-&gt;numVerts * sizeof(cullBits[0]));<br /><br />        // catagorize all points by the planes<br />        SIMDProcessor-&gt;DecalPointCull(cullBits, localInfo.boundingPlanes, stri-&gt;verts, stri-&gt;numVerts);<br /><br />        // find triangles inside the projection volume<br />        for (int triNum = 0, index = 0; index &lt; stri-&gt;numIndexes; index += 3, triNum++)<br />        {<br />            int v1 = stri-&gt;indexes[index + 0];<br />            int v2 = stri-&gt;indexes[index + 1];<br />            int v3 = stri-&gt;indexes[index + 2];<br /><br />            // skip triangles completely off one side<br />            if (cullBits[v1] &amp; cullBits[v2] &amp; cullBits[v3])<br />            {<br />                continue;<br />            }<br /><br />            // skip back facing triangles<br />            if (stri-&gt;facePlanes &amp;&amp; stri-&gt;facePlanesCalculated &amp;&amp;<br />                stri-&gt;facePlanes[triNum].Normal() * localInfo.boundingPlanes[NUM_DECAL_BOUNDING_PLANES - 2].Normal() &lt; -0.1f)<br />            {<br />                continue;<br />            }<br /><br />            // create a winding with texture coordinates for the triangle<br />            idFixedWinding fw;<br />            fw.SetNumPoints(3);<br /><br />            if (localInfo.parallel)<br />            {<br />                for (int j = 0; j &lt; 3; j++)<br />                {<br />                    fw[j] = stri-&gt;verts[stri-&gt;indexes[index + j]].xyz;<br />                    fw[j].s = localInfo.textureAxis[0].Distance(fw[j].ToVec3());<br />                    fw[j].t = localInfo.textureAxis[1].Distance(fw[j].ToVec3());<br />                }<br />            }<br />            else<br />            {<br />                for (int j = 0; j &lt; 3; j++)<br />                {<br />                    idVec3 dir;<br />                    float scale;<br /><br />                    fw[j] = stri-&gt;verts[stri-&gt;indexes[index + j]].xyz;<br />                    dir = fw[j].ToVec3() - localInfo.projectionOrigin;<br />                    localInfo.boundingPlanes[NUM_DECAL_BOUNDING_PLANES - 1].RayIntersection(fw[j].ToVec3(), dir, scale);<br />                    dir = fw[j].ToVec3() + scale * dir;<br />                    fw[j].s = localInfo.textureAxis[0].Distance(dir);<br />                    fw[j].t = localInfo.textureAxis[1].Distance(dir);<br />                }<br />            }<br /><br />            int orBits = cullBits[v1] | cullBits[v2] | cullBits[v3];<br /><br />            // clip the exact surface triangle to the projection volume<br />            for (int j = 0; j &lt; NUM_DECAL_BOUNDING_PLANES; j++)<br />            {<br />                if (orBits &amp; (1 &lt;&lt; j))<br />                {<br />                    if (!fw.ClipInPlace(-localInfo.boundingPlanes[j]))<br />                    {<br />                        break;<br />                    }<br />                }<br />            }<br /><br />            if (fw.GetNumPoints() == 0)<br />            {<br />                continue;<br />            }<br /><br />            AddDepthFadedWinding(fw, localInfo.material, localInfo.fadePlanes, localInfo.fadeDepth, localInfo.startTime);<br />        }<br />    }<br />}<br /></div></div>]]></body></post><post id="p245042" date="Posted: Sat Dec 29, 2012 1:36 pm "><author>BloodRayne</author><body><![CDATA[<div class="postbody">I've implemented a new feature into Grimm:Quest for the Gatherer's key that I'm very excited about. It's simply called 'spray painting' and what it does is allow for mappers to run their map and spray paint the world with decals. No more tedious placing of single plane decals to create static blood, but 'real' painting of the world with decals. I can now run a map, think <span style="font-style: italic">'I'd like to have some blood spray there'</span>, paint the world with a single click, issue the command 'saveDecals' when I am happy with the result and the paint will be there permanently in the map.<br /><br />To make this happen I have exposed a new script command via the SDK that calls 'projectDecalOntoWorld'.<br />I use this routine in a very simple entity called 'grimm_spray' which has several advantages over the regular func_spray.<br />The first advantage is that I can now use random paint decals, allowing for randomly looking worlds (which is what Grimm is all about).<br />The second is that players can turn the feature off, meaning that they can remove these decals for performance reasons, something that's not possible in a static map.<br /><br />There's no real way to describe it unless you see it in action, so I've created a nice video to show off the effect!<br /><br /><span style="font-weight: bold">Click image to play video</span><br /><a href="https://web.archive.org/web/20130319220556/http://www.youtube.com/watch?v=QeYBKp2nnCQ&amp;hd=1" class="postlink"><img src="https://web.archive.org/web/20130319220556im_/http://i48.tinypic.com/34jbry1.jpg" alt="Image" /></a><br /><br />When painting mode is not set, the spray entities spawn during mapload and paint the world, after which they are automatically removed, this will leave only the paint decal.<br />Players can set paint density, to have either more or less paint in the world.<br /><br />I'm pretty excited about this, I've managed to go over 6 maps in a matter of several hours and completely detailed them to taste with decals. This would have normally taken more than a week of careful placing of single decals by hand in the editor, with the added disadvantage of blood not spraying onto nearby objects and such.</div>]]></body></post><post id="p245050" date="Posted: Sun Dec 30, 2012 2:23 am "><author>Tron</author><body><![CDATA[<div class="postbody">Nice!  How many of these decals can you throw around until it starts impacting performance?</div>]]></body></post><post id="p245052" date="Posted: Sun Dec 30, 2012 3:21 am "><author>bladeghost</author><body><![CDATA[<div class="postbody">That's very interesting, can the same be done with grass,rocks and dirt?<br />you have some great talent there rayne.<br />good stuff!</div>]]></body></post><post id="p245054" date="Posted: Sun Dec 30, 2012 4:48 am "><author>BNA!</author><body><![CDATA[<div class="postbody">Oh that's nice!</div>]]></body></post><post id="p245055" date="Posted: Sun Dec 30, 2012 4:56 am "><author>The Happy Friar</author><body><![CDATA[<div class="postbody">That's VERY cool.  I always wondered why id didn't have that built in to D3.  Was there any special hurdles you had to jump over to get this working?</div>]]></body></post><post id="p245057" date="Posted: Sun Dec 30, 2012 7:22 am "><author>motorsep</author><body><![CDATA[<div class="postbody">Aren't those decals dynamic? (meaning you can only have so many of those on the level)</div>]]></body></post><post id="p245067" date="Posted: Sun Dec 30, 2012 10:33 am "><author>BloodRayne</author><body><![CDATA[<div class="postbody"><div class="quotetitle">Tron wrote:</div><div class="quotecontent">Nice!  How many of these decals can you throw around until it starts impacting performance?</div><br /><div class="quotetitle">motorsep wrote:</div><div class="quotecontent">Aren't those decals dynamic? (meaning you can only have so many of those on the level)</div><br />Numbers I'm not sure about, it's just a sprite so there's many. Performance starts to hurt when the decals overlap intersecting lights, so the challenge there is to minimize overlap, try to see them as lights and how lights hurt performance. So you quickly learn what works and what doesn't.<br />There is no hard set limit in my version of the engine.<br /><br /><div class="quotetitle">bladeghost wrote:</div><div class="quotecontent">That's very interesting, can the same be done with grass,rocks and dirt?<br />you have some great talent there rayne.<br />good stuff!</div><br />Any texture. But you can do random grass, rock and dirt model using the func_clutter entity that I made for Grimm which does random models. <img src="https://web.archive.org/web/20130319220556im_/http://www.doom3world.org/phpbb2/images/smilies/icon_smile.gif" alt=":)" title="Smile" /><br /><br /><div class="quotetitle">The Happy Friar wrote:</div><div class="quotecontent">That's VERY cool.  I always wondered why id didn't have that built in to D3.  Was there any special hurdles you had to jump over to get this working?</div><br />Yes, I'm working on making the decals save persistent, which they aren't now. When I quicksave/load the decals disappear, but that's easily fixable. Another hurdle was the angle. It just didn't want to spray in the correct angles, giving lots of stretches and other issues. I've manage to solve most of that but flukes still happen, in that case I simply undo the spray. The eventual code looks really simple, but it took me some time to get there..<img src="https://web.archive.org/web/20130319220556im_/http://www.doom3world.org/phpbb2/images/smilies/icon_smile.gif" alt=":)" title="Smile" /><br /><br />Code is work in progress, still some changes and cleanouts to be done.<br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">/* grimm --&gt; spraydecal<br />================<br />idEntity::Event_SprayDecal<br />================<br />*/<br />void idEntity::Event_SprayDecal( idVec3 *spray_origin, const char *mtr_decal, idVec3 *spray_angle, float size ) {<br /><br />   //srpay something<br />   idVec3 newangle = *spray_angle;   <br />   //gameLocal.Printf( "%s &lt;--current vector\n", spray_angle-&gt;ToString() );<br />   <br />   if ( spray_angle-&gt;x &lt;= -45 ) {<br />      newangle.z = 90;<br />   }<br />   if ( spray_angle-&gt;x &gt;= 45 ) {<br />      newangle.z = -90;<br />   }<br /><br />   gameLocal.ProjectDecal( *spray_origin, newangle, 256.0f, true, size, mtr_decal, 0, true );    <br />}<br /></div><br /><br />And I changed gameLocal.ProjectDecal somewhat:<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent"><br />/*<br />===============<br />idGameLocal::ProjectDecal<br />===============<br />*/<br />void idGameLocal::ProjectDecal( const idVec3 &amp;origin, const idVec3 &amp;dir, float depth, bool parallel, float size, const char *material, float angle, bool forever ) {<br />   float s, c;<br />   idMat3 axis, axistemp;<br />   idFixedWinding winding;<br />   idVec3 windingOrigin, projectionOrigin;<br /><br />   static idVec3 decalWinding[4] = {<br />      idVec3(  1.0f,  1.0f, 0.0f ),<br />      idVec3( -1.0f,  1.0f, 0.0f ),<br />      idVec3( -1.0f, -1.0f, 0.0f ),<br />      idVec3(  1.0f, -1.0f, 0.0f )<br />   };<br /><br />   if ( !g_decals.GetBool() ) {<br />      return;<br />   }<br /><br />   // randomly rotate the decal winding<br />   idMath::SinCos16( ( angle ) ? angle : random.RandomFloat() * idMath::TWO_PI, s, c );<br /><br />   // winding orientation<br />   axis[2] = dir;<br />   axis[2].Normalize();<br />   axis[2].NormalVectors( axistemp[0], axistemp[1] );<br />   axis[0] = axistemp[ 0 ] * c + axistemp[ 1 ] * -s;<br />   axis[1] = axistemp[ 0 ] * -s + axistemp[ 1 ] * -c;<br /><br />   windingOrigin = origin + depth * axis[2];<br />   if ( parallel ) {<br />      projectionOrigin = origin - depth * axis[2];<br />   } else {<br />      projectionOrigin = origin;<br />   }<br /><br />   size *= 0.5f;<br /><br />   winding.Clear();<br />   winding += idVec5( windingOrigin + ( axis * decalWinding[0] ) * size, idVec2( 1, 1 ) );<br />   winding += idVec5( windingOrigin + ( axis * decalWinding[1] ) * size, idVec2( 0, 1 ) );<br />   winding += idVec5( windingOrigin + ( axis * decalWinding[2] ) * size, idVec2( 0, 0 ) );<br />   winding += idVec5( windingOrigin + ( axis * decalWinding[3] ) * size, idVec2( 1, 0 ) );<br />   if ( forever ) {<br />      //27 hrs = 'forever' in game time..<br />      //gameLocal.Printf( "Project decal forever\n");<br />      gameRenderWorld-&gt;ProjectDecalOntoWorld( winding, projectionOrigin, parallel, depth * 0.5f, declManager-&gt;FindMaterial( material ), time + SEC2MS( 999999 ) );<br />   } else {<br />      //gameLocal.Printf( "Project decal for decalStay time\n");<br />      gameRenderWorld-&gt;ProjectDecalOntoWorld( winding, projectionOrigin, parallel, depth * 0.5f, declManager-&gt;FindMaterial( material ), time + SEC2MS( g_decalStay.GetFloat() ) );<br />   }<br />   <br />}<br /></div></div>]]></body></post><post id="p245072" date="Posted: Sun Dec 30, 2012 12:05 pm "><author>7318</author><body><![CDATA[<div class="postbody">that's awesome! <br />but with this you could easily surpass the entity limit, isn't it? we have to find a way to get a much bigger entity limit without affecting anything else, just have the capacity to have more stuff in the maps.</div>]]></body></post><post id="p245073" date="Posted: Sun Dec 30, 2012 12:16 pm "><author>BloodRayne</author><body><![CDATA[<div class="postbody"><div class="quotetitle">7318 wrote:</div><div class="quotecontent">that's awesome! <br />but with this you could easily surpass the entity limit, isn't it? we have to find a way to get a much bigger entity limit without affecting anything else, just have the capacity to have more stuff in the maps.</div><br />I currently have a 8192 entity limit. There's around 20-30 spray entities per map so that's no more than about 300 polygons max and 30 entities that are removed upon mapload. I could make it so that it doesn't use entities, but I want them to be available for tweaking afterwards in the editor, where you can give them specific sizes and paint materials etc..</div>]]></body></post><post id="p245080" date="Posted: Sun Dec 30, 2012 8:49 pm "><author>7318</author><body><![CDATA[<div class="postbody">what did you do in order to increase the max entity limit?</div>]]></body></post><post id="p245081" date="Posted: Mon Dec 31, 2012 6:13 am "><author>bkt</author><body><![CDATA[<div class="postbody">What would be great would be if when you 'savedecals' it would write the decals to the mapfile as func_statics (or regular brushes), which you could then finetune in the editor.</div>]]></body></post><post id="p245083" date="Posted: Mon Dec 31, 2012 8:31 am "><author>BloodRayne</author><body><![CDATA[<div class="postbody"><div class="quotetitle">7318 wrote:</div><div class="quotecontent">what did you do in order to increase the max entity limit?</div><br />Simply raised it (it's a variable gameLocal), I searched D3World for it actually, there's a post on it somewhere. <img src="https://web.archive.org/web/20130319220556im_/http://www.doom3world.org/phpbb2/images/smilies/icon_smile.gif" alt=":)" title="Smile" /><br /><br /><div class="quotetitle">bkt wrote:</div><div class="quotecontent">What would be great would be if when you 'savedecals' it would write the decals to the mapfile as func_statics (or regular brushes), which you could then finetune in the editor.</div><br />I actually didn't want to do that because I want to be able to quickly change the decals (and randomly change them).<br />Also, one spray can have multiple decals as it sprays on different objects at once.</div>]]></body></post><post id="p245084" date="Posted: Mon Dec 31, 2012 8:36 am "><author>motorsep</author><body><![CDATA[<div class="postbody">How would you do such decaling in DarkRadiant (so decals end up projected on any kind of curvature in-game) ?<br /><br />Do those decals work the same way as blood / burn marks in-game? If so, I encountered huge fps drop when I shop my player's model to turn it black (~5 decals will kill performance).</div>]]></body></post><post id="p245085" date="Posted: Mon Dec 31, 2012 8:41 am "><author>BloodRayne</author><body><![CDATA[<div class="postbody"><div class="quotetitle">motorsep wrote:</div><div class="quotecontent">How would you do such decaling in DarkRadiant (so decals end up projected on any kind of curvature in-game) ?</div><br />I don't use DarkRadiant so I have no idea, I guess the same as I would do them in DoomEdit, e.g. place a square and texture it?<br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Do those decals work the same way as blood / burn marks in-game? If so, I encountered huge fps drop when I shop my player's model to turn it black (~5 decals will kill performance).</div><br />They use ProjectDecal and there are the same performance issues there as with regular burn marks. This is a mapper's tool, to be used by a mapper that has knowledge of where to place these decals. The performance issues come from overlapping lights, creating draws and depend on which texture you use. As long as you stick with 1-2 decals per surface performance is fine.</div>]]></body></post><post id="p245086" date="Posted: Mon Dec 31, 2012 8:46 am "><author>motorsep</author><body><![CDATA[<div class="postbody">Ahh, gotcha <img src="https://web.archive.org/web/20130319220556im_/http://www.doom3world.org/phpbb2/images/smilies/icon_sad.gif" alt=":(" title="Sad" /> I thought you are using something else to project decals. That's why maybe idSoftware did use that method because it's limiting. I wonder how to resolve this issue with performance (make decals not interact with lights?).</div>]]></body></post><post id="p245088" date="Posted: Mon Dec 31, 2012 8:50 am "><author>BloodRayne</author><body><![CDATA[<div class="postbody"><div class="quotetitle">motorsep wrote:</div><div class="quotecontent">Ahh, gotcha <img src="https://web.archive.org/web/20130319220556im_/http://www.doom3world.org/phpbb2/images/smilies/icon_sad.gif" alt=":(" title="Sad" /> I thought you are using something else to project decals. That's why maybe idSoftware did use that method because it's limiting. I wonder how to resolve this issue with performance (make decals not interact with lights?).</div><br />I am developing Grimm in two phases.<br /><br />Phase 1 consists only of source-code fixes that are SDK related. ProjectDecalOntoWorld is a function that's available from inside the GPL code base, Phase 2 will consist of all those changes I couldn't make via the SDK.  It's my plan to look into this again in phase 2 and perhaps create my own routine for it. My knowledge concerning the codebase is growing by the day and I'm nearly at the point where I can start feeling comfortable in calling myself an 'idtech 4' programmer.. Not there yet.. but getting there!</div>]]></body></post><post id="p245089" date="Posted: Mon Dec 31, 2012 8:55 am "><author>motorsep</author><body><![CDATA[<div class="postbody">cool stuff!</div>]]></body></post><post id="p245090" date="Posted: Mon Dec 31, 2012 9:02 am "><author>jmarshall23</author><body><![CDATA[<div class="postbody">Very nice now just put it in the editor : ).</div>]]></body></post><post id="p245105" date="Posted: Mon Dec 31, 2012 8:56 pm "><author>nbohr1more</author><body><![CDATA[<div class="postbody">Dark Radiant has an auto decal feature:<br /><br /><br /><!-- m --><a class="postlink" href="https://web.archive.org/web/20130319220556/http://wiki.thedarkmod.com/index.php?title=Decals">http://wiki.thedarkmod.com/index.php?title=Decals</a><!-- m --><br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">To create decals, select the surface you want to make a decal for (in <span style="font-weight: bold">select face mode</span> or with SHIFT+CTRL+Click the left mouse button). Press the “create Decals for selected Faces” button, it will create a patch for each selected face, which will be exactly in the same plane. Another way to create a decal is create patch yourself and place it were you want. Assign a texture to it from the Media browser, the texture browser or with the surface inspector. <br /></div><br /><br />It doesn't look as fun as this though...</div>]]></body></post><post id="p245110" date="Posted: Mon Dec 31, 2012 11:59 pm "><author>motorsep</author><body><![CDATA[<div class="postbody">How does it get projected though? On runtime ?</div>]]></body></post><post id="p245124" date="Posted: Tue Jan 01, 2013 7:39 am "><author>Serpentine</author><body><![CDATA[<div class="postbody"><div class="quotetitle">motorsep wrote:</div><div class="quotecontent">How does it get projected though? On runtime ?</div><br />This question makes very little sense. wat.</div>]]></body></post><post id="p245126" date="Posted: Tue Jan 01, 2013 7:46 am "><author>BloodRayne</author><body><![CDATA[<div class="postbody"><div class="quotetitle">Serpentine wrote:</div><div class="quotecontent"><div class="quotetitle">motorsep wrote:</div><div class="quotecontent">How does it get projected though? On runtime ?</div><br />This question makes very little sense. wat.</div><br />I think he missed the part where I actually posed source code.  <img src="https://web.archive.org/web/20130319220549im_/http://www.doom3world.org/phpbb2/images/smilies/icon_mrgreen.gif" alt=":mrgreen:" title="Mr. Green" /><br /><br /><div class="quotetitle">nbohr1more wrote:</div><div class="quotecontent">Dark Radiant has an auto decal feature:<br /><br /><br /><!-- m --><a class="postlink" href="https://web.archive.org/web/20130319220549/http://wiki.thedarkmod.com/index.php?title=Decals">http://wiki.thedarkmod.com/index.php?title=Decals</a><!-- m --><br /><br /><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">To create decals, select the surface you want to make a decal for (in <span style="font-weight: bold">select face mode</span> or with SHIFT+CTRL+Click the left mouse button). Press the “create Decals for selected Faces” button, it will create a patch for each selected face, which will be exactly in the same plane. Another way to create a decal is create patch yourself and place it were you want. Assign a texture to it from the Media browser, the texture browser or with the surface inspector. <br /></div><br /><br />It doesn't look as fun as this though...</div><br /><br />This does seem like a robust way to handle things as well. But it makes things static and give you much less control than in my current setup, which is basically like hanging spraycans in the world which spray their stuff upon mapload and restore, no editing of any kind, no offsetting or texturing needed.</div>]]></body></post><post id="p245128" date="Posted: Tue Jan 01, 2013 7:52 am "><author>motorsep</author><body><![CDATA[<div class="postbody">No, I was asking about DarkRadiant's method. How does flat patch with decal material get projected onto the world?</div>]]></body></post><post id="p245185" date="Posted: Tue Jan 01, 2013 6:02 pm "><author>nbohr1more</author><body><![CDATA[<div class="postbody">The patches are created as any other patches would be. They are map geometry rather than<br />generated entities. (Though you could use the SEED system to generate a bunch of patch models<br />randomly if you wanted.) The only thing special is that you don't need to meticulously create and align<br />the patches (and move them into position) yourself. <br />You just select the surfaces and Dark Radiant creates the patches for you with the right size and alignment.<br /><br />As far as entity usage. One trick that we tend to advise for decorative grime patches is to merge them into<br />a single func_static entity. You could also do this with BloodRayne's method since it looks like you are saving <br />the decals to the map via a console action. You'd just need to crack open the editor, find the decal patches and mark them<br />as part of the same func_static entity. Though it would kinda defeat the purpose of having an easy free-form<br />workflow...</div>]]></body></post><post id="p245186" date="Posted: Tue Jan 01, 2013 6:45 pm "><author>BloodRayne</author><body><![CDATA[<div class="postbody"><div class="quotetitle">nbohr1more wrote:</div><div class="quotecontent">As far as entity usage. One trick that we tend to advise for decorative grime patches is to merge them into<br />a single func_static entity. You could also do this with BloodRayne's method since it looks like you are saving <br />the decals to the map via a console action. You'd just need to crack open the editor, find the decal patches and mark them<br />as part of the same func_static entity. Though it would kinda defeat the purpose of having an easy free-form<br />workflow...</div><br />Actually, they are func_static entities that project a decal, nothing more.<br />They do it upon map load/restore. (Meaning that if you do a 'reloadModels' or 'vid_restart' the decals disappear), but will fix that soon as well. There's nothing in the editor but these entities to see/edit. You can give their projected decal an angle, set a mtr_decal key (or have it choose a random decal for you) and set spray size. These entities don't create map geometry other than the decals needed.</div>]]></body></post><post id="p245187" date="Posted: Tue Jan 01, 2013 8:53 pm "><author>nbohr1more</author><body><![CDATA[<div class="postbody">OK. So they are like SEED entities or Particle emitters then.<br /><br />This might come in handy for TDM after all... Especially since distributing SEED entities on anything other than<br />a gravity-based orientation has proven a challenge. If these emitters project spherically then this would solve<br />issues like spawning rocks or vegetation in a cylindrical cave area.</div>]]></body></post><post id="p245188" date="Posted: Tue Jan 01, 2013 8:59 pm "><author>BloodRayne</author><body><![CDATA[<div class="postbody"><div class="quotetitle">nbohr1more wrote:</div><div class="quotecontent">OK. So they are like SEED entities or Particle emitters then.<br /><br />This might come in handy for TDM after all... Especially since distributing SEED entities on anything other than<br />a gravity-based orientation has proven a challenge. If these emitters project spherically then this would solve<br />issues like spawning rocks or vegetation in a cylindrical cave area.</div><br />The engine can do that, look into ProjectDecalOntoWorld in RenderWorld.cpp and modelDecal.cpp.<br />Mind you, that's just a starting point, I haven't done anything with these. My changes were made solely in entity.cpp. <img src="https://web.archive.org/web/20130319220549im_/http://www.doom3world.org/phpbb2/images/smilies/icon_smile.gif" alt=":)" title="Smile" /><br /><br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">/*<br />================<br />idRenderWorldLocal::ProjectDecalOntoWorld<br />================<br />*/<br />void idRenderWorldLocal::ProjectDecalOntoWorld(const idFixedWinding &amp;winding, const idVec3 &amp;projectionOrigin, const bool parallel, const float fadeDepth, const idMaterial *material, const int startTime)<br />{<br />    int i, areas[10], numAreas;<br />    const areaReference_t *ref;<br />    const portalArea_t *area;<br />    const idRenderModel *model;<br />    idRenderEntityLocal *def;<br />    decalProjectionInfo_t info, localInfo;<br /><br />    if (!idRenderModelDecal::CreateProjectionInfo(info, winding, projectionOrigin, parallel, fadeDepth, material, startTime))<br />    {<br />        return;<br />    }<br /><br />    // get the world areas touched by the projection volume<br />    numAreas = BoundsInAreas(info.projectionBounds, areas, 10);<br /><br />    // check all areas for models<br />    for (i = 0; i &lt; numAreas; i++)<br />    {<br /><br />        area = &amp;portalAreas[ areas[i] ];<br /><br />        // check all models in this area<br />        for (ref = area-&gt;entityRefs.areaNext; ref != &amp;area-&gt;entityRefs; ref = ref-&gt;areaNext)<br />        {<br />            def = ref-&gt;entity;<br /><br />            // completely ignore any dynamic or callback models<br />            model = def-&gt;parms.hModel;<br /><br />            if (model == NULL || model-&gt;IsDynamicModel() != DM_STATIC || def-&gt;parms.callback)<br />            {<br />                continue;<br />            }<br /><br />            if (def-&gt;parms.customShader != NULL &amp;&amp; !def-&gt;parms.customShader-&gt;AllowOverlays())<br />            {<br />                continue;<br />            }<br /><br />            idBounds bounds;<br />            bounds.FromTransformedBounds(model-&gt;Bounds(&amp;def-&gt;parms), def-&gt;parms.origin, def-&gt;parms.axis);<br /><br />            // if the model bounds do not overlap with the projection bounds<br />            if (!info.projectionBounds.IntersectsBounds(bounds))<br />            {<br />                continue;<br />            }<br /><br />            // transform the bounding planes, fade planes and texture axis into local space<br />            idRenderModelDecal::GlobalProjectionInfoToLocal(localInfo, info, def-&gt;parms.origin, def-&gt;parms.axis);<br />            localInfo.force = (def-&gt;parms.customShader != NULL);<br /><br />            if (!def-&gt;decals)<br />            {<br />                def-&gt;decals = idRenderModelDecal::Alloc();<br />            }<br /><br />            def-&gt;decals-&gt;CreateDecal(model, localInfo);<br />        }<br />    }<br />}<br /><br />/*<br />====================<br />idRenderWorldLocal::ProjectDecal<br />====================<br />*/<br />void idRenderWorldLocal::ProjectDecal(qhandle_t entityHandle, const idFixedWinding &amp;winding, const idVec3 &amp;projectionOrigin, const bool parallel, const float fadeDepth, const idMaterial *material, const int startTime)<br />{<br />    decalProjectionInfo_t info, localInfo;<br /><br />    if (entityHandle &lt; 0 || entityHandle &gt;= entityDefs.Num())<br />    {<br />        common-&gt;Error("idRenderWorld::ProjectOverlay: index = %i", entityHandle);<br />        return;<br />    }<br /><br />    idRenderEntityLocal   *def = entityDefs[ entityHandle ];<br /><br />    if (!def)<br />    {<br />        return;<br />    }<br /><br />    const idRenderModel *model = def-&gt;parms.hModel;<br /><br />    if (model == NULL || model-&gt;IsDynamicModel() != DM_STATIC || def-&gt;parms.callback)<br />    {<br />        return;<br />    }<br /><br />    if (!idRenderModelDecal::CreateProjectionInfo(info, winding, projectionOrigin, parallel, fadeDepth, material, startTime))<br />    {<br />        return;<br />    }<br /><br />    idBounds bounds;<br />    bounds.FromTransformedBounds(model-&gt;Bounds(&amp;def-&gt;parms), def-&gt;parms.origin, def-&gt;parms.axis);<br /><br />    // if the model bounds do not overlap with the projection bounds<br />    if (!info.projectionBounds.IntersectsBounds(bounds))<br />    {<br />        return;<br />    }<br /><br />    // transform the bounding planes, fade planes and texture axis into local space<br />    idRenderModelDecal::GlobalProjectionInfoToLocal(localInfo, info, def-&gt;parms.origin, def-&gt;parms.axis);<br />    localInfo.force = (def-&gt;parms.customShader != NULL);<br /><br />    if (def-&gt;decals == NULL)<br />    {<br />        def-&gt;decals = idRenderModelDecal::Alloc();<br />    }<br /><br />    def-&gt;decals-&gt;CreateDecal(model, localInfo);<br />}<br /><br />/*<br />====================<br />idRenderWorldLocal::ProjectOverlay<br />====================<br />*/<br />void idRenderWorldLocal::ProjectOverlay(qhandle_t entityHandle, const idPlane localTextureAxis[2], const idMaterial *material)<br />{<br /><br />    if (entityHandle &lt; 0 || entityHandle &gt;= entityDefs.Num())<br />    {<br />        common-&gt;Error("idRenderWorld::ProjectOverlay: index = %i", entityHandle);<br />        return;<br />    }<br /><br />    idRenderEntityLocal   *def = entityDefs[ entityHandle ];<br /><br />    if (!def)<br />    {<br />        return;<br />    }<br /><br />    const renderEntity_t *refEnt = &amp;def-&gt;parms;<br /><br />    idRenderModel *model = refEnt-&gt;hModel;<br /><br />    if (model-&gt;IsDynamicModel() != DM_CACHED)     // FIXME: probably should be MD5 only<br />    {<br />        return;<br />    }<br /><br />    model = R_EntityDefDynamicModel(def);<br /><br />    if (def-&gt;overlay == NULL)<br />    {<br />        def-&gt;overlay = idRenderModelOverlay::Alloc();<br />    }<br /><br />    def-&gt;overlay-&gt;CreateOverlay(model, localTextureAxis, material);<br />}<br /></div><br /><br />And ModelDecl.cpp<br /><div class="codetitle"><b>Code:</b></div><div class="codecontent">/*<br />=================<br />idRenderModelDecal::CreateProjectionInfo<br />=================<br />*/<br />bool idRenderModelDecal::CreateProjectionInfo(decalProjectionInfo_t &amp;info, const idFixedWinding &amp;winding, const idVec3 &amp;projectionOrigin, const bool parallel, const float fadeDepth, const idMaterial *material, const int startTime)<br />{<br /><br />    if (winding.GetNumPoints() != NUM_DECAL_BOUNDING_PLANES - 2)<br />    {<br />        common-&gt;Printf("idRenderModelDecal::CreateProjectionInfo: winding must have %d points\n", NUM_DECAL_BOUNDING_PLANES - 2);<br />        return false;<br />    }<br /><br />    assert(material != NULL);<br /><br />    info.projectionOrigin = projectionOrigin;<br />    info.material = material;<br />    info.parallel = parallel;<br />    info.fadeDepth = fadeDepth;<br />    info.startTime = startTime;<br />    info.force = false;<br /><br />    // get the winding plane and the depth of the projection volume<br />    idPlane windingPlane;<br />    winding.GetPlane(windingPlane);<br />    float depth = windingPlane.Distance(projectionOrigin);<br /><br />    // find the bounds for the projection<br />    winding.GetBounds(info.projectionBounds);<br /><br />    if (parallel)<br />    {<br />        info.projectionBounds.ExpandSelf(depth);<br />    }<br />    else<br />    {<br />        info.projectionBounds.AddPoint(projectionOrigin);<br />    }<br /><br />    // calculate the world space projection volume bounding planes, positive sides face outside the decal<br />    if (parallel)<br />    {<br />        for (int i = 0; i &lt; winding.GetNumPoints(); i++)<br />        {<br />            idVec3 edge = winding[(i + 1) % winding.GetNumPoints()].ToVec3() - winding[i].ToVec3();<br />            info.boundingPlanes[i].Normal().Cross(windingPlane.Normal(), edge);<br />            info.boundingPlanes[i].Normalize();<br />            info.boundingPlanes[i].FitThroughPoint(winding[i].ToVec3());<br />        }<br />    }<br />    else<br />    {<br />        for (int i = 0; i &lt; winding.GetNumPoints(); i++)<br />        {<br />            info.boundingPlanes[i].FromPoints(projectionOrigin, winding[i].ToVec3(), winding[(i + 1) % winding.GetNumPoints()].ToVec3());<br />        }<br />    }<br /><br />    info.boundingPlanes[NUM_DECAL_BOUNDING_PLANES - 2] = windingPlane;<br />    info.boundingPlanes[NUM_DECAL_BOUNDING_PLANES - 2][3] -= depth;<br />    info.boundingPlanes[NUM_DECAL_BOUNDING_PLANES - 1] = -windingPlane;<br /><br />    // fades will be from these plane<br />    info.fadePlanes[0] = windingPlane;<br />    info.fadePlanes[0][3] -= fadeDepth;<br />    info.fadePlanes[1] = -windingPlane;<br />    info.fadePlanes[1][3] += depth - fadeDepth;<br /><br />    // calculate the texture vectors for the winding<br />    float   len, texArea, inva;<br />    idVec3   temp;<br />    idVec5   d0, d1;<br /><br />    const idVec5 &amp;a = winding[0];<br />    const idVec5 &amp;b = winding[1];<br />    const idVec5 &amp;c = winding[2];<br /><br />    d0 = b.ToVec3() - a.ToVec3();<br />    d0.s = b.s - a.s;<br />    d0.t = b.t - a.t;<br />    d1 = c.ToVec3() - a.ToVec3();<br />    d1.s = c.s - a.s;<br />    d1.t = c.t - a.t;<br /><br />    texArea = (d0[3] * d1[4]) - (d0[4] * d1[3]);<br />    inva = 1.0f / texArea;<br /><br />    temp[0] = (d0[0] * d1[4] - d0[4] * d1[0]) * inva;<br />    temp[1] = (d0[1] * d1[4] - d0[4] * d1[1]) * inva;<br />    temp[2] = (d0[2] * d1[4] - d0[4] * d1[2]) * inva;<br />    len = temp.Normalize();<br />    info.textureAxis[0].Normal() = temp * (1.0f / len);<br />    info.textureAxis[0][3] = winding[0].s - (winding[0].ToVec3() * info.textureAxis[0].Normal());<br /><br />    temp[0] = (d0[3] * d1[0] - d0[0] * d1[3]) * inva;<br />    temp[1] = (d0[3] * d1[1] - d0[1] * d1[3]) * inva;<br />    temp[2] = (d0[3] * d1[2] - d0[2] * d1[3]) * inva;<br />    len = temp.Normalize();<br />    info.textureAxis[1].Normal() = temp * (1.0f / len);<br />    info.textureAxis[1][3] = winding[0].t - (winding[0].ToVec3() * info.textureAxis[1].Normal());<br /><br />    return true;<br />}<br /><br />/*<br />=================<br />idRenderModelDecal::CreateProjectionInfo<br />=================<br />*/<br />void idRenderModelDecal::GlobalProjectionInfoToLocal(decalProjectionInfo_t &amp;localInfo, const decalProjectionInfo_t &amp;info, const idVec3 &amp;origin, const idMat3 &amp;axis)<br />{<br />    float modelMatrix[16];<br /><br />    R_AxisToModelMatrix(axis, origin, modelMatrix);<br /><br />    for (int j = 0; j &lt; NUM_DECAL_BOUNDING_PLANES; j++)<br />    {<br />        R_GlobalPlaneToLocal(modelMatrix, info.boundingPlanes[j], localInfo.boundingPlanes[j]);<br />    }<br /><br />    R_GlobalPlaneToLocal(modelMatrix, info.fadePlanes[0], localInfo.fadePlanes[0]);<br />    R_GlobalPlaneToLocal(modelMatrix, info.fadePlanes[1], localInfo.fadePlanes[1]);<br />    R_GlobalPlaneToLocal(modelMatrix, info.textureAxis[0], localInfo.textureAxis[0]);<br />    R_GlobalPlaneToLocal(modelMatrix, info.textureAxis[1], localInfo.textureAxis[1]);<br />    R_GlobalPointToLocal(modelMatrix, info.projectionOrigin, localInfo.projectionOrigin);<br />    localInfo.projectionBounds = info.projectionBounds;<br />    localInfo.projectionBounds.TranslateSelf(-origin);<br />    localInfo.projectionBounds.RotateSelf(axis.Transpose());<br />    localInfo.material = info.material;<br />    localInfo.parallel = info.parallel;<br />    localInfo.fadeDepth = info.fadeDepth;<br />    localInfo.startTime = info.startTime;<br />    localInfo.force = info.force;<br />}<br /><br />/*<br />=================<br />idRenderModelDecal::AddWinding<br />=================<br />*/<br />void idRenderModelDecal::AddWinding(const idWinding &amp;w, const idMaterial *decalMaterial, const idPlane fadePlanes[2], float fadeDepth, int startTime)<br />{<br />    int i;<br />    float invFadeDepth, fade;<br />    decalInfo_t   decalInfo;<br /><br />    if ((material == NULL || material == decalMaterial) &amp;&amp;<br />        tri.numVerts + w.GetNumPoints() &lt; MAX_DECAL_VERTS &amp;&amp;<br />        tri.numIndexes + (w.GetNumPoints() - 2) * 3 &lt; MAX_DECAL_INDEXES)<br />    {<br /><br />        material = decalMaterial;<br /><br />        // add to this decal<br />        decalInfo = material-&gt;GetDecalInfo();<br />        invFadeDepth = -1.0f / fadeDepth;<br /><br />        for (i = 0; i &lt; w.GetNumPoints(); i++)<br />        {<br />            fade = fadePlanes[0].Distance(w[i].ToVec3()) * invFadeDepth;<br /><br />            if (fade &lt; 0.0f)<br />            {<br />                fade = fadePlanes[1].Distance(w[i].ToVec3()) * invFadeDepth;<br />            }<br /><br />            if (fade &lt; 0.0f)<br />            {<br />                fade = 0.0f;<br />            }<br />            else if (fade &gt; 0.99f)<br />            {<br />                fade = 1.0f;<br />            }<br /><br />            fade = 1.0f - fade;<br />            vertDepthFade[tri.numVerts + i] = fade;<br />            tri.verts[tri.numVerts + i].xyz = w[i].ToVec3();<br />            tri.verts[tri.numVerts + i].st[0] = w[i].s;<br />            tri.verts[tri.numVerts + i].st[1] = w[i].t;<br /><br />            for (int k = 0; k &lt; 4; k++)<br />            {<br />                int icolor = idMath::FtoiFast(decalInfo.start[k] * fade * 255.0f);<br /><br />                if (icolor &lt; 0)<br />                {<br />                    icolor = 0;<br />                }<br />                else if (icolor &gt; 255)<br />                {<br />                    icolor = 255;<br />                }<br /><br />                tri.verts[tri.numVerts + i].color[k] = icolor;<br />            }<br />        }<br /><br />        for (i = 2; i &lt; w.GetNumPoints(); i++)<br />        {<br />            tri.indexes[tri.numIndexes + 0] = tri.numVerts;<br />            tri.indexes[tri.numIndexes + 1] = tri.numVerts + i - 1;<br />            tri.indexes[tri.numIndexes + 2] = tri.numVerts + i;<br />            indexStartTime[tri.numIndexes] =<br />                indexStartTime[tri.numIndexes + 1] =<br />                    indexStartTime[tri.numIndexes + 2] = startTime;<br />            tri.numIndexes += 3;<br />        }<br /><br />        tri.numVerts += w.GetNumPoints();<br />        return;<br />    }<br /><br />    // if we are at the end of the list, create a new decal<br />    if (!nextDecal)<br />    {<br />        nextDecal = idRenderModelDecal::Alloc();<br />    }<br /><br />    // let the next decal on the chain take a look<br />    nextDecal-&gt;AddWinding(w, decalMaterial, fadePlanes, fadeDepth, startTime);<br />}<br /><br />/*<br />=================<br />idRenderModelDecal::AddDepthFadedWinding<br />=================<br />*/<br />void idRenderModelDecal::AddDepthFadedWinding(const idWinding &amp;w, const idMaterial *decalMaterial, const idPlane fadePlanes[2], float fadeDepth, int startTime)<br />{<br />    idFixedWinding front, back;<br /><br />    front = w;<br /><br />    if (front.Split(&amp;back, fadePlanes[0], 0.1f) == SIDE_CROSS)<br />    {<br />        AddWinding(back, decalMaterial, fadePlanes, fadeDepth, startTime);<br />    }<br /><br />    if (front.Split(&amp;back, fadePlanes[1], 0.1f) == SIDE_CROSS)<br />    {<br />        AddWinding(back, decalMaterial, fadePlanes, fadeDepth, startTime);<br />    }<br /><br />    AddWinding(front, decalMaterial, fadePlanes, fadeDepth, startTime);<br />}<br /><br />/*<br />=================<br />idRenderModelDecal::CreateDecal<br />=================<br />*/<br />void idRenderModelDecal::CreateDecal(const idRenderModel *model, const decalProjectionInfo_t &amp;localInfo)<br />{<br /><br />    // check all model surfaces<br />    for (int surfNum = 0; surfNum &lt; model-&gt;NumSurfaces(); surfNum++)<br />    {<br />        const modelSurface_t *surf = model-&gt;Surface(surfNum);<br /><br />        // if no geometry or no shader<br />        if (!surf-&gt;geometry || !surf-&gt;shader)<br />        {<br />            continue;<br />        }<br /><br />        // decals and overlays use the same rules<br />        if (!localInfo.force &amp;&amp; !surf-&gt;shader-&gt;AllowOverlays())<br />        {<br />            continue;<br />        }<br /><br />        srfTriangles_t *stri = surf-&gt;geometry;<br /><br />        // if the triangle bounds do not overlap with projection bounds<br />        if (!localInfo.projectionBounds.IntersectsBounds(stri-&gt;bounds))<br />        {<br />            continue;<br />        }<br /><br />        // allocate memory for the cull bits<br />        byte *cullBits = (byte *) _alloca16(stri-&gt;numVerts * sizeof(cullBits[0]));<br /><br />        // catagorize all points by the planes<br />        SIMDProcessor-&gt;DecalPointCull(cullBits, localInfo.boundingPlanes, stri-&gt;verts, stri-&gt;numVerts);<br /><br />        // find triangles inside the projection volume<br />        for (int triNum = 0, index = 0; index &lt; stri-&gt;numIndexes; index += 3, triNum++)<br />        {<br />            int v1 = stri-&gt;indexes[index + 0];<br />            int v2 = stri-&gt;indexes[index + 1];<br />            int v3 = stri-&gt;indexes[index + 2];<br /><br />            // skip triangles completely off one side<br />            if (cullBits[v1] &amp; cullBits[v2] &amp; cullBits[v3])<br />            {<br />                continue;<br />            }<br /><br />            // skip back facing triangles<br />            if (stri-&gt;facePlanes &amp;&amp; stri-&gt;facePlanesCalculated &amp;&amp;<br />                stri-&gt;facePlanes[triNum].Normal() * localInfo.boundingPlanes[NUM_DECAL_BOUNDING_PLANES - 2].Normal() &lt; -0.1f)<br />            {<br />                continue;<br />            }<br /><br />            // create a winding with texture coordinates for the triangle<br />            idFixedWinding fw;<br />            fw.SetNumPoints(3);<br /><br />            if (localInfo.parallel)<br />            {<br />                for (int j = 0; j &lt; 3; j++)<br />                {<br />                    fw[j] = stri-&gt;verts[stri-&gt;indexes[index + j]].xyz;<br />                    fw[j].s = localInfo.textureAxis[0].Distance(fw[j].ToVec3());<br />                    fw[j].t = localInfo.textureAxis[1].Distance(fw[j].ToVec3());<br />                }<br />            }<br />            else<br />            {<br />                for (int j = 0; j &lt; 3; j++)<br />                {<br />                    idVec3 dir;<br />                    float scale;<br /><br />                    fw[j] = stri-&gt;verts[stri-&gt;indexes[index + j]].xyz;<br />                    dir = fw[j].ToVec3() - localInfo.projectionOrigin;<br />                    localInfo.boundingPlanes[NUM_DECAL_BOUNDING_PLANES - 1].RayIntersection(fw[j].ToVec3(), dir, scale);<br />                    dir = fw[j].ToVec3() + scale * dir;<br />                    fw[j].s = localInfo.textureAxis[0].Distance(dir);<br />                    fw[j].t = localInfo.textureAxis[1].Distance(dir);<br />                }<br />            }<br /><br />            int orBits = cullBits[v1] | cullBits[v2] | cullBits[v3];<br /><br />            // clip the exact surface triangle to the projection volume<br />            for (int j = 0; j &lt; NUM_DECAL_BOUNDING_PLANES; j++)<br />            {<br />                if (orBits &amp; (1 &lt;&lt; j))<br />                {<br />                    if (!fw.ClipInPlace(-localInfo.boundingPlanes[j]))<br />                    {<br />                        break;<br />                    }<br />                }<br />            }<br /><br />            if (fw.GetNumPoints() == 0)<br />            {<br />                continue;<br />            }<br /><br />            AddDepthFadedWinding(fw, localInfo.material, localInfo.fadePlanes, localInfo.fadeDepth, localInfo.startTime);<br />        }<br />    }<br />}<br /></div></div>]]></body></post></posts></thread></xml>
